{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Nominatim (from the Latin, 'by name') is a tool to search OSM data by name and address and to generate synthetic addresses of OSM points (reverse geocoding). It has also limited capability to search features by their type (pubs, hotels, churches, etc).</p> <p>This guide comes in five parts:</p> <ul> <li>API reference for users of Nominatim</li> <li>Administration Guide for those who want    to install their own Nominatim server</li> <li>Customization Guide for those who want to    adapt their own installation to their special requirements</li> <li>Library Guide for Python developers who    want to use Nominatim as a library in their project</li> <li>Developer's Guide for developers of the software</li> </ul>"},{"location":"admin/Advanced-Installations/","title":"Advanced installations","text":"<p>This page contains instructions for setting up multiple countries in  your Nominatim database. It is assumed that you have already successfully installed the Nominatim software itself, if not return to the  installation page.</p>"},{"location":"admin/Advanced-Installations/#importing-with-a-database-user-without-superuser-rights","title":"Importing with a database user without superuser rights","text":"<p>Nominatim usually creates its own PostgreSQL database at the beginning of the import process. This makes usage easier for the user but means that the database user doing the import needs the appropriate rights.</p> <p>If you prefer to run the import with a database user with limited rights, you can do so by changing the import process as follows:</p> <ol> <li>Run the command for database preparation with a database user with    superuser rights. For example, to use a db user 'dbadmin' for a    database 'nominatim', execute:</li> </ol> <pre><code>NOMINATIM_DATABASE_DSN=\"pgsql:dbname=nominatim;user=dbadmin\" nominatim import --prepare-database\n</code></pre> <ol> <li>Grant the import user the right to create tables. For example, foe user 'import-user':</li> </ol> <pre><code>psql -d nominatim -c 'GRANT CREATE ON SCHEMA public TO \"import-user\"'\n</code></pre> <ol> <li>Now run the reminder of the import with the import user:</li> </ol> <pre><code>NOMINATIM_DATABASE_DSN=\"pgsql:dbname=nominatim;user=import-user\" nominatim import --continue import-from-file --osm-file file.pbf\n</code></pre>"},{"location":"admin/Advanced-Installations/#importing-multiple-regions-without-updates","title":"Importing multiple regions (without updates)","text":"<p>To import multiple regions in your database you can simply give multiple OSM files to the import command:</p> <pre><code>nominatim import --osm-file file1.pbf --osm-file file2.pbf\n</code></pre> <p>If you already have imported a file and want to add another one, you can use the add-data function to import the additional data as follows:</p> <pre><code>nominatim add-data --file &lt;FILE&gt;\nnominatim refresh --postcodes\nnominatim index -j &lt;NUMBER OF THREADS&gt;\n</code></pre> <p>Please note that adding additional data is always significantly slower than the original import.</p>"},{"location":"admin/Advanced-Installations/#importing-multiple-regions-with-updates","title":"Importing multiple regions (with updates)","text":"<p>If you want to import multiple regions and be able to keep them up-to-date with updates, then you can use the scripts provided in the <code>utils</code> directory.</p> <p>These scripts will set up an <code>update</code> directory in your project directory, which has the following structure:</p> <pre><code>update\n \u251c\u2500\u2500 europe\n \u2502    \u251c\u2500\u2500 andorra\n \u2502    \u2502    \u2514\u2500\u2500 sequence.state\n \u2502    \u2514\u2500\u2500 monaco\n \u2502         \u2514\u2500\u2500 sequence.state\n \u2514\u2500\u2500 tmp\n      \u2514\u2500\u2500 europe\n           \u251c\u2500\u2500 andorra-latest.osm.pbf\n           \u2514\u2500\u2500 monaco-latest.osm.pbf\n</code></pre> <p>The <code>sequence.state</code> files contain the sequence ID for each region. They will be used by pyosmium to get updates. The <code>tmp</code> folder is used for import dump and can be deleted once the import is complete.</p>"},{"location":"admin/Advanced-Installations/#setting-up-multiple-regions","title":"Setting up multiple regions","text":"<p>Create a project directory as described for the simple import. If necessary, you can also add an <code>.env</code> configuration with customized options. In particular, you need to make sure that <code>NOMINATIM_REPLICATION_UPDATE_INTERVAL</code> and <code>NOMINATIM_REPLICATION_RECHECK_INTERVAL</code> are set according to the update interval of the extract server you use.</p> <p>Copy the scripts <code>utils/import_multiple_regions.sh</code> and <code>utils/update_database.sh</code> into the project directory.</p> <p>Now customize both files as per your requirements</p> <ol> <li> <p>List of countries. e.g.</p> <pre><code>COUNTRIES=\"europe/monaco europe/andorra\"\n</code></pre> </li> <li> <p>URL to the service providing the extracts and updates. eg:</p> <pre><code>BASEURL=\"https://download.geofabrik.de\"\nDOWNCOUNTRYPOSTFIX=\"-latest.osm.pbf\"\n</code></pre> </li> <li> <p>Followup in the update script can be set according to your installation.    E.g. for Photon,</p> <pre><code>FOLLOWUP=\"curl http://localhost:2322/nominatim-update\"\n</code></pre> <p>will handle the indexing.</p> </li> </ol> <p>To start the initial import, change into the project directory and run</p> <pre><code>    bash import_multiple_regions.sh\n</code></pre>"},{"location":"admin/Advanced-Installations/#updating-the-database","title":"Updating the database","text":"<p>Change into the project directory and run the following command:</p> <pre><code>bash update_database.sh\n</code></pre> <p>This will get diffs from the replication server, import diffs and index the database. The default replication server in the script (Geofabrik) provides daily updates.</p>"},{"location":"admin/Advanced-Installations/#using-an-external-postgresql-database","title":"Using an external PostgreSQL database","text":"<p>You can install Nominatim using a database that runs on a different server when you have physical access to the file system on the other server. Nominatim uses a custom normalization library that needs to be made accessible to the PostgreSQL server. This section explains how to set up the normalization library.</p> <p>Note</p> <p>The external module is only needed when using the legacy tokenizer. If you have chosen the ICU tokenizer, then you can ignore this section and follow the standard import documentation.</p>"},{"location":"admin/Advanced-Installations/#option-1-compiling-the-library-on-the-database-server","title":"Option 1: Compiling the library on the database server","text":"<p>The most sure way to get a working library is to compile it on the database server. From the prerequisites you need at least cmake, gcc and the PostgreSQL server package.</p> <p>Clone or unpack the Nominatim source code, enter the source directory and create and enter a build directory.</p> <pre><code>cd Nominatim\nmkdir build\ncd build\n</code></pre> <p>Now configure cmake to only build the PostgreSQL module and build it:</p> <pre><code>cmake -DBUILD_IMPORTER=off -DBUILD_API=off -DBUILD_TESTS=off -DBUILD_DOCS=off -DBUILD_OSM2PGSQL=off ..\nmake\n</code></pre> <p>When done, you find the normalization library in <code>build/module/nominatim.so</code>. Copy it to a place where it is readable and executable by the PostgreSQL server process.</p>"},{"location":"admin/Advanced-Installations/#option-2-compiling-the-library-on-the-import-machine","title":"Option 2: Compiling the library on the import machine","text":"<p>You can also compile the normalization library on the machine from where you run the import.</p> <p>Important</p> <p>You can only do this when the database server and the import machine have the same architecture and run the same version of Linux. Otherwise there is no guarantee that the compiled library is compatible with the PostgreSQL server running on the database server.</p> <p>Make sure that the PostgreSQL server package is installed on the machine with the same version as on the database server. You do not need to install the PostgreSQL server itself.</p> <p>Download and compile Nominatim as per standard instructions. Once done, you find the normalization library in <code>build/module/nominatim.so</code>. Copy the file to the database server at a location where it is readable and executable by the PostgreSQL server process.</p>"},{"location":"admin/Advanced-Installations/#running-the-import","title":"Running the import","text":"<p>On the client side you now need to configure the import to point to the correct location of the library on the database server. Add the following line to your your <code>.env</code> file:</p> <pre><code>NOMINATIM_DATABASE_MODULE_PATH=\"&lt;directory on the database server where nominatim.so resides&gt;\"\n</code></pre> <p>Now change the <code>NOMINATIM_DATABASE_DSN</code> to point to your remote server and continue to follow the standard instructions for importing.</p>"},{"location":"admin/Advanced-Installations/#moving-the-database-to-another-machine","title":"Moving the database to another machine","text":"<p>For some configurations it may be useful to run the import on one machine, then move the database to another machine and run the Nominatim service from there. For example, you might want to use a large machine to be able to run the import quickly but only want a smaller machine for production because there is not so much load. Or you might want to do the import once and then replicate the database to many machines.</p> <p>The important thing to keep in mind when transferring the Nominatim installation is that you need to transfer the database and the project directory. Both parts are essential for your installation.</p> <p>The Nominatim database can be transferred using the <code>pg_dump</code>/<code>pg_restore</code> tool. Make sure to use the same version of PostgreSQL and PostGIS on source and target machine.</p> <p>Note</p> <p>Before creating a dump of your Nominatim database, consider running <code>nominatim freeze</code> first. Your database looses the ability to receive further data updates but the resulting database is only about a third of the size of a full database.</p> <p>Next install Nominatim on the target machine by following the standard installation instructions. Again, make sure to use the same version as the source machine.</p> <p>Create a project directory on your destination machine and set up the <code>.env</code> file to match the configuration on the source machine. Finally run</p> <pre><code>nominatim refresh --website\n</code></pre> <p>to make sure that the local installation of Nominatim will be used.</p> <p>If you are using the legacy tokenizer you might also have to switch to the PostgreSQL module that was compiled on your target machine. If you get errors that PostgreSQL cannot find or access <code>nominatim.so</code> then rerun</p> <p>nominatim refresh --functions</p> <p>on the target machine to update the the location of the module.</p>"},{"location":"admin/Deployment-PHP/","title":"Deploying Nominatim using the PHP frontend","text":"<p>The Nominatim API is implemented as a PHP application. The <code>website/</code> directory in the project directory contains the configured website. You can serve this in a production environment with any web server that is capable to run PHP scripts.</p> <p>This section gives a quick overview on how to configure Apache and Nginx to serve Nominatim. It is not meant as a full system administration guide on how to run a web service. Please refer to the documentation of Apache and Nginx for background information on configuring the services.</p> <p>Note</p> <p>Throughout this page, we assume your Nominatim project directory is located in <code>/srv/nominatim-project</code> and you have installed Nominatim using the default installation prefix <code>/usr/local</code>. If you have put it somewhere else, you need to adjust the commands and configuration accordingly.</p> <p>We further assume that your web server runs as user <code>www-data</code>. Older versions of CentOS may still use the user name <code>apache</code>. You also need to adapt the instructions in this case.</p>"},{"location":"admin/Deployment-PHP/#making-the-website-directory-accessible","title":"Making the website directory accessible","text":"<p>You need to make sure that the <code>website</code> directory is accessible for the web server user. You can check that the permissions are correct by accessing on of the php files as the web server user:</p> <pre><code>sudo -u www-data head -n 1 /srv/nominatim-project/website/search.php\n</code></pre> <p>If this shows a permission error, then you need to adapt the permissions of each directory in the path so that it is executable for <code>www-data</code>.</p> <p>If you have SELinux enabled, further adjustments may be necessary to give the web server access. At a minimum the following SELinux labelling should be done for Nominatim:</p> <pre><code>sudo semanage fcontext -a -t httpd_sys_content_t \"/usr/local/nominatim/lib/lib-php(/.*)?\"\nsudo semanage fcontext -a -t httpd_sys_content_t \"/srv/nominatim-project/website(/.*)?\"\nsudo semanage fcontext -a -t lib_t \"/srv/nominatim-project/module/nominatim.so\"\nsudo restorecon -R -v /usr/local/lib/nominatim\nsudo restorecon -R -v /srv/nominatim-project\n</code></pre>"},{"location":"admin/Deployment-PHP/#nominatim-with-apache","title":"Nominatim with Apache","text":""},{"location":"admin/Deployment-PHP/#installing-the-required-packages","title":"Installing the required packages","text":"<p>With Apache you can use the PHP module to run Nominatim.</p> <p>Under Ubuntu/Debian install them with:</p> <pre><code>sudo apt install apache2 libapache2-mod-php\n</code></pre>"},{"location":"admin/Deployment-PHP/#configuring-apache","title":"Configuring Apache","text":"<p>Make sure your Apache configuration contains the required permissions for the directory and create an alias:</p> <pre><code>&lt;Directory \"/srv/nominatim-project/website\"&gt;\n  Options FollowSymLinks MultiViews\n  AddType text/html   .php\n  DirectoryIndex search.php\n  Require all granted\n&lt;/Directory&gt;\nAlias /nominatim /srv/nominatim-project/website\n</code></pre> <p>After making changes in the apache config you need to restart apache. The website should now be available on <code>http://localhost/nominatim</code>.</p>"},{"location":"admin/Deployment-PHP/#nominatim-with-nginx","title":"Nominatim with Nginx","text":""},{"location":"admin/Deployment-PHP/#installing-the-required-packages_1","title":"Installing the required packages","text":"<p>Nginx has no built-in PHP interpreter. You need to use php-fpm as a daemon for serving PHP cgi.</p> <p>On Ubuntu/Debian install nginx and php-fpm with:</p> <pre><code>sudo apt install nginx php-fpm\n</code></pre>"},{"location":"admin/Deployment-PHP/#configure-php-fpm-and-nginx","title":"Configure php-fpm and Nginx","text":"<p>By default php-fpm listens on a network socket. If you want it to listen to a Unix socket instead, change the pool configuration (<code>/etc/php/&lt;php version&gt;/fpm/pool.d/www.conf</code>) as follows:</p> <pre><code>; Replace the tcp listener and add the unix socket\nlisten = /var/run/php-fpm-nominatim.sock\n\n; Ensure that the daemon runs as the correct user\nlisten.owner = www-data\nlisten.group = www-data\nlisten.mode = 0666\n</code></pre> <p>Tell nginx that php files are special and to fastcgi_pass to the php-fpm unix socket by adding the location definition to the default configuration.</p> <pre><code>root /srv/nominatim-project/website;\nindex search.php;\nlocation / {\n    try_files $uri $uri/ @php;\n}\n\nlocation @php {\n    fastcgi_param SCRIPT_FILENAME \"$document_root$uri.php\";\n    fastcgi_param PATH_TRANSLATED \"$document_root$uri.php\";\n    fastcgi_param QUERY_STRING    $args;\n    fastcgi_pass unix:/var/run/php-fpm-nominatim.sock;\n    fastcgi_index index.php;\n    include fastcgi_params;\n}\n\nlocation ~ [^/]\\.php(/|$) {\n    fastcgi_split_path_info ^(.+?\\.php)(/.*)$;\n    if (!-f $document_root$fastcgi_script_name) {\n        return 404;\n    }\n    fastcgi_pass unix:/var/run/php-fpm-nominatim.sock;\n    fastcgi_index search.php;\n    include fastcgi.conf;\n}\n</code></pre> <p>Restart the nginx and php-fpm services and the website should now be available at <code>http://localhost/</code>.</p>"},{"location":"admin/Deployment-PHP/#nominatim-with-other-webservers","title":"Nominatim with other webservers","text":"<p>Users have created instructions for other webservers:</p> <ul> <li>Caddy</li> </ul>"},{"location":"admin/Deployment-Python/","title":"Deploying the Nominatim Python frontend","text":"<p>The Nominatim can be run as a Python-based  ASGI web application. You have the choice between Falcon and Starlette as the ASGI framework.</p> <p>This section gives a quick overview on how to configure Nginx to serve Nominatim. Please refer to the documentation of Nginx for background information on how to configure it.</p> <p>Note</p> <p>Throughout this page, we assume your Nominatim project directory is located in <code>/srv/nominatim-project</code> and you have installed Nominatim using the default installation prefix <code>/usr/local</code>. If you have put it somewhere else, you need to adjust the commands and configuration accordingly.</p> <p>We further assume that your web server runs as user <code>www-data</code>. Older versions of CentOS may still use the user name <code>apache</code>. You also need to adapt the instructions in this case.</p>"},{"location":"admin/Deployment-Python/#installing-the-required-packages","title":"Installing the required packages","text":"<p>The recommended way to deploy a Python ASGI application is to run the ASGI runner uvicorn together with gunicorn HTTP server. We use Falcon here as the web framework.</p> <p>Create a virtual environment for the Python packages and install the necessary dependencies:</p> <pre><code>sudo apt install virtualenv\nvirtualenv /srv/nominatim-venv\n/srv/nominatim-venv/bin/pip install SQLAlchemy PyICU psycopg[binary] \\\n   psycopg2-binary python-dotenv PyYAML falcon uvicorn gunicorn\n</code></pre>"},{"location":"admin/Deployment-Python/#setting-up-nominatim-as-a-systemd-job","title":"Setting up Nominatim as a systemd job","text":"<p>Next you need to set up the service that runs the Nominatim frontend. This is easiest done with a systemd job.</p> <p>First you need to tell systemd to create a socket file to be used by hunicorn. Create the following file <code>/etc/systemd/system/nominatim.socket</code>:</p> <pre><code>[Unit]\nDescription=Gunicorn socket for Nominatim\n\n[Socket]\nListenStream=/run/nominatim.sock\nSocketUser=www-data\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> <p>Now you can add the systemd service for Nominatim itself. Create the following file <code>/etc/systemd/system/nominatim.service</code>:</p> <pre><code>[Unit]\nDescription=Nominatim running as a gunicorn application\nAfter=network.target\nRequires=nominatim.socket\n\n[Service]\nType=simple\nEnvironment=\"PYTHONPATH=/usr/local/lib/nominatim/lib-python/\"\nUser=www-data\nGroup=www-data\nWorkingDirectory=/srv/nominatim-project\nExecStart=/srv/nominatim-venv/bin/gunicorn -b unix:/run/nominatim.sock -w 4 -k uvicorn.workers.UvicornWorker nominatim.server.falcon.server:run_wsgi\nExecReload=/bin/kill -s HUP $MAINPID\nStandardOutput=append:/var/log/gunicorn-nominatim.log\nStandardError=inherit\nPrivateTmp=true\nTimeoutStopSec=5\nKillMode=mixed\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> <p>This sets up gunicorn with 4 workers (<code>-w 4</code> in ExecStart). Each worker runs its own Python process using <code>NOMINATIM_API_POOL_SIZE</code> connections to the database to serve requests in parallel.</p> <p>Make the new services known to systemd and start it:</p> <pre><code>sudo systemctl daemon-reload\nsudo systemctl enable nominatim.socket\nsudo systemctl start nominatim.socket\nsudo systemctl enable nominatim.service\nsudo systemctl start nominatim.service\n</code></pre> <p>This sets the service up, so that Nominatim is automatically started on reboot.</p>"},{"location":"admin/Deployment-Python/#configuring-nginx","title":"Configuring nginx","text":"<p>To make the service available to the world, you need to proxy it through nginx. Add the following definition to the default configuration:</p> <pre><code>upstream nominatim_service {\n  server unix:/run/nominatim.sock fail_timeout=0;\n}\n\nserver {\n    listen 80;\n    listen [::]:80;\n\n    root /var/www/html;\n    index /search;\n\n    location / {\n            proxy_set_header Host $http_host;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_set_header X-Forwarded-Proto $scheme;\n            proxy_redirect off;\n            proxy_pass http://nominatim_service;\n    }\n}\n</code></pre> <p>Reload nginx with</p> <pre><code>sudo systemctl reload nginx\n</code></pre> <p>and you should be able to see the status of your server under <code>http://localhost/status</code>.</p>"},{"location":"admin/Faq/","title":"Troubleshooting Nominatim Installations","text":""},{"location":"admin/Faq/#installation-issues","title":"Installation Issues","text":""},{"location":"admin/Faq/#can-a-stoppedkilled-import-process-be-resumed","title":"Can a stopped/killed import process be resumed?","text":"<p>\"I accidentally killed the import process after it has been running for many hours. Can it be resumed?\"</p> <p>It is possible if the import already got to the indexing stage. Check the last line of output that was logged before the process was killed. If it looks like this:</p> <pre><code>Done 844 in 13 @ 64.923080 per second - Rank 26 ETA (seconds): 7.886255\n</code></pre> <p>then you can resume with the following command:</p> <pre><code>nominatim import --continue indexing\n</code></pre> <p>If the reported rank is 26 or higher, you can also safely add <code>--index-noanalyse</code>.</p>"},{"location":"admin/Faq/#postgresql-crashed-invalid-page-in-block","title":"PostgreSQL crashed \"invalid page in block\"","text":"<p>Usually serious problem, can be a hardware issue, not all data written to disc for example. Check PostgreSQL log file and search PostgreSQL issues/mailing list for hints.</p> <p>If it happened during index creation you can try rerunning the step with</p> <pre><code>nominatim import --continue indexing\n</code></pre> <p>Otherwise it's best to start the full setup from the beginning.</p>"},{"location":"admin/Faq/#nominatimso-version-mismatch","title":"nominatim.so version mismatch","text":"<p>When running the import you may get a version mismatch: <code>COPY_END for place failed: ERROR: incompatible library \"/srv/Nominatim/nominatim/build/module/nominatim.so\": version mismatch</code></p> <p>pg_config seems to use bad includes sometimes when multiple versions of PostgreSQL are available in the system. Make sure you remove the server development libraries (<code>postgresql-server-dev-13</code> on Ubuntu) and recompile (<code>cmake .. &amp;&amp; make</code>).</p>"},{"location":"admin/Faq/#i-see-the-error-error-permission-denied-for-language-c","title":"I see the error \"ERROR: permission denied for language c\"","text":"<p><code>nominatim.so</code>, written in C, is required to be installed on the database server. Some managed database (cloud) services like Amazon RDS do not allow this. There is currently no work-around other than installing a database on a non-managed machine.</p>"},{"location":"admin/Faq/#i-see-the-error-function-transliterationtext-does-not-exist","title":"I see the error: \"function transliteration(text) does not exist\"","text":"<p>Reinstall the nominatim functions with <code>nominatim refresh --functions</code> and check for any errors, e.g. a missing <code>nominatim.so</code> file.</p>"},{"location":"admin/Faq/#i-see-the-error-error-mmap-remap-failed","title":"I see the error: \"ERROR: mmap (remap) failed\"","text":"<p>This may be a simple out-of-memory error. Try reducing the memory used for <code>--osm2pgsql-cache</code>. Also make sure that overcommitting memory is allowed: <code>cat /proc/sys/vm/overcommit_memory</code> should print 0 or 1.</p> <p>If you are using a flatnode file, then it may also be that the underlying filesystem does not fully support 'mmap'. A notable candidate is virtualbox's vboxfs.</p>"},{"location":"admin/Faq/#nominatim-update-failed-error-buffer-179261-is-not-owned-by-resource-owner-portal","title":"nominatim UPDATE failed: ERROR: buffer 179261 is not owned by resource owner Portal","text":"<p>Several users reported this during the initial import of the database. It's something PostgreSQL internal Nominatim doesn't control. And PostgreSQL forums suggest it's threading related but definitely some kind of crash of a process. Users reported either rebooting the server, different hardware or just trying the import again worked.</p>"},{"location":"admin/Faq/#the-website-shows-could-not-get-word-tokens","title":"The website shows: \"Could not get word tokens\"","text":"<p>The server cannot access your database. Add <code>&amp;debug=1</code> to your URL to get the full error message.</p>"},{"location":"admin/Faq/#website-reports-db-error-insufficient-permissions","title":"Website reports \"DB Error: insufficient permissions\"","text":"<p>The user the webserver, e.g. Apache, runs under needs to have access to the Nominatim database. You can find the user like this, for default Ubuntu operating system for example it's <code>www-data</code>.</p> <ol> <li> <p>Repeat the <code>createuser</code> step of the installation instructions.</p> </li> <li> <p>Give the user permission to existing tables</p> </li> </ol> <pre><code>   GRANT usage ON SCHEMA public TO \"www-data\";\n   GRANT SELECT ON ALL TABLES IN SCHEMA public TO \"www-data\";\n</code></pre>"},{"location":"admin/Faq/#website-reports-could-not-load-library-nominatimso","title":"Website reports \"Could not load library \"nominatim.so\"","text":"<p>Example error message</p> <pre><code>   SELECT make_standard_name('3039 E MEADOWLARK LN') [nativecode=ERROR: could not\n   load library \"/srv/nominatim/Nominatim-3.1.0/build/module/nominatim.so\":\n   /srv/nominatim/Nominatim-3.1.0/build/module/nominatim.so: cannot open shared\n   object file: Permission denied\n   CONTEXT: PL/pgSQL function make_standard_name(text) line 5 at assignment]\n</code></pre> <p>The PostgreSQL database, i.e. user <code>postgres</code>, needs to have access to that file.</p> <p>The permission need to be read &amp; executable by everybody, but not writeable by everybody, e.g.</p> <pre><code>   -rwxr-xr-x 1 nominatim nominatim 297984 build/module/nominatim.so\n</code></pre> <p>Try <code>chmod a+r nominatim.so; chmod a+x nominatim.so</code>.</p> <p>When you recently updated your operating system, updated PostgreSQL to a new version or moved files (e.g. the build directory) you should recreate <code>nominatim.so</code>. Try</p> <pre><code>   cd build\n   rm -r module/\n   cmake $main_Nominatim_path &amp;&amp; make\n</code></pre>"},{"location":"admin/Faq/#setup-fails-with-db-error-extension-not-found","title":"Setup fails with \"DB Error: extension not found\"","text":"<p>Make sure you have the PostgreSQL extensions \"hstore\" and \"postgis\" installed. See the installation instructions for a full list of required packages.</p>"},{"location":"admin/Faq/#i-forgot-to-delete-the-flatnodes-file-before-starting-an-import","title":"I forgot to delete the flatnodes file before starting an import.","text":"<p>That's fine. For each import the flatnodes file get overwritten. See https://help.openstreetmap.org/questions/52419/nominatim-flatnode-storage for more information.</p>"},{"location":"admin/Faq/#running-your-own-instance","title":"Running your own instance","text":""},{"location":"admin/Faq/#can-i-import-negative-osm-ids-into-nominatim","title":"Can I import negative OSM ids into Nominatim?","text":"<p>See this question of Stackoverflow.</p>"},{"location":"admin/Import/","title":"Importing the Database","text":"<p>The following instructions explain how to create a Nominatim database from an OSM planet file. It is assumed that you have already successfully installed the Nominatim software itself and the <code>nominatim</code> tool can be found in your <code>PATH</code>. If this is not the case, return to the installation page.</p>"},{"location":"admin/Import/#creating-the-project-directory","title":"Creating the project directory","text":"<p>Before you start the import, you should create a project directory for your new database installation. This directory receives all data that is related to a single Nominatim setup: configuration, extra data, etc. Create a project directory apart from the Nominatim software and change into the directory:</p> <pre><code>mkdir ~/nominatim-project\ncd ~/nominatim-project\n</code></pre> <p>In the following, we refer to the project directory as <code>$PROJECT_DIR</code>. To be able to copy&amp;paste instructions, you can export the appropriate variable:</p> <pre><code>export PROJECT_DIR=~/nominatim-project\n</code></pre> <p>The Nominatim tool assumes per default that the current working directory is the project directory but you may explicitly state a different directory using the <code>--project-dir</code> parameter. The following instructions assume that you run all commands from the project directory.</p> <p>Migration Tip</p> <p>Nominatim used to be run directly from the build directory until version 3.6. Essentially, the build directory functioned as the project directory for the database installation. This setup still works and can be useful for development purposes. It is not recommended anymore for production setups. Create a project directory that is separate from the Nominatim software.</p>"},{"location":"admin/Import/#configuration-setup-in-env","title":"Configuration setup in <code>.env</code>","text":"<p>The Nominatim server can be customized via an <code>.env</code> configuration file in the  project directory. This is a file in dotenv format which looks the same as variable settings in a standard shell environment. You can also set the same configuration via environment variables. All settings have a <code>NOMINATIM_</code> prefix to avoid conflicts with other environment variables.</p> <p>There are lots of configuration settings you can tweak. A full reference can be found in the chapter Configuration Settings. Most should have a sensible default.</p>"},{"location":"admin/Import/#flatnode-files","title":"Flatnode files","text":"<p>If you plan to import a large dataset (e.g. Europe, North America, planet), you should also enable flatnode storage of node locations. With this setting enabled, node coordinates are stored in a simple file instead of the database. This will save you import time and disk storage. Add to your <code>.env</code>:</p> <pre><code>NOMINATIM_FLATNODE_FILE=\"/path/to/flatnode.file\"\n</code></pre> <p>Replace the second part with a suitable path on your system and make sure the directory exists. There should be at least 75GB of free space.</p>"},{"location":"admin/Import/#downloading-additional-data","title":"Downloading additional data","text":""},{"location":"admin/Import/#wikipediawikidata-rankings","title":"Wikipedia/Wikidata rankings","text":"<p>Wikipedia can be used as an optional auxiliary data source to help indicate the importance of OSM features. Nominatim will work without this information but it will improve the quality of the results if this is installed. This data is available as a binary download. Put it into your project directory:</p> <pre><code>cd $PROJECT_DIR\nwget https://nominatim.org/data/wikimedia-importance.sql.gz\n</code></pre> <p>The file is about 400MB and adds around 4GB to the Nominatim database.</p> <p>Tip</p> <p>If you forgot to download the wikipedia rankings, then you can also add importances after the import. Download the SQL files, then run <code>nominatim refresh --wiki-data --importance</code>. Updating importances for a planet will take a couple of hours.</p>"},{"location":"admin/Import/#external-postcodes","title":"External postcodes","text":"<p>Nominatim can use postcodes from an external source to improve searching with postcodes. We provide precomputed postcodes sets for the US (using TIGER data) and the UK (using the CodePoint OpenData set. This data can be optionally downloaded into the project directory:</p> <pre><code>cd $PROJECT_DIR\nwget https://nominatim.org/data/gb_postcodes.csv.gz\nwget https://nominatim.org/data/us_postcodes.csv.gz\n</code></pre> <p>You can also add your own custom postcode sources, see Customization of postcodes.</p>"},{"location":"admin/Import/#choosing-the-data-to-import","title":"Choosing the data to import","text":"<p>In its default setup Nominatim is configured to import the full OSM data set for the entire planet. Such a setup requires a powerful machine with at least 64GB of RAM and around 900GB of SSD hard disks. Depending on your use case there are various ways to reduce the amount of data imported. This section discusses these methods. They can also be combined.</p>"},{"location":"admin/Import/#using-an-extract","title":"Using an extract","text":"<p>If you only need geocoding for a smaller region, then precomputed OSM extracts are a good way to reduce the database size and import time. Geofabrik offers extracts for most countries. They even have daily updates which can be used with the update process described in the next section. There are also other providers for extracts.</p> <p>Please be aware that some extracts are not cut exactly along the country boundaries. As a result some parts of the boundary may be missing which means that Nominatim cannot compute the areas for some administrative areas.</p>"},{"location":"admin/Import/#dropping-data-required-for-dynamic-updates","title":"Dropping Data Required for Dynamic Updates","text":"<p>About half of the data in Nominatim's database is not really used for serving the API. It is only there to allow the data to be updated from the latest changes from OSM. For many uses these dynamic updates are not really required. If you don't plan to apply updates, you can run the import with the <code>--no-updates</code> parameter. This will drop the dynamic part of the database as soon as it is not required anymore.</p> <p>You can also drop the dynamic part later using the following command:</p> <pre><code>nominatim freeze\n</code></pre> <p>Note that you still need to provide for sufficient disk space for the initial import. So this option is particularly interesting if you plan to transfer the database or reuse the space later.</p> <p>Warning</p> <p>The data structure for updates are also required when adding additional data after the import, for example TIGER housenumber data. If you plan to use those, you must not use the <code>--no-updates</code> parameter. Do a normal import, add the external data and once you are done with everything run <code>nominatim freeze</code>.</p>"},{"location":"admin/Import/#reverse-only-imports","title":"Reverse-only Imports","text":"<p>If you only want to use the Nominatim database for reverse lookups or if you plan to use the installation only for exports to a photon database, then you can set up a database without search indexes. Add <code>--reverse-only</code> to your setup command above.</p> <p>This saves about 5% of disk space, import time won't be significant faster.</p>"},{"location":"admin/Import/#filtering-imported-data","title":"Filtering Imported Data","text":"<p>Nominatim normally sets up a full search database containing administrative boundaries, places, streets, addresses and POI data. There are also other import styles available which only read selected data:</p> <ul> <li>admin   Only import administrative boundaries and places.</li> <li>street   Like the admin style but also adds streets.</li> <li>address   Import all data necessary to compute addresses down to house number level.</li> <li>full   Default style that also includes points of interest.</li> <li>extratags   Like the full style but also adds most of the OSM tags into the extratags   column.</li> </ul> <p>The style can be changed with the configuration <code>NOMINATIM_IMPORT_STYLE</code>.</p> <p>To give you an idea of the impact of using the different styles, the table below gives rough estimates of the final database size after import of a 2020 planet and after using the <code>--drop</code> option. It also shows the time needed for the import on a machine with 64GB RAM, 4 CPUS and NVME disks. Note that the given sizes are just an estimate meant for comparison of style requirements. Your planet import is likely to be larger as the OSM data grows with time.</p> style Import time DB size after drop admin 4h 215 GB 20 GB street 22h 440 GB 185 GB address 36h 545 GB 260 GB full 54h 640 GB 330 GB extratags 54h 650 GB 340 GB <p>You can also customize the styles further. A description of the style format can be found in the customization guide.</p>"},{"location":"admin/Import/#initial-import-of-the-data","title":"Initial import of the data","text":"<p>Important</p> <p>First try the import with a small extract, for example from Geofabrik.</p> <p>Download the data to import. Then issue the following command from the project directory to start the import:</p> <pre><code>nominatim import --osm-file &lt;data file&gt; 2&gt;&amp;1 | tee setup.log\n</code></pre> <p>The project directory is the one that you have set up at the beginning. See creating the project directory.</p>"},{"location":"admin/Import/#notes-on-full-planet-imports","title":"Notes on full planet imports","text":"<p>Even on a perfectly configured machine the import of a full planet takes around 2 days. Once you see messages with <code>Rank .. ETA</code> appear, the indexing process has started. This part takes the most time. There are 30 ranks to process. Rank 26 and 30 are the most complex. They take each about a third of the total import time. If you have not reached rank 26 after two days of import, it is worth revisiting your system configuration as it may not be optimal for the import.</p>"},{"location":"admin/Import/#notes-on-memory-usage","title":"Notes on memory usage","text":"<p>In the first step of the import Nominatim uses osm2pgsql to load the OSM data into the PostgreSQL database. This step is very demanding in terms of RAM usage. osm2pgsql and PostgreSQL are running in parallel at  this point. PostgreSQL blocks at least the part of RAM that has been configured with the <code>shared_buffers</code> parameter during PostgreSQL tuning and needs some memory on top of that. osm2pgsql needs at least 2GB of RAM for its internal data structures, potentially more when it has to process very large relations. In addition it needs to maintain a cache for node locations. The size of this cache can be configured with the parameter <code>--osm2pgsql-cache</code>.</p> <p>When importing with a flatnode file, it is best to disable the node cache completely and leave the memory for the flatnode file. Nominatim will do this by default, so you do not need to configure anything in this case.</p> <p>For imports without a flatnode file, set <code>--osm2pgsql-cache</code> approximately to the size of the OSM pbf file you are importing. The size needs to be given in MB. Make sure you leave enough RAM for PostgreSQL and osm2pgsql as mentioned above. If the system starts swapping or you are getting out-of-memory errors, reduce the cache size or even consider using a flatnode file.</p>"},{"location":"admin/Import/#testing-the-installation","title":"Testing the installation","text":"<p>Run this script to verify that all required tables and indices got created successfully.</p> <pre><code>nominatim admin --check-database\n</code></pre> <p>Now you can try out your installation by executing a simple query on the command line:</p> <pre><code>nominatim search --query Berlin\n</code></pre> <p>or, when you have a reverse-only installation:</p> <pre><code>nominatim reverse --lat 51 --lon 45\n</code></pre> <p>If you want to run Nominatim as a service, you need to make a choice between running the modern Python frontend and the legacy PHP frontend. Make sure you have installed the right packages as per Installation.</p>"},{"location":"admin/Import/#testing-the-python-frontend","title":"Testing the Python frontend","text":"<p>To run the test server against the Python frontend, you must choose a web framework to use, either starlette or falcon. Make sure the appropriate packages are installed. Then run</p> <pre><code>nominatim serve\n</code></pre> <p>or, if you prefer to use Starlette instead of Falcon as webserver,</p> <pre><code>nominatim serve --engine starlette\n</code></pre> <p>Go to <code>http://localhost:8088/status.php</code> and you should see the message <code>OK</code>. You can also run a search query, e.g. <code>http://localhost:8088/search.php?q=Berlin</code> or, for reverse-only installations a reverse query, e.g. <code>http://localhost:8088/reverse.php?lat=27.1750090510034&amp;lon=78.04209025</code>.</p> <p>Do not use this test server in production. To run Nominatim via webservers like Apache or nginx, please continue reading Deploy the Python frontend.</p>"},{"location":"admin/Import/#testing-the-php-frontend","title":"Testing the PHP frontend","text":"<p>You can run a small test server with the PHP frontend like this:</p> <pre><code>nominatim serve --engine php\n</code></pre> <p>Go to <code>http://localhost:8088/status.php</code> and you should see the message <code>OK</code>. You can also run a search query, e.g. <code>http://localhost:8088/search.php?q=Berlin</code> or, for reverse-only installations a reverse query, e.g. <code>http://localhost:8088/reverse.php?lat=27.1750090510034&amp;lon=78.04209025</code>.</p> <p>Do not use this test server in production. To run Nominatim via webservers like Apache or nginx, please continue reading Deploy the PHP frontend.</p>"},{"location":"admin/Import/#enabling-search-by-category-phrases","title":"Enabling search by category phrases","text":"<p>To be able to search for places by their type using special phrases you also need to import these key phrases like this:</p> <pre><code>nominatim special-phrases --import-from-wiki\n</code></pre> <p>Note that this command downloads the phrases from the wiki link above. You need internet access for the step.</p> <p>You can also import special phrases from a csv file, for more  information please see the Customization part.</p>"},{"location":"admin/Installation/","title":"Basic Installation","text":"<p>This page contains generic installation instructions for Nominatim and its prerequisites. There are also step-by-step instructions available for the following operating systems:</p> <ul> <li>Ubuntu 22.04</li> <li>Ubuntu 20.04</li> </ul> <p>These OS-specific instructions can also be found in executable form in the <code>vagrant/</code> directory.</p> <p>Users have created instructions for other frameworks. We haven't tested those and can't offer support.</p> <ul> <li>Docker</li> <li>Docker on Kubernetes</li> <li>Kubernetes with Helm</li> <li>Ansible</li> </ul>"},{"location":"admin/Installation/#prerequisites","title":"Prerequisites","text":""},{"location":"admin/Installation/#software","title":"Software","text":"<p>Warning</p> <p>For larger installations you must have PostgreSQL 11+ and PostGIS 3+ otherwise import and queries will be slow to the point of being unusable. Query performance has marked improvements with PostgreSQL 13+ and PostGIS 3.2+.</p> <p>For compiling:</p> <ul> <li>cmake</li> <li>expat</li> <li>proj</li> <li>bzip2</li> <li>zlib</li> <li>ICU</li> <li>nlohmann/json</li> <li>Boost libraries, including system and filesystem</li> <li>PostgreSQL client libraries</li> <li>a recent C++ compiler (gcc 5+ or Clang 3.8+)</li> </ul> <p>For running Nominatim:</p> <ul> <li>PostgreSQL (9.6+ will work, 11+ strongly recommended)</li> <li>PostGIS (2.2+ will work, 3.0+ strongly recommended)</li> <li>Python 3 (3.7+)</li> <li>Psycopg2 (2.7+)</li> <li>Python Dotenv</li> <li>psutil</li> <li>Jinja2</li> <li>SQLAlchemy (1.4.31+ with greenlet support)</li> <li>asyncpg (0.8+)</li> <li>PyICU</li> <li>PyYaml (5.1+)</li> <li>datrie</li> </ul> <p>For running continuous updates:</p> <ul> <li>pyosmium</li> </ul> <p>For running the Python frontend:</p> <ul> <li>one of the following web frameworks:<ul> <li>falcon (3.0+)</li> <li>starlette</li> </ul> </li> <li>uvicorn</li> </ul> <p>For running the legacy PHP frontend:</p> <ul> <li>PHP (7.3+)</li> <li>PHP-pgsql</li> <li>PHP-intl (bundled with PHP)</li> </ul> <p>For dependencies for running tests and building documentation, see the Development section.</p>"},{"location":"admin/Installation/#hardware","title":"Hardware","text":"<p>A minimum of 2GB of RAM is required or installation will fail. For a full planet import 128GB of RAM or more are strongly recommended. Do not report out of memory problems if you have less than 64GB RAM.</p> <p>For a full planet install you will need at least 1TB of hard disk space. Take into account that the OSM database is growing fast. Fast disks are essential. Using NVME disks is recommended.</p> <p>Even on a well configured machine the import of a full planet takes around 2 days. When using traditional SSDs, 4-5 days are more realistic.</p>"},{"location":"admin/Installation/#tuning-the-postgresql-database","title":"Tuning the PostgreSQL database","text":"<p>You might want to tune your PostgreSQL installation so that the later steps make best use of your hardware. You should tune the following parameters in your <code>postgresql.conf</code> file.</p> <pre><code>shared_buffers = 2GB\nmaintenance_work_mem = (10GB)\nautovacuum_work_mem = 2GB\nwork_mem = (50MB)\neffective_cache_size = (24GB)\nsynchronous_commit = off\nmax_wal_size = 1GB\ncheckpoint_timeout = 10min\ncheckpoint_completion_target = 0.9\n</code></pre> <p>The numbers in brackets behind some parameters seem to work fine for 64GB RAM machine. Adjust to your setup. A higher number for <code>max_wal_size</code> means that PostgreSQL needs to run checkpoints less often but it does require the additional space on your disk.</p> <p>Autovacuum must not be switched off because it ensures that the tables are frequently analysed. If your machine has very little memory, you might consider setting:</p> <pre><code>autovacuum_max_workers = 1\n</code></pre> <p>and even reduce <code>autovacuum_work_mem</code> further. This will reduce the amount of memory that autovacuum takes away from the import process.</p>"},{"location":"admin/Installation/#downloading-and-building-nominatim","title":"Downloading and building Nominatim","text":""},{"location":"admin/Installation/#downloading-the-latest-release","title":"Downloading the latest release","text":"<p>You can download the latest release from nominatim.org. The release contains all necessary files. Just unpack it.</p>"},{"location":"admin/Installation/#downloading-the-latest-development-version","title":"Downloading the latest development version","text":"<p>If you want to install latest development version from github, make sure to also check out the osm2pgsql subproject:</p> <pre><code>git clone --recursive https://github.com/openstreetmap/Nominatim.git\n</code></pre> <p>The development version does not include the country grid. Download it separately:</p> <pre><code>wget -O Nominatim/data/country_osm_grid.sql.gz https://nominatim.org/data/country_grid.sql.gz\n</code></pre>"},{"location":"admin/Installation/#building-nominatim","title":"Building Nominatim","text":"<p>The code must be built in a separate directory. Create the directory and change into it.</p> <pre><code>mkdir build\ncd build\n</code></pre> <p>Nominatim uses cmake and make for building. Assuming that you have created the build at the same level as the Nominatim source directory run:</p> <pre><code>cmake ../Nominatim\nmake\nsudo make install\n</code></pre> <p>Warning</p> <p>The default installation no longer compiles the PostgreSQL module that is needed for the legacy tokenizer from older Nominatim versions. If you are upgrading an older database or want to run the legacy tokenizer for some other reason, you need to enable the PostgreSQL module via cmake: <code>cmake -DBUILD_MODULE=on ../Nominatim</code>. To compile the module you need to have the server development headers for PostgreSQL installed. On Ubuntu/Debian run: <code>sudo apt install postgresql-server-dev-&lt;postgresql version&gt;</code></p> <p>Nominatim installs itself into <code>/usr/local</code> per default. To choose a different installation directory add <code>-DCMAKE_INSTALL_PREFIX=&lt;install root&gt;</code> to the cmake command. Make sure that the <code>bin</code> directory is available in your path in that case, e.g.</p> <pre><code>export PATH=&lt;install root&gt;/bin:$PATH\n</code></pre> <p>Now continue with importing the database.</p>"},{"location":"admin/Maintenance/","title":"Maintenance","text":"<p>This chapter describes the various operations the Nominatim database administrator may use to clean and maintain the database. None of these operations is mandatory but they may help improve the performance and accuracy of results.</p>"},{"location":"admin/Maintenance/#updating-postcodes","title":"Updating postcodes","text":"<p>Command: <code>nominatim refresh --postcodes</code></p> <p>Postcode centroids (aka 'calculated postcodes') are generated by looking at all postcodes of a country, grouping them and calculating the geometric centroid. There is currently no logic to deal with extreme outliers (typos or other mistakes in OSM data). There is also no check if a postcodes adheres to a country's format, e.g. if Swiss postcodes are 4 digits.</p> <p>When running regular updates, postcodes results can be improved by running this command on a regular basis. Note that only the postcode table and the postcode search terms are updated. The postcode that is assigned to each place is only updated when the place is updated.</p> <p>The command takes around 70min to run on the planet and needs ca. 40GB of temporary disk space.</p>"},{"location":"admin/Maintenance/#updating-word-counts","title":"Updating word counts","text":"<p>Command: <code>nominatim refresh --word-counts</code></p> <p>Nominatim keeps frequency statistics about all search terms it indexes. These statistics are currently used to optimise queries to the database. Thus better statistics mean better performance. Word counts are created once after import and are usually sufficient even when running regular updates. You might want to rerun the statistics computation when adding larger amounts of new data, for example, when adding an additional country via <code>nominatim add-data</code>.</p>"},{"location":"admin/Maintenance/#forcing-recomputation-of-places-and-areas","title":"Forcing recomputation of places and areas","text":"<p>Command: <code>nominatim refresh --data-object [NWR]&lt;id&gt; --data-area [NWR]&lt;id&gt;</code></p> <p>When running replication updates, Nominatim tries to recompute the search and address information for all places that are affected by a change. But it needs to restrict the total number of changes to make sure it can keep up with the minutely updates. Therefore it will refrain from propagating changes that affect a lot of objects.</p> <p>The administrator may force an update of places in the database. <code>nominatim refresh --data-object</code> invalidates a single OSM object. <code>nominatim refresh --data-area</code> invalidates an OSM object and all dependent objects. That are usually the places that inside its area or around the center of the object. Both commands expect the OSM object as an argument of the form OSM type + OSM id. The type must be <code>N</code> (node), <code>W</code> (way) or <code>R</code> (relation).</p> <p>After invalidating the object, indexing must be run again. If continuous update are running in the background, the objects will be recomputed together with the next round of updates. Otherwise you need to run <code>nominatim index</code> to finish the recomputation.</p>"},{"location":"admin/Maintenance/#removing-large-deleted-objects","title":"Removing large deleted objects","text":"<p>Command: <code>nominatim admin --clean-deleted &lt;PostgreSQL Time Interval&gt;</code></p> <p>Nominatim refuses to delete very large areas because often these deletions are accidental and are reverted within hours. Instead the deletions are logged in the <code>import_polygon_delete</code> table and left to the administrator to clean up.</p> <p>To run this command you will need to pass a PostgreSQL time interval. For example to  delete any objects that have been deleted more than a month ago you would run: <code>nominatim admin --clean-deleted '1 month'</code></p>"},{"location":"admin/Migration/","title":"Database Migrations","text":"<p>Since version 3.7.0 Nominatim offers automatic migrations. Please follow the following steps:</p> <ul> <li>stop any updates that are potentially running</li> <li>update Nominatim to the newer version</li> <li>go to your project directory and run <code>nominatim admin --migrate</code></li> <li>(optionally) restart updates</li> </ul> <p>Below you find additional migrations and hints about other structural and breaking changes. Please read them before running the migration.</p> <p>Note</p> <p>If you are migrating from a version &lt;3.6, then you still have to follow the manual migration steps up to 3.6.</p>"},{"location":"admin/Migration/#420-430","title":"4.2.0 -&gt; 4.3.0","text":""},{"location":"admin/Migration/#new-indexes-for-reverse-lookup","title":"New indexes for reverse lookup","text":"<p>The reverse lookup algorithm has changed slightly to improve performance. This change needs a different index in the database. The required index will be automatically build during migration. Until the new index is available performance of the /reverse endpoint is significantly reduced. You should therefore either remove traffic from the machine before attempting a version update or create the index manually before starting the update using the following SQL:</p> <pre><code>CREATE INDEX IF NOT EXISTS idx_placex_geometry_reverse_lookupPlaceNode\n  ON placex USING gist (ST_Buffer(geometry, reverse_place_diameter(rank_search)))\n  WHERE rank_address between 4 and 25 AND type != 'postcode'\n    AND name is not null AND linked_place_id is null AND osm_type = 'N';\n</code></pre>"},{"location":"admin/Migration/#400-410","title":"4.0.0 -&gt; 4.1.0","text":""},{"location":"admin/Migration/#icu-tokenizer-is-the-new-default","title":"ICU tokenizer is the new default","text":"<p>Nominatim now installs the ICU tokenizer by default. This only has an effect on newly installed databases. When updating older databases, it keeps its installed tokenizer. If you still run with the legacy tokenizer, make sure to compile Nominatim with the PostgreSQL module, see Installation.</p>"},{"location":"admin/Migration/#geocodejson-output-changed","title":"geocodejson output changed","text":"<p>The <code>type</code> field of the geocodejson output has changed. It now contains the address class of the object instead of the value of the OSM tag. If your client has used the <code>type</code> field, switch them to read <code>osm_value</code> instead.</p>"},{"location":"admin/Migration/#370-400","title":"3.7.0 -&gt; 4.0.0","text":""},{"location":"admin/Migration/#nominatim_phrase_config-removed","title":"NOMINATIM_PHRASE_CONFIG removed","text":"<p>Custom blacklist configurations for special phrases now need to be handed with the <code>--config</code> parameter to <code>nominatim special-phrases</code>. Alternatively you can put your custom configuration in the project directory in a file named <code>phrase-settings.json</code>.</p> <p>Version 3.8 also removes the automatic converter for the php format of the configuration in older versions. If you are updating from Nominatim &lt; 3.7 and still work with a custom <code>phrase-settings.php</code>, you need to manually convert it into a json format.</p>"},{"location":"admin/Migration/#php-utils-removed","title":"PHP utils removed","text":"<p>The old PHP utils have now been removed completely. You need to switch to the appropriate functions of the nominatim  command line tool. See Introducing <code>nominatim</code> command line tool below.</p>"},{"location":"admin/Migration/#360-370","title":"3.6.0 -&gt; 3.7.0","text":""},{"location":"admin/Migration/#new-format-and-name-of-configuration-file","title":"New format and name of configuration file","text":"<p>The configuration for an import is now saved in a <code>.env</code> file in the project directory. This file follows the dotenv format. For more information, see the installation chapter.</p> <p>To migrate to the new system, create a new project directory, add the <code>.env</code> file and port your custom configuration from <code>settings/local.php</code>. Most settings are named similar and only have received a <code>NOMINATIM_</code> prefix. Use the default settings in <code>settings/env.defaults</code> as a reference.</p>"},{"location":"admin/Migration/#new-location-for-data-files","title":"New location for data files","text":"<p>External data files for Wikipedia importance, postcodes etc. are no longer expected to reside in the source tree by default. Instead they will be searched in the project directory. If you have an automated setup script you must either adapt the download location or explicitly set the location of the files to the old place in your <code>.env</code>.</p>"},{"location":"admin/Migration/#introducing-nominatim-command-line-tool","title":"Introducing <code>nominatim</code> command line tool","text":"<p>The various php utilities have been replaced with a single <code>nominatim</code> command line tool. Make sure to adapt any scripts. There is no direct 1:1 matching between the old utilities and the commands of nominatim CLI. The following list gives you a list of nominatim sub-commands that contain functionality of each script:</p> <ul> <li>./utils/setup.php: <code>import</code>, <code>freeze</code>, <code>refresh</code></li> <li>./utils/update.php: <code>replication</code>, <code>add-data</code>, <code>index</code>, <code>refresh</code></li> <li>./utils/specialphrases.php: <code>special-phrases</code></li> <li>./utils/check_import_finished.php: <code>admin</code></li> <li>./utils/warm.php: <code>admin</code></li> <li>./utils/export.php: <code>export</code></li> </ul> <p>Try <code>nominatim &lt;command&gt; --help</code> for more information about each subcommand.</p> <p><code>./utils/query.php</code> no longer exists in its old form. <code>nominatim search</code> provides a replacement but returns different output.</p>"},{"location":"admin/Migration/#switch-to-normalized-house-numbers","title":"Switch to normalized house numbers","text":"<p>The housenumber column in the placex table uses now normalized version. The automatic migration step will convert the column but this may take a very long time. It is advisable to take the machine offline while doing that.</p>"},{"location":"admin/Migration/#350-360","title":"3.5.0 -&gt; 3.6.0","text":""},{"location":"admin/Migration/#change-of-layout-of-search_name_-tables","title":"Change of layout of search_name_* tables","text":"<p>The table need a different index for nearest place lookup. Recreate the indexes using the following shell script:</p> <pre><code>for table in `psql -d nominatim -c \"SELECT tablename FROM pg_tables WHERE tablename LIKE 'search_name_%'\" -tA | grep -v search_name_blank`;\ndo\n    psql -d nominatim -c \"DROP INDEX idx_${table}_centroid_place; CREATE INDEX idx_${table}_centroid_place ON ${table} USING gist (centroid) WHERE ((address_rank &gt;= 2) AND (address_rank &lt;= 25)); DROP INDEX idx_${table}_centroid_street; CREATE INDEX idx_${table}_centroid_street ON ${table} USING gist (centroid) WHERE ((address_rank &gt;= 26) AND (address_rank &lt;= 27))\";\ndone\n</code></pre>"},{"location":"admin/Migration/#removal-of-html-output","title":"Removal of html output","text":"<p>The debugging UI is no longer directly provided with Nominatim. Instead we now provide a simple Javascript application. Please refer to Setting up the Nominatim UI for details on how to set up the UI.</p> <p>The icons served together with the API responses have been moved to the nominatim-ui project as well. If you want to keep the <code>icon</code> field in the response, you need to set <code>CONST_MapIcon_URL</code> to the URL of the <code>/mapicon</code> directory of nominatim-ui.</p>"},{"location":"admin/Migration/#change-order-during-indexing","title":"Change order during indexing","text":"<p>When reindexing places during updates, there is now a different order used which needs a different database index. Create it with the following SQL command:</p> <pre><code>CREATE INDEX idx_placex_pendingsector_rank_address\n  ON placex\n  USING BTREE (rank_address, geometry_sector)\n  WHERE indexed_status &gt; 0;\n</code></pre> <p>You can then drop the old index with:</p> <pre><code>DROP INDEX idx_placex_pendingsector;\n</code></pre>"},{"location":"admin/Migration/#unused-index","title":"Unused index","text":"<p>This index has been unused ever since the query using it was changed two years ago. Saves about 12GB on a planet installation.</p> <pre><code>DROP INDEX idx_placex_geometry_reverse_lookupPoint;\n</code></pre>"},{"location":"admin/Migration/#switching-to-dotenv","title":"Switching to dotenv","text":"<p>As part of the work changing the configuration format, the configuration for the website is now using a separate configuration file. To create the configuration file, run the following command after updating:</p> <pre><code>./utils/setup.php --setup-website\n</code></pre>"},{"location":"admin/Migration/#update-sql-code","title":"Update SQL code","text":"<p>To update the SQL code to the leatest version run:</p> <pre><code>./utils/setup.php --create-functions --enable-diff-updates --create-partition-functions\n</code></pre>"},{"location":"admin/Migration/#340-350","title":"3.4.0 -&gt; 3.5.0","text":""},{"location":"admin/Migration/#new-wikipediawikidata-importance-tables","title":"New Wikipedia/Wikidata importance tables","text":"<p>The <code>wikipedia_*</code> tables have a new format that also includes references to Wikidata. You need to update the computation functions and the tables as follows:</p> <ul> <li>download the new Wikipedia tables as described in the import section</li> <li>reimport the tables: <code>./utils/setup.php --import-wikipedia-articles</code></li> <li>update the functions: <code>./utils/setup.php --create-functions --enable-diff-updates</code></li> <li>create a new lookup index: <pre><code>CREATE INDEX idx_placex_wikidata\n  ON placex\n  USING BTREE ((extratags -&gt; 'wikidata'))\n  WHERE extratags ? 'wikidata'\n    AND class = 'place'\n    AND osm_type = 'N'\n    AND rank_search &lt; 26;\n</code></pre></li> <li>compute importance: <code>./utils/update.php --recompute-importance</code></li> </ul> <p>The last step takes about 10 hours on the full planet.</p> <p>Remove one function (it will be recreated in the next step):</p> <pre><code>DROP FUNCTION create_country(hstore,character varying);\n</code></pre> <p>Finally, update all SQL functions:</p> <pre><code>./utils/setup.php --create-functions --enable-diff-updates --create-partition-functions\n</code></pre>"},{"location":"admin/Migration/#330-340","title":"3.3.0 -&gt; 3.4.0","text":""},{"location":"admin/Migration/#reorganisation-of-location_area_country-table","title":"Reorganisation of location_area_country table","text":"<p>The table <code>location_area_country</code> has been optimized. You need to switch to the new format when you run updates. While updates are disabled, run the following SQL commands:</p> <pre><code>CREATE TABLE location_area_country_new AS\n  SELECT place_id, country_code, geometry FROM location_area_country;\nDROP TABLE location_area_country;\nALTER TABLE location_area_country_new RENAME TO location_area_country;\nCREATE INDEX idx_location_area_country_geometry ON location_area_country USING GIST (geometry);\nCREATE INDEX idx_location_area_country_place_id ON location_area_country USING BTREE (place_id);\n</code></pre> <p>Finally, update all SQL functions:</p> <pre><code>./utils/setup.php --create-functions --enable-diff-updates --create-partition-functions\n</code></pre>"},{"location":"admin/Migration/#320-330","title":"3.2.0 -&gt; 3.3.0","text":""},{"location":"admin/Migration/#new-database-connection-string-dsn-format","title":"New database connection string (DSN) format","text":"<p>Previously database connection setting (<code>CONST_Database_DSN</code> in <code>settings/*.php</code>) had the format</p> <ul> <li>(simple) <code>pgsql://@/nominatim</code></li> <li>(complex) <code>pgsql://johndoe:secret@machine1.domain.com:1234/db1</code></li> </ul> <p>The new format is</p> <ul> <li>(simple) <code>pgsql:dbname=nominatim</code></li> <li>(complex) <code>pgsql:dbname=db1;host=machine1.domain.com;port=1234;user=johndoe;password=secret</code></li> </ul>"},{"location":"admin/Migration/#natural-earth-country-boundaries-no-longer-needed-as-fallback","title":"Natural Earth country boundaries no longer needed as fallback","text":"<pre><code>DROP TABLE country_naturalearthdata;\n</code></pre> <p>Finally, update all SQL functions:</p> <pre><code>./utils/setup.php --create-functions --enable-diff-updates --create-partition-functions\n</code></pre>"},{"location":"admin/Migration/#configurable-address-levels","title":"Configurable Address Levels","text":"<p>The new configurable address levels require a new table. Create it with the following command:</p> <pre><code>./utils/update.php --update-address-levels\n</code></pre>"},{"location":"admin/Migration/#310-320","title":"3.1.0 -&gt; 3.2.0","text":""},{"location":"admin/Migration/#new-reverse-algorithm","title":"New reverse algorithm","text":"<p>The reverse algorithm has changed and requires new indexes. Run the following SQL statements to create the indexes:</p> <pre><code>CREATE INDEX idx_placex_geometry_reverse_lookupPoint\n  ON placex\n  USING gist (geometry)\n  WHERE (name IS NOT null or housenumber IS NOT null or rank_address BETWEEN 26 AND 27)\n    AND class NOT IN ('railway','tunnel','bridge','man_made')\n    AND rank_address &gt;= 26\n    AND indexed_status = 0\n    AND linked_place_id IS null;\nCREATE INDEX idx_placex_geometry_reverse_lookupPolygon\n  ON placex USING gist (geometry)\n  WHERE St_GeometryType(geometry) in ('ST_Polygon', 'ST_MultiPolygon')\n    AND rank_address between 4 and 25\n    AND type != 'postcode'\n    AND name is not null\n    AND indexed_status = 0\n    AND linked_place_id is null;\nCREATE INDEX idx_placex_geometry_reverse_placeNode\n  ON placex USING gist (geometry)\n  WHERE osm_type = 'N'\n    AND rank_search between 5 and 25\n    AND class = 'place'\n    AND type != 'postcode'\n    AND name is not null\n    AND indexed_status = 0\n    AND linked_place_id is null;\n</code></pre> <p>You also need to grant the website user access to the <code>country_osm_grid</code> table:</p> <pre><code>GRANT SELECT ON table country_osm_grid to \"www-user\";\n</code></pre> <p>Replace the <code>www-user</code> with the user name of your website server if necessary.</p> <p>You can now drop the unused indexes:</p> <pre><code>DROP INDEX idx_placex_reverse_geometry;\n</code></pre> <p>Finally, update all SQL functions:</p> <pre><code>./utils/setup.php --create-functions --enable-diff-updates --create-partition-functions\n</code></pre>"},{"location":"admin/Migration/#300-310","title":"3.0.0 -&gt; 3.1.0","text":""},{"location":"admin/Migration/#postcode-table","title":"Postcode Table","text":"<p>A new separate table for artificially computed postcode centroids was introduced. Migration to the new format is possible but not recommended.</p> <p>Create postcode table and indexes, running the following SQL statements:</p> <pre><code>CREATE TABLE location_postcode\n  (place_id BIGINT, parent_place_id BIGINT, rank_search SMALLINT,\n   rank_address SMALLINT, indexed_status SMALLINT, indexed_date TIMESTAMP,\n   country_code varchar(2), postcode TEXT,\n   geometry GEOMETRY(Geometry, 4326));\nCREATE INDEX idx_postcode_geometry ON location_postcode USING GIST (geometry);\nCREATE UNIQUE INDEX idx_postcode_id ON location_postcode USING BTREE (place_id);\nCREATE INDEX idx_postcode_postcode ON location_postcode USING BTREE (postcode);\nGRANT SELECT ON location_postcode TO \"www-data\";\nDROP TYPE IF EXISTS nearfeaturecentr CASCADE;\nCREATE TYPE nearfeaturecentr AS (\n  place_id BIGINT,\n  keywords int[],\n  rank_address smallint,\n  rank_search smallint,\n  distance float,\n  isguess boolean,\n  postcode TEXT,\n  centroid GEOMETRY\n);\n</code></pre> <p>Add postcode column to <code>location_area</code> tables with SQL statement:</p> <pre><code>ALTER TABLE location_area ADD COLUMN postcode TEXT;\n</code></pre> <p>Then reimport the functions:</p> <pre><code>./utils/setup.php --create-functions --enable-diff-updates --create-partition-functions\n</code></pre> <p>Create appropriate triggers with SQL:</p> <pre><code>CREATE TRIGGER location_postcode_before_update BEFORE UPDATE ON location_postcode\n    FOR EACH ROW EXECUTE PROCEDURE postcode_update();\n</code></pre> <p>Finally populate the postcode table (will take a while):</p> <pre><code>./utils/setup.php --calculate-postcodes --index --index-noanalyse\n</code></pre> <p>This will create a working database. You may also delete the old artificial postcodes now. Note that this may be expensive and is not absolutely necessary. The following SQL statement will remove them:</p> <pre><code>DELETE FROM place_addressline a USING placex p\n WHERE a.address_place_id = p.place_id and p.osm_type = 'P';\nALTER TABLE placex DISABLE TRIGGER USER;\nDELETE FROM placex WHERE osm_type = 'P';\nALTER TABLE placex ENABLE TRIGGER USER;\n</code></pre>"},{"location":"admin/Setup-Nominatim-UI/","title":"Setting up the Nominatim UI","text":"<p>Nominatim is a search API, it does not provide a website interface on its own. nominatim-ui offers a small website for testing your setup and inspecting the database content.</p> <p>This section provides a quick start how to use nominatim-ui with your installation. For more details, please also have a look at the README of nominatim-ui.</p>"},{"location":"admin/Setup-Nominatim-UI/#installing-nominatim-ui","title":"Installing nominatim-ui","text":"<p>We provide regular releases of nominatim-ui that contain the packaged website. They do not need any special installation. Just download, configure and run it. Grab the latest release from nominatim-ui's Github release page and unpack it. You can use <code>nominatim-ui-x.x.x.tar.gz</code> or <code>nominatim-ui-x.x.x.zip</code>.</p> <p>Next you need to adapt the UI to your installation. Custom settings need to be put into <code>dist/theme/config.theme.js</code>. At a minimum you need to set <code>Nominatim_API_Endpoint</code> to point to your Nominatim installation:</p> <pre><code>cd nominatim-ui\necho \"Nominatim_Config.Nominatim_API_Endpoint='https://myserver.org/nominatim/';\" &gt; dist/theme/config.theme.js\n</code></pre> <p>For the full set of available settings, have a look at <code>dist/config.defaults.js</code>.</p> <p>Then you can just test it locally by spinning up a webserver in the <code>dist</code> directory. For example, with Python:</p> <pre><code>cd nominatim-ui/dist\npython3 -m http.server 8765\n</code></pre> <p>The website is now available at <code>http://localhost:8765</code>.</p>"},{"location":"admin/Setup-Nominatim-UI/#forwarding-searches-to-nominatim-ui","title":"Forwarding searches to nominatim-ui","text":"<p>Nominatim used to provide the search interface directly by itself when <code>format=html</code> was requested. For all endpoints except for <code>/reverse</code> and <code>/lookup</code> this even used to be the default.</p> <p>The following section describes how to set up Apache or nginx, so that your users are forwarded to nominatim-ui when they go to URL that formerly presented the UI.</p>"},{"location":"admin/Setup-Nominatim-UI/#setting-up-forwarding-in-nginx","title":"Setting up forwarding in Nginx","text":"<p>First of all make nominatim-ui available under <code>/ui</code> on your webserver:</p> <pre><code>server {\n\n    # Here is the Nominatim setup as described in the Installation section\n\n    location /ui/ {\n        alias &lt;full path to the nominatim-ui directory&gt;/dist/;\n        index index.html;\n    }\n}\n</code></pre> <p>Now we need to find out if a URL should be forwarded to the UI. Add the following <code>map</code> commands outside the server section:</p> <pre><code># Inspect the format parameter in the query arguments. We are interested\n# if it is set to html or something else or if it is missing completely.\nmap $args $format {\n    default                  default;\n    ~(^|&amp;)format=html(&amp;|$)   html;\n    ~(^|&amp;)format=            other;\n}\n\n# Determine from the URI and the format parameter above if forwarding is needed.\nmap $uri/$format $forward_to_ui {\n    default               1;   # The default is to forward.\n    ~^/ui                 0;   # If the URI point to the UI already, we are done.\n    ~/other$              0;   # An explicit non-html format parameter. No forwarding.\n    ~/reverse.*/default   0;   # Reverse and lookup assume xml format when\n    ~/lookup.*/default    0;   #   no format parameter is given. No forwarding.\n}\n</code></pre> <p>The <code>$forward_to_ui</code> parameter can now be used to conditionally forward the calls:</p> <pre><code># When no endpoint is given, default to search.\n# Need to add a rewrite so that the rewrite rules below catch it correctly.\nrewrite ^/$ /search;\n\nlocation @php {\n    # fastcgi stuff..\n    if ($forward_to_ui) {\n        rewrite ^(/[^/]*) https://yourserver.com/ui$1.html redirect;\n    }\n}\n\nlocation ~ [^/]\\.php(/|$) {\n    # fastcgi stuff..\n    if ($forward_to_ui) {\n        rewrite (.*).php https://yourserver.com/ui$1.html redirect;\n    }\n}\n</code></pre> <p>Warning</p> <p>Be aware that the rewrite commands are slightly different for URIs with and without the .php suffix.</p> <p>Reload nginx and the UI should be available.</p>"},{"location":"admin/Setup-Nominatim-UI/#setting-up-forwarding-in-apache","title":"Setting up forwarding in Apache","text":"<p>First of all make nominatim-ui available in the <code>ui/</code> subdirectory where Nominatim is installed. For example, given you have set up an alias under <code>nominatim</code> like this:</p> <pre><code>Alias /nominatim /home/vagrant/build/website\n</code></pre> <p>you need to insert the following rules for nominatim-ui before that alias:</p> <pre><code>&lt;Directory \"/home/vagrant/nominatim-ui/dist\"&gt;\n  DirectoryIndex search.html\n  Require all granted\n&lt;/Directory&gt;\n\nAlias /nominatim/ui /home/vagrant/nominatim-ui/dist\n</code></pre> <p>Replace <code>/home/vagrant/nominatim-ui</code> with the directory where you have cloned nominatim-ui.</p> <p>Important</p> <p>The alias for nominatim-ui must come before the alias for the Nominatim website directory.</p> <p>To set up forwarding, the Apache rewrite module is needed. Enable it with:</p> <pre><code>sudo a2enmod rewrite\n</code></pre> <p>Then add rewrite rules to the <code>Directory</code> directive of the Nominatim website directory like this:</p> <pre><code>&lt;Directory \"/home/vagrant/build/website\"&gt;\n  Options FollowSymLinks MultiViews\n  AddType text/html   .php\n  Require all granted\n\n  RewriteEngine On\n\n  # This must correspond to the URL where nominatim can be found.\n  RewriteBase \"/nominatim/\"\n\n  # If no endpoint is given, then use search.\n  RewriteRule ^(/|$)   \"search.php\"\n\n  # If format-html is explicitly requested, forward to the UI.\n  RewriteCond %{QUERY_STRING} \"format=html\"\n  RewriteRule ^([^/]+)(.php)? ui/$1.html [R,END]\n\n  # If no format parameter is there then forward anything\n  # but /reverse and /lookup to the UI.\n  RewriteCond %{QUERY_STRING} \"!format=\"\n  RewriteCond %{REQUEST_URI}  \"!/lookup\"\n  RewriteCond %{REQUEST_URI}  \"!/reverse\"\n  RewriteRule ^([^/]+)(.php)? ui/$1.html [R,END]\n&lt;/Directory&gt;\n</code></pre> <p>Restart Apache and the UI should be available.</p>"},{"location":"admin/Update/","title":"Updating the Database","text":"<p>There are many different ways to update your Nominatim database. The following section describes how to keep it up-to-date using an online replication service for OpenStreetMap data For a list of other methods to add or update data see the output of <code>nominatim add-data --help</code>.</p> <p>Important</p> <p>If you have configured a flatnode file for the import, then you need to keep this flatnode file around for updates.</p>"},{"location":"admin/Update/#installing-the-newest-version-of-pyosmium","title":"Installing the newest version of Pyosmium","text":"<p>The replication process uses Pyosmium to download update data from the server. It is recommended to install Pyosmium via pip. Run (as the same user who will later run the updates):</p> <pre><code>pip3 install --user osmium\n</code></pre>"},{"location":"admin/Update/#setting-up-the-update-process","title":"Setting up the update process","text":"<p>Next the update process needs to be initialised. By default Nominatim is configured to update using the global minutely diffs.</p> <p>If you want a different update source you will need to add some settings to <code>.env</code>. For example, to use the daily country extracts diffs for Ireland from Geofabrik add the following:</p> <pre><code># base URL of the replication service\nNOMINATIM_REPLICATION_URL=\"https://download.geofabrik.de/europe/ireland-and-northern-ireland-updates\"\n# How often upstream publishes diffs (in seconds)\nNOMINATIM_REPLICATION_UPDATE_INTERVAL=86400\n# How long to sleep if no update found yet (in seconds)\nNOMINATIM_REPLICATION_RECHECK_INTERVAL=900\n</code></pre> <p>To set up the update process now run the following command:</p> <pre><code>nominatim replication --init\n</code></pre> <p>It outputs the date where updates will start. Recheck that this date is what you expect.</p> <p>The <code>replication --init</code> command needs to be rerun whenever the replication service is changed.</p>"},{"location":"admin/Update/#updating-nominatim","title":"Updating Nominatim","text":"<p>Nominatim supports different modes how to retrieve the update data from the server. Which one you want to use depends on your exact setup and how often you want to retrieve updates.</p> <p>These instructions are for using a single source of updates. If you have imported multiple country extracts and want to keep them up-to-date, Advanced installations section contains instructions to set up and update multiple country extracts.</p>"},{"location":"admin/Update/#one-time-mode","title":"One-time mode","text":"<p>When the <code>--once</code> parameter is given, then Nominatim will download exactly one batch of updates and then exit. This one-time mode still respects the <code>NOMINATIM_REPLICATION_UPDATE_INTERVAL</code> that you have set. If according to the update interval no new data has been published yet, it will go to sleep until the next expected update and only then attempt to download the next batch.</p> <p>The one-time mode is particularly useful if you want to run updates continuously but need to schedule other work in between updates. For example, the main service at osm.org uses it, to regularly recompute postcodes -- a process that must not be run while updates are in progress. Its update script looks like this:</p> <pre><code>#!/bin/bash\n\n# Switch to your project directory.\ncd /srv/nominatim\n\nwhile true; do\n  nominatim replication --once\n  if [ -f \"/srv/nominatim/schedule-maintenance\" ]; then\n    rm /srv/nominatim/schedule-maintenance\n    nominatim refresh --postcodes\n  fi\ndone\n</code></pre> <p>A cron job then creates the file <code>/srv/nominatim/schedule-maintenance</code> once per night.</p>"},{"location":"admin/Update/#one-time-mode-with-systemd","title":"One-time mode with systemd","text":"<p>You can run the one-time mode with a systemd timer &amp; service.</p> <p>Create a timer description like <code>/etc/systemd/system/nominatim-updates.timer</code>:</p> <pre><code>[Unit]\nDescription=Timer to start updates of Nominatim\n\n[Timer]\nOnActiveSec=2\nOnUnitActiveSec=1min\nUnit=nominatim-updates.service\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> <p>And then a similar service definition: <code>/etc/systemd/system/nominatim-updates.service</code>:</p> <pre><code>[Unit]\nDescription=Single updates of Nominatim\n\n[Service]\nWorkingDirectory=/srv/nominatim\nExecStart=nominatim replication --once\nStandardOutput=append:/var/log/nominatim-updates.log\nStandardError=append:/var/log/nominatim-updates.error.log\nUser=nominatim\nGroup=nominatim\nType=simple\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> <p>Replace the <code>WorkingDirectory</code> with your project directory. Also adapt user and group names as required. <code>OnUnitActiveSec</code> defines how often the individual update command is run.</p> <p>Now activate the service and start the updates:</p> <pre><code>sudo systemctl daemon-reload\nsudo systemctl enable nominatim-updates.timer\nsudo systemctl start nominatim-updates.timer\n</code></pre> <p>You can stop future data updates, while allowing any current, in-progress update steps to finish, by running <code>sudo systemctl stop nominatim-updates.timer</code> and waiting until <code>nominatim-updates.service</code> isn't running (<code>sudo systemctl is-active nominatim-updates.service</code>). Current output from the update can be seen like above (<code>systemctl status nominatim-updates.service</code>).</p>"},{"location":"admin/Update/#catch-up-mode","title":"Catch-up mode","text":"<p>With the <code>--catch-up</code> parameter, Nominatim will immediately try to download all changes from the server until the database is up-to-date. The catch-up mode still respects the parameter <code>NOMINATIM_REPLICATION_MAX_DIFF</code>. It downloads and applies the changes in appropriate batches until all is done.</p> <p>The catch-up mode is foremost useful to bring the database up to speed after the initial import. Give that the service usually is not in production at this point, you can temporarily be a bit more generous with the batch size and number of threads you use for the updates by running catch-up like this:</p> <pre><code>cd /srv/nominatim\nNOMINATIM_REPLICATION_MAX_DIFF=5000 nominatim replication --catch-up --threads 15\n</code></pre> <p>The catch-up mode is also useful when you want to apply updates at a lower frequency than what the source publishes. You can set up a cron job to run replication catch-up at whatever interval you desire.</p> <p>Hint</p> <p>When running scheduled updates with catch-up, it is a good idea to choose a replication source with an update frequency that is an order of magnitude lower. For example, if you want to update once a day, use an hourly updated source. This makes sure that you don't miss an entire day of updates when the source is unexpectedly late to publish its update.</p> <p>If you want to use the source with the same update frequency (e.g. a daily updated source with daily updates), use the continuous update mode. It ensures to re-request the newest update until it is published.</p>"},{"location":"admin/Update/#continuous-updates","title":"Continuous updates","text":"<p>Danger</p> <p>This mode is no longer recommended to use and will removed in future releases. systemd is much better suited for running regular updates. Please refer to the setup instructions for running one-time mode with systemd above.</p> <p>This is the easiest mode. Simply run the replication command without any parameters:</p> <pre><code>nominatim replication\n</code></pre> <p>The update application keeps running forever and retrieves and applies new updates from the server as they are published.</p> <p>You can run this command as a simple systemd service. Create a service description like that in <code>/etc/systemd/system/nominatim-updates.service</code>:</p> <pre><code>[Unit]\nDescription=Continuous updates of Nominatim\n\n[Service]\nWorkingDirectory=/srv/nominatim\nExecStart=nominatim replication\nStandardOutput=append:/var/log/nominatim-updates.log\nStandardError=append:/var/log/nominatim-updates.error.log\nUser=nominatim\nGroup=nominatim\nType=simple\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> <p>Replace the <code>WorkingDirectory</code> with your project directory. Also adapt user and group names as required.</p> <p>Now activate the service and start the updates:</p> <pre><code>sudo systemctl daemon-reload\nsudo systemctl enable nominatim-updates\nsudo systemctl start nominatim-updates\n</code></pre>"},{"location":"api/Details/","title":"Place details","text":"<p>Show all details about a single place saved in the database.</p> <p>This API endpoint is meant for visual inspection of the data in the database, mainly together with Nominatim-UI. The parameters of the endpoint and the output may change occasionally between versions of Nominatim. Do not rely on the output in scripts or applications.</p> <p>Warning</p> <p>The details endpoint at https://nominatim.openstreetmap.org may not used in scripts or bots at all. See Nominatim Usage Policy.</p> <p>The details API supports the following two request formats:</p> <pre><code>https://nominatim.openstreetmap.org/details?osmtype=[N|W|R]&amp;osmid=&lt;value&gt;&amp;class=&lt;value&gt;\n</code></pre> <p><code>osmtype</code> and <code>osmid</code> are required parameters. The type is one of node (N), way (W) or relation (R). The id must be a number. The <code>class</code> parameter is optional and allows to distinguish between entries, when the corresponding OSM object has more than one main tag. For example, when a place is tagged with <code>tourism=hotel</code> and <code>amenity=restaurant</code>, there will be two place entries in Nominatim, one for a restaurant, one for a hotel. You need to specify <code>class=tourism</code> or <code>class=amentity</code> to get exactly the one you want. If there are multiple places in the database but the <code>class</code> parameter is left out, then one of the places will be chosen at random and displayed.</p> <pre><code>https://nominatim.openstreetmap.org/details?place_id=&lt;value&gt;\n</code></pre> <p>Place IDs are assigned sequentially during Nominatim data import. The ID for a place is different between Nominatim installation (servers) and changes when data gets reimported. Therefore it cannot be used as a permanent id and shouldn't be used in bug reports.</p> <p>Deprecation warning</p> <p>The API can also be used with the URL <code>https://nominatim.openstreetmap.org/details.php</code>. This is now deprecated and will be removed in future versions.</p>"},{"location":"api/Details/#parameters","title":"Parameters","text":"<p>This section lists additional optional parameters.</p>"},{"location":"api/Details/#output-format","title":"Output format","text":"Parameter Value Default json_callback function name unset <p>When set, then JSON output will be wrapped in a callback function with the given name. See JSONP for more information.</p> Parameter Value Default pretty 0 or 1 0 <p><code>[PHP-only]</code> Add indentation to the output to make it more human-readable.</p>"},{"location":"api/Details/#output-details","title":"Output details","text":"Parameter Value Default addressdetails 0 or 1 0 <p>When set to 1, include a breakdown of the address into elements.</p> Parameter Value Default keywords 0 or 1 0 <p>When set to 1, include a list of name keywords and address keywords in the result.</p> Parameter Value Default linkedplaces 0 or 1 1 <p>Include details of places that are linked with this one. Places get linked together when they are different forms of the same physical object. Nominatim links two kinds of objects together: place nodes get linked with the corresponding administrative boundaries. Waterway relations get linked together with their members.</p> Parameter Value Default hierarchy 0 or 1 0 <p>Include details of places lower in the address hierarchy.</p> <p><code>[Python-only]</code> will only return properly parented places. These are address or POI-like places that reuse the address of their parent street or place.</p> Parameter Value Default group_hierarchy 0 or 1 0 <p>When set to 1, the output of the address hierarchy will be grouped by type.</p> Parameter Value Default polygon_geojson 0 or 1 0 <p>Include geometry of result.</p>"},{"location":"api/Details/#language-of-results","title":"Language of results","text":"Parameter Value Default accept-language browser language string content of \"Accept-Language\" HTTP header <p>Preferred language order for showing search results. This may either be a simple comma-separated list of language codes or have the same format as the \"Accept-Language\" HTTP header.</p>"},{"location":"api/Details/#examples","title":"Examples","text":""},{"location":"api/Details/#json","title":"JSON","text":"<p>https://nominatim.openstreetmap.org/details.php?osmtype=W&amp;osmid=38210407&amp;format=json</p> <pre><code>{\n  \"place_id\": 85993608,\n  \"parent_place_id\": 72765313,\n  \"osm_type\": \"W\",\n  \"osm_id\": 38210407,\n  \"category\": \"place\",\n  \"type\": \"square\",\n  \"admin_level\": \"15\",\n  \"localname\": \"Pariser Platz\",\n  \"names\": {\n    \"name\": \"Pariser Platz\",\n    \"name:be\": \"\u041f\u0430\u0440\u044b\u0436\u0441\u043a\u0430\u044f \u043f\u043b\u043e\u0448\u0447\u0430\",\n    \"name:de\": \"Pariser Platz\",\n    \"name:es\": \"Plaza de Par\u00eds\",\n    \"name:he\": \"\u05e4\u05d0\u05e8\u05d9\u05d6\u05e8 \u05e4\u05dc\u05d0\u05e5\",\n    \"name:ko\": \"\ud30c\ub9ac\uc800 \uad11\uc7a5\",\n    \"name:la\": \"Forum Parisinum\",\n    \"name:ru\": \"\u041f\u0430\u0440\u0438\u0436\u0441\u043a\u0430\u044f \u043f\u043b\u043e\u0449\u0430\u0434\u044c\",\n    \"name:uk\": \"\u041f\u0430\u0440\u0438\u0437\u044c\u043a\u0430 \u043f\u043b\u043e\u0449\u0430\",\n    \"name:zh\": \"\u5df4\u9ece\u5ee3\u5834\"\n  },\n  \"addresstags\": {\n    \"postcode\": \"10117\"\n  },\n  \"housenumber\": null,\n  \"calculated_postcode\": \"10117\",\n  \"country_code\": \"de\",\n  \"indexed_date\": \"2018-08-18T17:02:45+00:00\",\n  \"importance\": 0.339401620591472,\n  \"calculated_importance\": 0.339401620591472,\n  \"extratags\": {\n    \"wikidata\": \"Q156716\",\n    \"wikipedia\": \"de:Pariser Platz\"\n  },\n  \"calculated_wikipedia\": \"de:Pariser_Platz\",\n  \"rank_address\": 30,\n  \"rank_search\": 30,\n  \"isarea\": true,\n  \"centroid\": {\n    \"type\": \"Point\",\n    \"coordinates\": [\n      13.3786822618517,\n      52.5163654\n    ]\n  },\n  \"geometry\": {\n    \"type\": \"Point\",\n    \"coordinates\": [\n      13.3786822618517,\n      52.5163654\n    ]\n  }\n}\n</code></pre>"},{"location":"api/Faq/","title":"Frequently Asked Questions","text":""},{"location":"api/Faq/#api-results","title":"API Results","text":""},{"location":"api/Faq/#1-the-address-of-my-search-results-contains-far-away-places-that-dont-belong-there","title":"1. The address of my search results contains far-away places that don't belong there.","text":"<p>Nominatim computes the address from two sources in the OpenStreetMap data: from administrative boundaries and from place nodes. Boundaries are the more useful source. They precisely describe an area. So it is very clear for Nominatim if a point belongs to an area or not. Place nodes are more complicated. These are only points without any precise extent. So Nominatim has to take a guess and assume that an address belongs to the closest place node it can find. In an ideal world, Nominatim would not need the place nodes but there are many places on earth where there are no precise boundaries available for all parts that make up an address. This is in particular true for the more local address parts, like villages and suburbs. Therefore it is not possible to completely dismiss place nodes. And sometimes they sneak in where they don't belong.</p> <p>As a OpenStreetMap mapper, you can improve the situation in two ways: if you see a place node for which already an administrative area exists, then you should link the two by adding the node with a 'label' role to the boundary relation. If there is no administrative area, you can add the approximate extent of the place and tag it place= as well."},{"location":"api/Faq/#2-when-doing-reverse-search-the-address-details-have-parts-that-dont-contain-the-point-i-was-looking-up","title":"2. When doing reverse search, the address details have parts that don't contain the point I was looking up.","text":"<p>There is a common misconception how the reverse API call works in Nominatim. Reverse does not give you the address of the point you asked for. Reverse returns the closest object to the point you asked for and then returns the address of that object. Now, if you are close to a border, then the closest object may be across that border. When Nominatim then returns the address, it contains the county/state/country across the border.</p>"},{"location":"api/Faq/#3-i-get-different-countiesstatescountries-when-i-change-the-zoom-parameter-in-the-reverse-query-how-is-that-possible","title":"3. I get different counties/states/countries when I change the zoom parameter in the reverse query. How is that possible?","text":"<p>This is basically the same problem as in the previous answer. The zoom level influences at which search rank Nominatim starts looking for the closest object. So the closest house number maybe on one side of the border while the closest street is on the other. As the address details contain the address of the closest object found, you might sometimes get one result, sometimes the other for the closest point.</p>"},{"location":"api/Faq/#4-can-you-return-the-continent","title":"4. Can you return the continent?","text":"<p>Nominatim assigns each map feature one country. Those outside any administrative boundaries are assigned a special no-country. Continents or other super-national administrations (e.g. European Union, NATO, Custom unions) are not supported, see also Administrative Boundary.</p>"},{"location":"api/Faq/#5-can-you-return-the-timezone","title":"5. Can you return the timezone?","text":"<p>See this separate OpenStreetMap-based project Timezone Boundary Builder.</p>"},{"location":"api/Faq/#6-i-want-to-download-a-list-of-streetsrestaurants-of-a-cityregion","title":"6. I want to download a list of streets/restaurants of a city/region","text":"<p>The Overpass API is more suited for these kinds of queries.</p> <p>That said if you installed your own Nominatim instance you can use the <code>nominatim export</code> PHP script as basis to return such lists.</p>"},{"location":"api/Faq/#7-my-result-has-a-wrong-postcode-where-does-it-come-from","title":"7. My result has a wrong postcode. Where does it come from?","text":"<p>Most places in OSM don't have a postcode, so Nominatim tries to interpolate one. It first look at all the places that make up the address of the place. If one of them has a postcode defined, this is the one to be used. When none of the address parts has a postcode either, Nominatim interpolates one from the surrounding objects. If the postcode is for your result is one, then most of the time there is an OSM object with the wrong postcode nearby.</p> <p>To find the bad postcode, go to https://nominatim.openstreetmap.org and search for your place. When you have found it, click on the 'details' link under the result to go to the details page. There is a field 'Computed Postcode' which should display the bad postcode. Click on the 'how?' link. A small explanation text appears. It contains a link to a query for Overpass Turbo. Click on that and you get a map with all places in the area that have the bad postcode. If none is displayed, zoom the map out a bit and then click on 'Run'.</p> <p>Now go to OpenStreetMap and fix the error you have just found. It will take at least a day for Nominatim to catch up with your data fix. Sometimes longer, depending on how much editing activity is in the area.</p>"},{"location":"api/Lookup/","title":"Address lookup","text":"<p>The lookup API allows to query the address and other details of one or multiple OSM objects like node, way or relation.</p>"},{"location":"api/Lookup/#endpoint","title":"Endpoint","text":"<p>The lookup API has the following format:</p> <pre><code>  https://nominatim.openstreetmap.org/lookup?osm_ids=[N|W|R]&lt;value&gt;,\u2026,\u2026,&amp;&lt;params&gt;\n</code></pre> <p><code>osm_ids</code> is mandatory and must contain a comma-separated list of OSM ids each prefixed with its type, one of node(N), way(W) or relation(R). Up to 50 ids can be queried at the same time.</p> <p>Deprecation warning</p> <p>The API can also be used with the URL <code>https://nominatim.openstreetmap.org/lookup.php</code>. This is now deprecated and will be removed in future versions.</p>"},{"location":"api/Lookup/#parameters","title":"Parameters","text":"<p>This section lists additional optional parameters.</p>"},{"location":"api/Lookup/#output-format","title":"Output format","text":"Parameter Value Default format one of: <code>xml</code>, <code>json</code>, <code>jsonv2</code>, <code>geojson</code>, <code>geocodejson</code> <code>jsonv2</code> <p>See Place Output Formats for details on each format.</p> Parameter Value Default json_callback function name unset <p>When given, then JSON output will be wrapped in a callback function with the given name. See JSONP for more information.</p> <p>Only has an effect for JSON output formats.</p>"},{"location":"api/Lookup/#output-details","title":"Output details","text":"Parameter Value Default addressdetails 0 or 1 0 <p>When set to 1, include a breakdown of the address into elements. The exact content of the address breakdown depends on the output format.</p> <p>Tip</p> <p>If you are interested in a stable classification of address categories (suburb, city, state, etc), have a look at the <code>geocodejson</code> format. All other formats return classifications according to OSM tagging. There is a much larger set of categories and they are not always consistent, which makes them very hard to work with.</p> Parameter Value Default extratags 0 or 1 0 <p>When set to 1, the response include any additional information in the result that is available in the database, e.g. wikipedia link, opening hours.</p> Parameter Value Default namedetails 0 or 1 0 <p>When set to 1, include a full list of names for the result. These may include language variants, older names, references and brand.</p>"},{"location":"api/Lookup/#language-of-results","title":"Language of results","text":"Parameter Value Default accept-language browser language string content of \"Accept-Language\" HTTP header <p>Preferred language order for showing search results. This may either be a simple comma-separated list of language codes or have the same format as the \"Accept-Language\" HTTP header.</p> <p>Tip</p> <p>First-time users of Nominatim tend to be confused that they get different results when using Nominatim in the browser versus in a command-line tool like wget or curl. The command-line tools usually don't send any Accept-Language header, prompting Nominatim to show results in the local language. Browsers on the contrary always send the currently chosen browser language.</p>"},{"location":"api/Lookup/#polygon-output","title":"Polygon output","text":"Parameter Value Default polygon_geojson 0 or 1 0 polygon_kml 0 or 1 0 polygon_svg 0 or 1 0 polygon_text 0 or 1 0 <p>Add the full geometry of the place to the result output. Output formats in GeoJSON, KML, SVG or WKT are supported. Only one of these options can be used at a time.</p> Parameter Value Default polygon_threshold floating-point number 0.0 <p>When one of the polygon_* outputs is chosen, return a simplified version of the output geometry. The parameter describes the tolerance in degrees with which the geometry may differ from the original geometry. Topology is preserved in the geometry.</p>"},{"location":"api/Lookup/#other","title":"Other","text":"Parameter Value Default email valid email address unset <p>If you are making large numbers of request please include an appropriate email address to identify your requests. See Nominatim's Usage Policy for more details.</p> Parameter Value Default debug 0 or 1 0 <p>Output assorted developer debug information. Data on internals of Nominatim's \"search loop\" logic, and SQL queries. The output is HTML format. This overrides the specified machine readable format.</p>"},{"location":"api/Lookup/#examples","title":"Examples","text":""},{"location":"api/Lookup/#xml","title":"XML","text":"<p>https://nominatim.openstreetmap.org/lookup?osm_ids=R146656,W104393803,N240109189</p> <pre><code>  &lt;lookupresults timestamp=\"Mon, 28 Mar 22 14:38:54 +0000\" attribution=\"Data &amp;#xA9; OpenStreetMap contributors, ODbL 1.0. http://www.openstreetmap.org/copyright\" querystring=\"R146656,W50637691,N240109189\" more_url=\"\"&gt;\n    &lt;place place_id=\"282236157\" osm_type=\"relation\" osm_id=\"146656\" place_rank=\"16\" address_rank=\"16\" boundingbox=\"53.3401044,53.5445923,-2.3199185,-2.1468288\" lat=\"53.44246175\" lon=\"-2.2324547359718547\" display_name=\"Manchester, Greater Manchester, North West England, England, United Kingdom\" class=\"boundary\" type=\"administrative\" importance=\"0.35\"&gt;\n      &lt;city&gt;Manchester&lt;/city&gt;\n      &lt;county&gt;Greater Manchester&lt;/county&gt;\n      &lt;state_district&gt;North West England&lt;/state_district&gt;\n      &lt;state&gt;England&lt;/state&gt;\n      &lt;country&gt;United Kingdom&lt;/country&gt;\n      &lt;country_code&gt;gb&lt;/country_code&gt;\n    &lt;/place&gt;\n    &lt;place place_id=\"115462561\" osm_type=\"way\" osm_id=\"50637691\" place_rank=\"30\" address_rank=\"30\" boundingbox=\"52.3994612,52.3996426,13.0479574,13.0481754\" lat=\"52.399550700000006\" lon=\"13.048066846939687\" display_name=\"Brandenburger Tor, Brandenburger Stra&amp;#xDF;e, Historische Innenstadt, Innenstadt, Potsdam, Brandenburg, 14467, Germany\" class=\"tourism\" type=\"attraction\" importance=\"0.29402874005524\"&gt;\n      &lt;tourism&gt;Brandenburger Tor&lt;/tourism&gt;\n      &lt;road&gt;Brandenburger Stra&amp;#xDF;e&lt;/road&gt;\n      &lt;suburb&gt;Historische Innenstadt&lt;/suburb&gt;\n      &lt;city&gt;Potsdam&lt;/city&gt;\n      &lt;state&gt;Brandenburg&lt;/state&gt;\n      &lt;postcode&gt;14467&lt;/postcode&gt;\n      &lt;country&gt;Germany&lt;/country&gt;\n      &lt;country_code&gt;de&lt;/country_code&gt;\n    &lt;/place&gt;\n    &lt;place place_id=\"567505\" osm_type=\"node\" osm_id=\"240109189\" place_rank=\"15\" address_rank=\"16\" boundingbox=\"52.3586925,52.6786925,13.2396024,13.5596024\" lat=\"52.5186925\" lon=\"13.3996024\" display_name=\"Berlin, 10178, Germany\" class=\"place\" type=\"city\" importance=\"0.78753902824914\"&gt;\n      &lt;city&gt;Berlin&lt;/city&gt;\n      &lt;state&gt;Berlin&lt;/state&gt;\n      &lt;postcode&gt;10178&lt;/postcode&gt;\n      &lt;country&gt;Germany&lt;/country&gt;\n      &lt;country_code&gt;de&lt;/country_code&gt;\n    &lt;/place&gt;\n  &lt;/lookupresults&gt;\n</code></pre>"},{"location":"api/Lookup/#json-with-extratags","title":"JSON with extratags","text":"<p>https://nominatim.openstreetmap.org/lookup?osm_ids=W50637691&amp;format=json&amp;extratags=1</p> <pre><code>[\n   {\n      \"place_id\": 115462561,\n      \"licence\": \"Data \u00a9 OpenStreetMap contributors, ODbL 1.0. https://osm.org/copyright\",\n      \"osm_type\": \"way\",\n      \"osm_id\": 50637691,\n      \"boundingbox\": [\n        \"52.3994612\",\n        \"52.3996426\",\n        \"13.0479574\",\n        \"13.0481754\"\n      ],\n      \"lat\": \"52.399550700000006\",\n      \"lon\": \"13.048066846939687\",\n      \"display_name\": \"Brandenburger Tor, Brandenburger Stra\u00dfe, Historische Innenstadt, Innenstadt, Potsdam, Brandenburg, 14467, Germany\",\n      \"class\": \"tourism\",\n      \"type\": \"attraction\",\n      \"importance\": 0.2940287400552381,\n      \"address\": {\n        \"tourism\": \"Brandenburger Tor\",\n        \"road\": \"Brandenburger Stra\u00dfe\",\n        \"suburb\": \"Historische Innenstadt\",\n        \"city\": \"Potsdam\",\n        \"state\": \"Brandenburg\",\n        \"postcode\": \"14467\",\n        \"country\": \"Germany\",\n        \"country_code\": \"de\"\n      },\n      \"extratags\": {\n        \"image\": \"http://commons.wikimedia.org/wiki/File:Potsdam_brandenburger_tor.jpg\",\n        \"heritage\": \"4\",\n        \"wikidata\": \"Q695045\",\n        \"architect\": \"Carl von Gontard;Georg Christian Unger\",\n        \"wikipedia\": \"de:Brandenburger Tor (Potsdam)\",\n        \"wheelchair\": \"yes\",\n        \"description\": \"Kleines Brandenburger Tor in Potsdam\",\n        \"heritage:website\": \"http://www.bldam-brandenburg.de/images/stories/PDF/DML%202012/04-p-internet-13.pdf\",\n        \"heritage:operator\": \"bldam\",\n        \"architect:wikidata\": \"Q68768;Q95223\",\n        \"year_of_construction\": \"1771\"\n      }\n   }\n]\n</code></pre>"},{"location":"api/Output/","title":"Place Output","text":"<p>The /reverse, /search and /lookup API calls produce very similar output which is explained in this section. There is one section for each format. The format correspond to what was selected via the <code>format</code> parameter.</p>"},{"location":"api/Output/#json","title":"JSON","text":"<p>The JSON format returns an array of places (for search and lookup) or a single place (for reverse) of the following format:</p> <pre><code>  {\n    \"place_id\": \"100149\",\n    \"licence\": \"Data \u00a9 OpenStreetMap contributors, ODbL 1.0. https://osm.org/copyright\",\n    \"osm_type\": \"node\",\n    \"osm_id\": \"107775\",\n    \"boundingbox\": [\"51.3473219\", \"51.6673219\", \"-0.2876474\", \"0.0323526\"],\n    \"lat\": \"51.5073219\",\n    \"lon\": \"-0.1276474\",\n    \"display_name\": \"London, Greater London, England, SW1A 2DU, United Kingdom\",\n    \"class\": \"place\",\n    \"type\": \"city\",\n    \"importance\": 0.9654895765402,\n    \"icon\": \"https://nominatim.openstreetmap.org/images/mapicons/poi_place_city.p.20.png\",\n    \"address\": {\n      \"city\": \"London\",\n      \"state_district\": \"Greater London\",\n      \"state\": \"England\",\n      \"ISO3166-2-lvl4\": \"GB-ENG\",\n      \"postcode\": \"SW1A 2DU\",\n      \"country\": \"United Kingdom\",\n      \"country_code\": \"gb\"\n    },\n    \"extratags\": {\n      \"capital\": \"yes\",\n      \"website\": \"http://www.london.gov.uk\",\n      \"wikidata\": \"Q84\",\n      \"wikipedia\": \"en:London\",\n      \"population\": \"8416535\"\n    }\n  }\n</code></pre> <p>The possible fields are:</p> <ul> <li><code>place_id</code> - reference to the Nominatim internal database ID (see notes)</li> <li><code>osm_type</code>, <code>osm_id</code> - reference to the OSM object (see notes)</li> <li><code>boundingbox</code> - area of corner coordinates (see notes)</li> <li><code>lat</code>, <code>lon</code> - latitude and longitude of the centroid of the object</li> <li><code>display_name</code> - full comma-separated address</li> <li><code>class</code>, <code>type</code> - key and value of the main OSM tag</li> <li><code>importance</code> - computed importance rank</li> <li><code>icon</code> - link to class icon (if available)</li> <li><code>address</code> - dictionary of address details (only with <code>addressdetails=1</code>,    see notes)</li> <li><code>extratags</code> - dictionary with additional useful tags like website or maxspeed    (only with <code>extratags=1</code>)</li> <li><code>namedetails</code> - dictionary with full list of available names including ref etc.</li> <li><code>geojson</code>, <code>svg</code>, <code>geotext</code>, <code>geokml</code> - full geometry    (only with the appropriate <code>polygon_*</code> parameter)</li> </ul>"},{"location":"api/Output/#jsonv2","title":"JSONv2","text":"<p>This is the same as the JSON format with two changes:</p> <ul> <li><code>class</code> renamed to <code>category</code></li> <li>additional field <code>place_rank</code> with the search rank of the object</li> </ul>"},{"location":"api/Output/#geojson","title":"GeoJSON","text":"<p>This format follows the RFC7946. Every feature includes a bounding box (<code>bbox</code>).</p> <p>The properties object has the following fields:</p> <ul> <li><code>place_id</code> - reference to the Nominatim internal database ID (see notes)</li> <li><code>osm_type</code>, <code>osm_id</code> - reference to the OSM object (see notes)</li> <li><code>category</code>, <code>type</code> - key and value of the main OSM tag</li> <li><code>display_name</code> - full comma-separated address</li> <li><code>place_rank</code> - class search rank</li> <li><code>importance</code> - computed importance rank</li> <li><code>icon</code> - link to class icon (if available)</li> <li><code>address</code> - dictionary of address details (only with <code>addressdetails=1</code>,    see notes)</li> <li><code>extratags</code> - dictionary with additional useful tags like <code>website</code> or <code>maxspeed</code>    (only with <code>extratags=1</code>)</li> <li><code>namedetails</code> - dictionary with full list of available names including ref etc.</li> </ul> <p>Use <code>polygon_geojson</code> to output the full geometry of the object instead of the centroid.</p>"},{"location":"api/Output/#geocodejson","title":"GeocodeJSON","text":"<p>The GeocodeJSON format follows the GeocodeJSON spec 0.1.0. The following feature attributes are implemented:</p> <ul> <li><code>osm_type</code>, <code>osm_id</code> - reference to the OSM object (unofficial extension, see notes)</li> <li><code>type</code> - the 'address level' of the object ('house', 'street', <code>district</code>, <code>city</code>,             <code>county</code>, <code>state</code>, <code>country</code>, <code>locality</code>)</li> <li><code>osm_key</code>- key of the main tag of the OSM object (e.g. boundary, highway, amenity)</li> <li><code>osm_value</code> - value of the main tag of the OSM object (e.g. residential, restaurant)</li> <li><code>label</code> - full comma-separated address</li> <li><code>name</code> - localised name of the place</li> <li><code>housenumber</code>, <code>street</code>, <code>locality</code>, <code>district</code>, <code>postcode</code>, <code>city</code>,    <code>county</code>, <code>state</code>, <code>country</code> -    provided when it can be determined from the address</li> <li><code>admin</code> - list of localised names of administrative boundaries (only with <code>addressdetails=1</code>)</li> </ul> <p>Use <code>polygon_geojson</code> to output the full geometry of the object instead of the centroid.</p>"},{"location":"api/Output/#xml","title":"XML","text":"<p>The XML response returns one or more place objects in slightly different formats depending on the API call.</p>"},{"location":"api/Output/#reverse","title":"Reverse","text":"<pre><code>&lt;reversegeocode timestamp=\"Sat, 11 Aug 18 11:53:21 +0000\"\n                attribution=\"Data \u00a9 OpenStreetMap contributors, ODbL 1.0. https://www.openstreetmap.org/copyright\"\n                querystring=\"lat=48.400381&amp;lon=11.745876&amp;zoom=5&amp;format=xml\"&gt;\n  &lt;result place_id=\"179509537\" osm_type=\"relation\" osm_id=\"2145268\" ref=\"BY\" place_rank=\"15\" address_rank=\"15\"\n          lat=\"48.9467562\" lon=\"11.4038717\"\n          boundingbox=\"47.2701114,50.5647142,8.9763497,13.8396373\"&gt;\n       Bavaria, Germany\n  &lt;/result&gt;\n  &lt;addressparts&gt;\n     &lt;state&gt;Bavaria&lt;/state&gt;\n     &lt;ISO3166-2-lvl4&gt;DE-BY&lt;/ISO3166-2-lvl4&gt;\n     &lt;country&gt;Germany&lt;/country&gt;\n     &lt;country_code&gt;de&lt;/country_code&gt;\n  &lt;/addressparts&gt;\n  &lt;extratags&gt;\n    &lt;tag key=\"place\" value=\"state\"/&gt;\n    &lt;tag key=\"wikidata\" value=\"Q980\"/&gt;\n    &lt;tag key=\"wikipedia\" value=\"de:Bayern\"/&gt;\n    &lt;tag key=\"population\" value=\"12520000\"/&gt;\n    &lt;tag key=\"name:prefix\" value=\"Freistaat\"/&gt;\n  &lt;/extratags&gt;\n&lt;/reversegeocode&gt;\n</code></pre> <p>The attributes of the outer <code>reversegeocode</code> element return generic information about the query, including the time when the response was sent (in UTC), attribution to OSM and the original querystring.</p> <p>The place information can be found in the <code>result</code> element. The attributes of that element contain:</p> <ul> <li><code>place_id</code> - reference to the Nominatim internal database ID (see notes)</li> <li><code>osm_type</code>, <code>osm_id</code> - reference to the OSM object (see notes)</li> <li><code>ref</code> - content of <code>ref</code> tag if it exists</li> <li><code>lat</code>, <code>lon</code> - latitude and longitude of the centroid of the object</li> <li><code>boundingbox</code> - comma-separated list of corner coordinates (see notes)</li> </ul> <p>The full address of the result can be found in the content of the <code>result</code> element as a comma-separated list.</p> <p>Additional information requested with <code>addressdetails=1</code>, <code>extratags=1</code> and <code>namedetails=1</code> can be found in extra elements.</p>"},{"location":"api/Output/#search-and-lookup","title":"Search and Lookup","text":"<pre><code>&lt;searchresults timestamp=\"Sat, 11 Aug 18 11:55:35 +0000\"\n               attribution=\"Data \u00a9 OpenStreetMap contributors, ODbL 1.0. https://www.openstreetmap.org/copyright\"\n               querystring=\"london\" polygon=\"false\" exclude_place_ids=\"100149\"\n               more_url=\"https://nominatim.openstreetmap.org/search.php?q=london&amp;addressdetails=1&amp;extratags=1&amp;exclude_place_ids=100149&amp;format=xml&amp;accept-language=en-US%2Cen%3Bq%3D0.7%2Cde%3Bq%3D0.3\"&gt;\n  &lt;place place_id=\"100149\" osm_type=\"node\" osm_id=\"107775\" place_rank=\"15\" address_rank=\"15\"\n         boundingbox=\"51.3473219,51.6673219,-0.2876474,0.0323526\" lat=\"51.5073219\" lon=\"-0.1276474\"\n         display_name=\"London, Greater London, England, SW1A 2DU, United Kingdom\"\n         class=\"place\" type=\"city\" importance=\"0.9654895765402\"\n         icon=\"https://nominatim.openstreetmap.org/images/mapicons/poi_place_city.p.20.png\"&gt;\n    &lt;extratags&gt;\n      &lt;tag key=\"capital\" value=\"yes\"/&gt;\n      &lt;tag key=\"website\" value=\"http://www.london.gov.uk\"/&gt;\n      &lt;tag key=\"wikidata\" value=\"Q84\"/&gt;\n      &lt;tag key=\"wikipedia\" value=\"en:London\"/&gt;\n      &lt;tag key=\"population\" value=\"8416535\"/&gt;\n    &lt;/extratags&gt;\n    &lt;city&gt;London&lt;/city&gt;\n    &lt;state_district&gt;Greater London&lt;/state_district&gt;\n    &lt;state&gt;England&lt;/state&gt;\n    &lt;ISO3166-2-lvl4&gt;GB-ENG&lt;/ISO3166-2-lvl4&gt;\n    &lt;postcode&gt;SW1A 2DU&lt;/postcode&gt;\n    &lt;country&gt;United Kingdom&lt;/country&gt;\n    &lt;country_code&gt;gb&lt;/country_code&gt;\n  &lt;/place&gt;\n&lt;/searchresults&gt;\n</code></pre> <p>The attributes of the outer <code>searchresults</code> or <code>lookupresults</code> element return generic information about the query:</p> <ul> <li><code>timestamp</code> - UTC time when the response was sent</li> <li><code>attribution</code> - OSM licensing information</li> <li><code>querystring</code> - original query</li> <li><code>polygon</code> - true when extra geometry information was requested</li> <li><code>exclude_place_ids</code> - IDs of places that should be ignored in a follow-up request</li> <li><code>more_url</code> - search call that will yield additional results for the query    just sent</li> </ul> <p>The place information can be found in the <code>place</code> elements, of which there may be more than one. The attributes of that element contain:</p> <ul> <li><code>place_id</code> - reference to the Nominatim internal database ID (see notes)</li> <li><code>osm_type</code>, <code>osm_id</code> - reference to the OSM object (see notes)</li> <li><code>ref</code> - content of <code>ref</code> tag if it exists</li> <li><code>lat</code>, <code>lon</code> - latitude and longitude of the centroid of the object</li> <li><code>boundingbox</code> - comma-separated list of corner coordinates (see notes)</li> <li><code>place_rank</code> - class search rank</li> <li><code>address_rank</code> - place address rank</li> <li><code>display_name</code> - full comma-separated address</li> <li><code>class</code>, <code>type</code> - key and value of the main OSM tag</li> <li><code>importance</code> - computed importance rank</li> <li><code>icon</code> - link to class icon (if available)</li> </ul> <p>When <code>addressdetails=1</code> is requested, the localised address parts appear as subelements with the type of the address part.</p> <p>Additional information requested with <code>extratags=1</code> and <code>namedetails=1</code> can be found in extra elements as sub-element of <code>extratags</code> and <code>namedetails</code> respectively.</p>"},{"location":"api/Output/#notes-on-field-values","title":"Notes on field values","text":""},{"location":"api/Output/#place_id-is-not-a-persistent-id","title":"place_id is not a persistent id","text":"<p>The <code>place_id</code> is an internal identifier that is assigned data is imported into a Nominatim database. The same OSM object will have a different value on another server. It may even change its ID on the same server when it is removed and reimported while updating the database with fresh OSM data. It is thus not useful to treat it as permanent for later use.</p> <p>The combination <code>osm_type</code>+<code>osm_id</code> is slightly better but remember in OpenStreetMap mappers can delete, split, recreate places (and those get a new <code>osm_id</code>), there is no link between those old and new ids. Places can also change their meaning without changing their <code>osm_id</code>, e.g. when a restaurant is retagged as supermarket. For a more in-depth discussion see Permanent ID.</p> <p>If you need an ID that is consistent over multiple installations of Nominatim, then you should use the combination of <code>osm_type</code>+<code>osm_id</code>+<code>class</code>.</p>"},{"location":"api/Output/#osm-reference","title":"OSM reference","text":"<p>Nominatim may sometimes return special objects that do not correspond directly to an object in OpenStreetMap. These are:</p> <ul> <li>Postcodes. Nominatim returns an postcode point created from all mapped   postcodes of the same name. The class and type of these object is <code>place=postcdode</code>.   No <code>osm_type</code> and <code>osm_id</code> are included in the result.</li> <li>Housenumber interpolations. Nominatim returns a single interpolated   housenumber from the interpolation way. The class and type are <code>place=house</code>   and <code>osm_type</code> and <code>osm_id</code> correspond to the interpolation way in OSM.</li> <li>TIGER housenumber. Nominatim returns a single interpolated housenumber   from the TIGER data. The class and type are <code>place=house</code>   and <code>osm_type</code> and <code>osm_id</code> correspond to the street mentioned in the result.</li> </ul> <p>Please note that the <code>osm_type</code> and <code>osm_id</code> returned may be changed in the future. You should not expect to only find <code>node</code>, <code>way</code> and <code>relation</code> for the type.</p>"},{"location":"api/Output/#boundingbox","title":"boundingbox","text":"<p>Comma separated list of min latitude, max latitude, min longitude, max longitude. The whole planet would be <code>-90,90,-180,180</code>.</p> <p>Can be used to pan and center the map on the result, for example with leafletjs mapping library <code>map.fitBounds([[bbox[0],bbox[2]],[bbox[1],bbox[3]]], {padding: [20, 20], maxzoom: 16});</code></p> <p>Bounds crossing the antimeridian have a min latitude -180 and max latitude 180, essentially covering the entire planet (see issue 184).</p>"},{"location":"api/Output/#addressdetails","title":"addressdetails","text":"<p>Address details in the xml and json formats return a list of names together with a designation label. Per default the following labels may appear:</p> <ul> <li>continent</li> <li>country, country_code</li> <li>region, state, state_district, county, ISO3166-2-lvl <li>municipality, city, town, village</li> <li>city_district, district, borough, suburb, subdivision</li> <li>hamlet, croft, isolated_dwelling</li> <li>neighbourhood, allotments, quarter</li> <li>city_block, residential, farm, farmyard, industrial, commercial, retail</li> <li>road</li> <li>house_number, house_name</li> <li>emergency, historic, military, natural, landuse, place, railway,    man_made, aerialway, boundary, amenity, aeroway, club, craft, leisure,    office, mountain_pass, shop, tourism, bridge, tunnel, waterway</li> <li>postcode</li> <p>They roughly correspond to the classification of the OpenStreetMap data according to either the <code>place</code> tag or the main key of the object.</p>"},{"location":"api/Overview/","title":"Overview","text":""},{"location":"api/Overview/#nominatim-api","title":"Nominatim API","text":"<p>Attention</p> <p>The current version of Nominatim implements two different search frontends: the old PHP frontend and the new Python frontend. They have a very similar API but differ in some implementation details. These are marked in the documentation as <code>[Python-only]</code> or <code>[PHP-only]</code>.</p> <p><code>https://nominatim.openstreetmap.org</code> implements the Python frontend. So users should refer to the <code>[Python-only]</code> comments.</p> <p>This section describes the API V1 of the Nominatim web service. The service offers the following endpoints:</p> <ul> <li>/search - search OSM objects by name or type</li> <li>/reverse - search OSM object by their location</li> <li>/lookup - look up address details for OSM objects by their ID</li> <li>/status - query the status of the server</li> <li>/deletable - list objects that have been deleted in OSM but are held                     back in Nominatim in case the deletion was accidental</li> <li>/polygons - list of broken polygons detected by Nominatim</li> <li>/details - show internal details for an object (for debugging only)</li> </ul>"},{"location":"api/Reverse/","title":"Reverse Geocoding","text":"<p>Reverse geocoding generates an address from a coordinate given as latitude and longitude.</p>"},{"location":"api/Reverse/#how-it-works","title":"How it works","text":"<p>The reverse geocoding API does not exactly compute the address for the coordinate it receives. It works by finding the closest suitable OSM object and returning its address information. This may occasionally lead to unexpected results.</p> <p>First of all, Nominatim only includes OSM objects in its index that are suitable for searching. Small, unnamed paths for example are missing from the database and can therefore not be used for reverse geocoding either.</p> <p>The other issue to be aware of is that the closest OSM object may not always have a similar enough address to the coordinate you were requesting. For example, in dense city areas it may belong to a completely different street.</p>"},{"location":"api/Reverse/#endpoint","title":"Endpoint","text":"<p>The main format of the reverse API is</p> <pre><code>https://nominatim.openstreetmap.org/reverse?lat=&lt;value&gt;&amp;lon=&lt;value&gt;&amp;&lt;params&gt;\n</code></pre> <p>where <code>lat</code> and <code>lon</code> are latitude and longitude of a coordinate in WGS84 projection. The API returns exactly one result or an error when the coordinate is in an area with no OSM data coverage.</p> <p>Deprecation warning</p> <p>The reverse API used to allow address lookup for a single OSM object by its OSM id for <code>[PHP-only]</code>. The use is considered deprecated. Use the Address Lookup API instead.</p> <p>Deprecation warning</p> <p>The API can also be used with the URL <code>https://nominatim.openstreetmap.org/reverse.php</code>. This is now deprecated and will be removed in future versions.</p>"},{"location":"api/Reverse/#parameters","title":"Parameters","text":"<p>This section lists additional parameters to further influence the output.</p>"},{"location":"api/Reverse/#output-format","title":"Output format","text":"Parameter Value Default format one of: <code>xml</code>, <code>json</code>, <code>jsonv2</code>, <code>geojson</code>, <code>geocodejson</code> <code>xml</code> <p>See Place Output Formats for details on each format.</p> Parameter Value Default json_callback function name unset <p>When given, then JSON output will be wrapped in a callback function with the given name. See JSONP for more information.</p> <p>Only has an effect for JSON output formats.</p>"},{"location":"api/Reverse/#output-details","title":"Output details","text":"Parameter Value Default addressdetails 0 or 1 1 <p>When set to 1, include a breakdown of the address into elements. The exact content of the address breakdown depends on the output format.</p> <p>Tip</p> <p>If you are interested in a stable classification of address categories (suburb, city, state, etc), have a look at the <code>geocodejson</code> format. All other formats return classifications according to OSM tagging. There is a much larger set of categories and they are not always consistent, which makes them very hard to work with.</p> Parameter Value Default extratags 0 or 1 0 <p>When set to 1, the response include any additional information in the result that is available in the database, e.g. wikipedia link, opening hours.</p> Parameter Value Default namedetails 0 or 1 0 <p>When set to 1, include a full list of names for the result. These may include language variants, older names, references and brand.</p>"},{"location":"api/Reverse/#language-of-results","title":"Language of results","text":"Parameter Value Default accept-language browser language string content of \"Accept-Language\" HTTP header <p>Preferred language order for showing search results. This may either be a simple comma-separated list of language codes or have the same format as the \"Accept-Language\" HTTP header.</p> <p>Tip</p> <p>First-time users of Nominatim tend to be confused that they get different results when using Nominatim in the browser versus in a command-line tool like wget or curl. The command-line tools usually don't send any Accept-Language header, prompting Nominatim to show results in the local language. Browsers on the contrary always send the currently chosen browser language.</p>"},{"location":"api/Reverse/#result-restriction","title":"Result restriction","text":"Parameter Value Default zoom 0-18 18 <p>Level of detail required for the address. This is a number that corresponds roughly to the zoom level used in XYZ tile sources in frameworks like Leaflet.js, Openlayers etc. In terms of address details the zoom levels are as follows:</p> zoom address detail 3 country 5 state 8 county 10 city 12 town / borough 13 village / suburb 14 neighbourhood 15 any settlement 16 major streets 17 major and minor streets 18 building Parameter Value Default layer comma-separated list of: <code>address</code>, <code>poi</code>, <code>railway</code>, <code>natural</code>, <code>manmade</code> unset (no restriction) <p><code>[Python-only]</code></p> <p>The layer filter allows to select places by themes.</p> <p>The <code>address</code> layer contains all places that make up an address: address points with house numbers, streets, inhabited places (suburbs, villages, cities, states etc.) and administrative boundaries.</p> <p>The <code>poi</code> layer selects all point of interest. This includes classic points of interest like restaurants, shops, hotels but also less obvious features like recycling bins, guideposts or benches.</p> <p>The <code>railway</code> layer includes railway infrastructure like tracks. Note that in Nominatim's standard configuration, only very few railway features are imported into the database.</p> <p>The <code>natural</code> layer collects features like rivers, lakes and mountains while the <code>manmade</code> layer functions as a catch-all for features not covered by the other layers.</p>"},{"location":"api/Reverse/#polygon-output","title":"Polygon output","text":"Parameter Value Default polygon_geojson 0 or 1 0 polygon_kml 0 or 1 0 polygon_svg 0 or 1 0 polygon_text 0 or 1 0 <p>Add the full geometry of the place to the result output. Output formats in GeoJSON, KML, SVG or WKT are supported. Only one of these options can be used at a time.</p> Parameter Value Default polygon_threshold floating-point number 0.0 <p>When one of the polygon_* outputs is chosen, return a simplified version of the output geometry. The parameter describes the tolerance in degrees with which the geometry may differ from the original geometry. Topology is preserved in the geometry.</p>"},{"location":"api/Reverse/#other","title":"Other","text":"Parameter Value Default email valid email address unset <p>If you are making large numbers of request please include an appropriate email address to identify your requests. See Nominatim's Usage Policy for more details.</p> Parameter Value Default debug 0 or 1 0 <p>Output assorted developer debug information. Data on internals of Nominatim's \"search loop\" logic, and SQL queries. The output is HTML format. This overrides the specified machine readable format.</p>"},{"location":"api/Reverse/#examples","title":"Examples","text":"<ul> <li>https://nominatim.openstreetmap.org/reverse?format=xml&amp;lat=52.5487429714954&amp;lon=-1.81602098644987&amp;zoom=18&amp;addressdetails=1</li> </ul> <pre><code>  &lt;reversegeocode timestamp=\"Fri, 06 Nov 09 16:33:54 +0000\" querystring=\"...\"&gt;\n    &lt;result place_id=\"1620612\" osm_type=\"node\" osm_id=\"452010817\"&gt;\n      135, Pilkington Avenue, Wylde Green, City of Birmingham, West Midlands (county), B72, United Kingdom\n    &lt;/result&gt;\n    &lt;addressparts&gt;\n      &lt;house_number&gt;135&lt;/house_number&gt;\n      &lt;road&gt;Pilkington Avenue&lt;/road&gt;\n      &lt;village&gt;Wylde Green&lt;/village&gt;\n      &lt;town&gt;Sutton Coldfield&lt;/town&gt;\n      &lt;city&gt;City of Birmingham&lt;/city&gt;\n      &lt;county&gt;West Midlands (county)&lt;/county&gt;\n      &lt;postcode&gt;B72&lt;/postcode&gt;\n      &lt;country&gt;United Kingdom&lt;/country&gt;\n      &lt;country_code&gt;gb&lt;/country_code&gt;\n    &lt;/addressparts&gt;\n  &lt;/reversegeocode&gt;\n</code></pre>"},{"location":"api/Reverse/#example-with-formatjsonv2","title":"Example with <code>format=jsonv2</code>","text":"<ul> <li>https://nominatim.openstreetmap.org/reverse?format=jsonv2&amp;lat=-34.44076&amp;lon=-58.70521</li> </ul> <pre><code>{\n  \"place_id\":\"134140761\",\n  \"licence\":\"Data \u00a9 OpenStreetMap contributors, ODbL 1.0. https:\\/\\/www.openstreetmap.org\\/copyright\",\n  \"osm_type\":\"way\",\n  \"osm_id\":\"280940520\",\n  \"lat\":\"-34.4391708\",\n  \"lon\":\"-58.7064573\",\n  \"place_rank\":\"26\",\n  \"category\":\"highway\",\n  \"type\":\"motorway\",\n  \"importance\":\"0.1\",\n  \"addresstype\":\"road\",\n  \"display_name\":\"Autopista Pedro Eugenio Aramburu, El Tri\u00e1ngulo, Partido de Malvinas Argentinas, Buenos Aires, 1.619, Argentina\",\n  \"name\":\"Autopista Pedro Eugenio Aramburu\",\n  \"address\":{\n    \"road\":\"Autopista Pedro Eugenio Aramburu\",\n    \"village\":\"El Tri\u00e1ngulo\",\n    \"state_district\":\"Partido de Malvinas Argentinas\",\n    \"state\":\"Buenos Aires\",\n    \"postcode\":\"1.619\",\n    \"country\":\"Argentina\",\n    \"country_code\":\"ar\"\n  },\n  \"boundingbox\":[\"-34.44159\",\"-34.4370994\",\"-58.7086067\",\"-58.7044712\"]\n}\n</code></pre>"},{"location":"api/Reverse/#example-with-formatgeojson","title":"Example with <code>format=geojson</code>","text":"<ul> <li>https://nominatim.openstreetmap.org/reverse?format=geojson&amp;lat=44.50155&amp;lon=11.33989</li> </ul> <pre><code>{\n  \"type\": \"FeatureCollection\",\n  \"licence\": \"Data \u00a9 OpenStreetMap contributors, ODbL 1.0. https://osm.org/copyright\",\n  \"features\": [\n    {\n      \"type\": \"Feature\",\n      \"properties\": {\n        \"place_id\": \"18512203\",\n        \"osm_type\": \"node\",\n        \"osm_id\": \"1704756187\",\n        \"place_rank\": \"30\",\n        \"category\": \"place\",\n        \"type\": \"house\",\n        \"importance\": \"0\",\n        \"addresstype\": \"place\",\n        \"name\": null,\n        \"display_name\": \"71, Via Guglielmo Marconi, Saragozza-Porto, Bologna, BO, Emilia-Romagna, 40122, Italy\",\n        \"address\": {\n          \"house_number\": \"71\",\n          \"road\": \"Via Guglielmo Marconi\",\n          \"suburb\": \"Saragozza-Porto\",\n          \"city\": \"Bologna\",\n          \"county\": \"BO\",\n          \"state\": \"Emilia-Romagna\",\n          \"postcode\": \"40122\",\n          \"country\": \"Italy\",\n          \"country_code\": \"it\"\n        }\n      },\n      \"bbox\": [\n        11.3397676,\n        44.5014307,\n        11.3399676,\n        44.5016307\n      ],\n      \"geometry\": {\n        \"type\": \"Point\",\n        \"coordinates\": [\n          11.3398676,\n          44.5015307\n        ]\n      }\n    }\n  ]\n}\n</code></pre>"},{"location":"api/Reverse/#example-with-formatgeocodejson","title":"Example with <code>format=geocodejson</code>","text":"<p>https://nominatim.openstreetmap.org/reverse?format=geocodejson&amp;lat=60.2299&amp;lon=11.1663</p> <pre><code>{\n  \"type\": \"FeatureCollection\",\n  \"geocoding\": {\n    \"version\": \"0.1.0\",\n    \"attribution\": \"Data \u00a9 OpenStreetMap contributors, ODbL 1.0. https://osm.org/copyright\",\n    \"licence\": \"ODbL\",\n    \"query\": \"60.229917843587,11.16630979382\"\n  },\n  \"features\": {\n    \"type\": \"Feature\",\n    \"properties\": {\n      \"geocoding\": {\n        \"place_id\": \"42700574\",\n        \"osm_type\": \"node\",\n        \"osm_id\": \"3110596255\",\n        \"type\": \"house\",\n        \"accuracy\": 0,\n        \"label\": \"1, L\u00f8venbergvegen, Mogreina, Ullensaker, Akershus, 2054, Norway\",\n        \"name\": null,\n        \"housenumber\": \"1\",\n        \"street\": \"L\u00f8venbergvegen\",\n        \"postcode\": \"2054\",\n        \"county\": \"Akershus\",\n        \"country\": \"Norway\",\n        \"admin\": {\n          \"level7\": \"Ullensaker\",\n          \"level4\": \"Akershus\",\n          \"level2\": \"Norway\"\n        }\n      }\n    },\n    \"geometry\": {\n      \"type\": \"Point\",\n      \"coordinates\": [\n        11.1658572,\n        60.2301296\n      ]\n    }\n  }\n}\n</code></pre>"},{"location":"api/Search/","title":"Search queries","text":"<p>The search API allows you to look up a location from a textual description or address. Nominatim supports structured and free-form search queries.</p> <p>The search query may also contain special phrases which are translated into specific OpenStreetMap (OSM) tags (e.g. Pub =&gt; <code>amenity=pub</code>). This can be used to narrow down the kind of objects to be returned.</p> <p>Note</p> <p>Special phrases are not suitable to query all objects of a certain type in an area. Nominatim will always just return a collection of the best matches. To download OSM data by object type, use the Overpass API.</p>"},{"location":"api/Search/#endpoint","title":"Endpoint","text":"<p>The search API has the following format:</p> <pre><code>   https://nominatim.openstreetmap.org/search?&lt;params&gt;\n</code></pre> <p>Deprecation warning</p> <p>The API can also be used with the URL <code>https://nominatim.openstreetmap.org/search.php</code>. This is now deprecated and will be removed in future versions.</p> <p>The query term can be given in two different forms: free-form or structured.</p>"},{"location":"api/Search/#free-form-query","title":"Free-form query","text":"Parameter Value q Free-form query string to search for <p>In this form, the query can be unstructured. Free-form queries are processed first left-to-right and then right-to-left if that fails. So you may search for pilkington avenue, birmingham as well as for birmingham, pilkington avenue. Commas are optional, but improve performance by reducing the complexity of the search.</p> <p>The free-form may also contain special phrases to describe the type of place to be returned or a coordinate to search close to a position.</p>"},{"location":"api/Search/#structured-query","title":"Structured query","text":"Parameter Value amenity name and/or type of POI street housenumber and streetname city city county county state state country country postalcode postal code <p>The structured form of the search query allows to lookup up an address that is already split into its components. Each parameter represents a field of the address. All parameters are optional. You should only use the ones that are relevant for the address you want to geocode.</p> <p>Attention</p> <p>Cannot be combined with the <code>q=&lt;query&gt;</code> parameter. Newer versions of the API will return an error if you do so. Older versions simply return unexpected results.</p>"},{"location":"api/Search/#parameters","title":"Parameters","text":"<p>The following parameters can be used to further restrict the search and change the output. They are usable for both forms of the search query.</p>"},{"location":"api/Search/#output-format","title":"Output format","text":"Parameter Value Default format one of: <code>xml</code>, <code>json</code>, <code>jsonv2</code>, <code>geojson</code>, <code>geocodejson</code> <code>jsonv2</code> <p>See Place Output Formats for details on each format.</p> <p>Note</p> <p>The Nominatim service at https://nominatim.openstreetmap.org has a different default behaviour for historical reasons. When the <code>format</code> parameter is omitted, the request will be forwarded to the Web UI.</p> Parameter Value Default json_callback function name unset <p>When given, then JSON output will be wrapped in a callback function with the given name. See JSONP for more information.</p> <p>Only has an effect for JSON output formats.</p> Parameter Value Default limit number 10 <p>Limit the maximum number of returned results. Cannot be more than 40. Nominatim may decide to return less results than given, if additional results do not sufficiently match the query.</p>"},{"location":"api/Search/#output-details","title":"Output details","text":"Parameter Value Default addressdetails 0 or 1 0 <p>When set to 1, include a breakdown of the address into elements. The exact content of the address breakdown depends on the output format.</p> <p>Tip</p> <p>If you are interested in a stable classification of address categories (suburb, city, state, etc), have a look at the <code>geocodejson</code> format. All other formats return classifications according to OSM tagging. There is a much larger set of categories and they are not always consistent, which makes them very hard to work with.</p> Parameter Value Default extratags 0 or 1 0 <p>When set to 1, the response include any additional information in the result that is available in the database, e.g. wikipedia link, opening hours.</p> Parameter Value Default namedetails 0 or 1 0 <p>When set to 1, include a full list of names for the result. These may include language variants, older names, references and brand.</p>"},{"location":"api/Search/#language-of-results","title":"Language of results","text":"Parameter Value Default accept-language browser language string content of \"Accept-Language\" HTTP header <p>Preferred language order for showing search results. This may either be a simple comma-separated list of language codes or have the same format as the \"Accept-Language\" HTTP header.</p> <p>Tip</p> <p>First-time users of Nominatim tend to be confused that they get different results when using Nominatim in the browser versus in a command-line tool like wget or curl. The command-line tools usually don't send any Accept-Language header, prompting Nominatim to show results in the local language. Browsers on the contrary always send the currently chosen browser language.</p>"},{"location":"api/Search/#result-restriction","title":"Result restriction","text":"<p>There are two ways to influence the results. Filters exclude certain kinds of results completely. Boost parameters only change the order of the results and thus give a preference to some results over others.</p> Parameter Value Default countrycodes comma-separated list of country codes unset <p>Filer that limits the search results to one or more countries. The country code must be the ISO 3166-1alpha2 code of the country, e.g. <code>gb</code> for the United Kingdom, <code>de</code> for Germany.</p> <p>Each place in Nominatim is assigned to one country code based on OSM country boundaries. In rare cases a place may not be in any country at all, for example, when it is in international waters. These places are also excluded when the filter is set.</p> <p>Note</p> <p>This parameter should not be confused with the 'country' parameter of the structured query. The 'country' parameter contains a search term and will be handled with some fuzziness. The <code>countrycodes</code> parameter is a hard filter and as such should be preferred. Having both parameters in the same query will work. If the parameters contradict each other, the search will come up empty.</p> Parameter Value Default layer comma-separated list of: <code>address</code>, <code>poi</code>, <code>railway</code>, <code>natural</code>, <code>manmade</code> unset (no restriction) <p><code>[Python-only]</code></p> <p>The layer filter allows to select places by themes.</p> <p>The <code>address</code> layer contains all places that make up an address: address points with house numbers, streets, inhabited places (suburbs, villages, cities, states tec.) and administrative boundaries.</p> <p>The <code>poi</code> layer selects all point of interest. This includes classic POIs like restaurants, shops, hotels but also less obvious features like recycling bins, guideposts or benches.</p> <p>The <code>railway</code> layer includes railway infrastructure like tracks. Note that in Nominatim's standard configuration, only very few railway features are imported into the database.</p> <p>The <code>natural</code> layer collects features like rivers, lakes and mountains while the <code>manmade</code> layer functions as a catch-all for features not covered by the other layers.</p> Parameter Value Default featureType one of: <code>country</code>, <code>state</code>, <code>city</code>, <code>settlement</code> unset <p>The featureType allows to have a more fine-grained selection for places from the address layer. Results can be restricted to places that make up the 'state', 'country' or 'city' part of an address. A featureType of settlement selects any human inhabited feature from 'state' down to 'neighbourhood'.</p> <p>When featureType is set, then results are automatically restricted to the address layer (see above).</p> <p>Tip</p> <p>Instead of using the featureType filters <code>country</code>, <code>state</code> or <code>city</code>, you can also use a structured query without the finer-grained parameters amenity or street.</p> Parameter Value Default exclude_place_ids comma-separated list of place ids <p>If you do not want certain OSM objects to appear in the search result, give a comma separated list of the <code>place_id</code>s you want to skip. This can be used to retrieve additional search results. For example, if a previous query only returned a few results, then including those here would cause the search to return other, less accurate, matches (if possible).</p> Parameter Value Default viewbox <code>&lt;x1&gt;,&lt;y1&gt;,&lt;x2&gt;,&lt;y2&gt;</code> unset <p>Boost parameter which focuses the search on the given area. Any two corner points of the box are accepted as long as they make a proper box. <code>x</code> is longitude, <code>y</code> is latitude.</p> Parameter Value Default bounded 0 or 1 0 <p>When set to 1, then it turns the 'viewbox' parameter (see above) into a filter parameter, excluding any results outside the viewbox.</p> <p>When <code>bounded=1</code> is given and the viewbox is small enough, then an amenity-only search is allowed. Give the special keyword for the amenity in square brackets, e.g. <code>[pub]</code> and a selection of objects of this type is returned. There is no guarantee that the result returns all objects in the area.</p>"},{"location":"api/Search/#polygon-output","title":"Polygon output","text":"Parameter Value Default polygon_geojson 0 or 1 0 polygon_kml 0 or 1 0 polygon_svg 0 or 1 0 polygon_text 0 or 1 0 <p>Add the full geometry of the place to the result output. Output formats in GeoJSON, KML, SVG or WKT are supported. Only one of these options can be used at a time.</p> Parameter Value Default polygon_threshold floating-point number 0.0 <p>When one of the polygon_* outputs is chosen, return a simplified version of the output geometry. The parameter describes the tolerance in degrees with which the geometry may differ from the original geometry. Topology is preserved in the geometry.</p>"},{"location":"api/Search/#other","title":"Other","text":"Parameter Value Default email valid email address unset <p>If you are making large numbers of request please include an appropriate email address to identify your requests. See Nominatim's Usage Policy for more details.</p> Parameter Value Default dedupe 0 or 1 1 <p>Sometimes you have several objects in OSM identifying the same place or object in reality. The simplest case is a street being split into many different OSM ways due to different characteristics. Nominatim will attempt to detect such duplicates and only return one match. Setting this parameter to 0 disables this deduplication mechanism and ensures that all results are returned.</p> Parameter Value Default debug 0 or 1 0 <p>Output assorted developer debug information. Data on internals of Nominatim's \"search loop\" logic, and SQL queries. The output is HTML format. This overrides the specified machine readable format.</p>"},{"location":"api/Search/#examples","title":"Examples","text":""},{"location":"api/Search/#xml-with-kml-polygon","title":"XML with KML polygon","text":"<ul> <li>https://nominatim.openstreetmap.org/search?q=135+pilkington+avenue,+birmingham&amp;format=xml&amp;polygon_kml=1&amp;addressdetails=1</li> </ul> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;\n&lt;searchresults timestamp=\"Tue, 08 Aug 2023 15:45:41 +00:00\"\n               attribution=\"Data \u00a9 OpenStreetMap contributors, ODbL 1.0. http://osm.org/copyright\"\n               querystring=\"135 pilkington avenue, birmingham\"\n               more_url=\"https://nominatim.openstreetmap.org/search?q=135+pilkington+avenue%2C+birmingham&amp;amp;polygon_kml=1&amp;amp;addressdetails=1&amp;amp;limit=20&amp;amp;exclude_place_ids=125279639&amp;amp;format=xml\"\n               exclude_place_ids=\"125279639\"&gt;\n  &lt;place place_id=\"125279639\"\n         osm_type=\"way\"\n         osm_id=\"90394480\"\n         lat=\"52.5487921\"\n         lon=\"-1.8164308\"\n         boundingbox=\"52.5487473,52.5488481,-1.8165130,-1.8163464\"\n         place_rank=\"30\"\n         address_rank=\"30\"\n         display_name=\"135, Pilkington Avenue, Maney, Sutton Coldfield, Wylde Green, Birmingham, West Midlands Combined Authority, England, B72 1LH, United Kingdom\"\n         class=\"building\"\n         type=\"residential\"\n         importance=\"9.999999994736442e-08\"&gt;\n    &lt;geokml&gt;\n      &lt;Polygon&gt;\n        &lt;outerBoundaryIs&gt;\n          &lt;LinearRing&gt;\n            &lt;coordinates&gt;-1.816513,52.5487566 -1.816434,52.5487473 -1.816429,52.5487629 -1.8163717,52.5487561 -1.8163464,52.5488346 -1.8164599,52.5488481 -1.8164685,52.5488213 -1.8164913,52.548824 -1.816513,52.5487566&lt;/coordinates&gt;\n          &lt;/LinearRing&gt;\n        &lt;/outerBoundaryIs&gt;\n      &lt;/Polygon&gt;\n    &lt;/geokml&gt;\n    &lt;house_number&gt;135&lt;/house_number&gt;\n    &lt;road&gt;Pilkington Avenue&lt;/road&gt;\n    &lt;hamlet&gt;Maney&lt;/hamlet&gt;\n    &lt;town&gt;Sutton Coldfield&lt;/town&gt;\n    &lt;village&gt;Wylde Green&lt;/village&gt;\n    &lt;city&gt;Birmingham&lt;/city&gt;\n    &lt;ISO3166-2-lvl8&gt;GB-BIR&lt;/ISO3166-2-lvl8&gt;\n    &lt;state_district&gt;West Midlands Combined Authority&lt;/state_district&gt;\n    &lt;state&gt;England&lt;/state&gt;\n    &lt;ISO3166-2-lvl4&gt;GB-ENG&lt;/ISO3166-2-lvl4&gt;\n    &lt;postcode&gt;B72 1LH&lt;/postcode&gt;\n    &lt;country&gt;United Kingdom&lt;/country&gt;\n    &lt;country_code&gt;gb&lt;/country_code&gt;\n  &lt;/place&gt;\n&lt;/searchresults&gt;\n</code></pre>"},{"location":"api/Search/#json-with-svg-polygon","title":"JSON with SVG polygon","text":"<p>https://nominatim.openstreetmap.org/search?q=Unter%20den%20Linden%201%20Berlin&amp;format=json&amp;addressdetails=1&amp;limit=1&amp;polygon_svg=1</p> <pre><code>[\n  {\n    \"address\": {\n      \"ISO3166-2-lvl4\": \"DE-BE\",\n      \"borough\": \"Mitte\",\n      \"city\": \"Berlin\",\n      \"country\": \"Deutschland\",\n      \"country_code\": \"de\",\n      \"historic\": \"Kommandantenhaus\",\n      \"house_number\": \"1\",\n      \"neighbourhood\": \"Friedrichswerder\",\n      \"postcode\": \"10117\",\n      \"road\": \"Unter den Linden\",\n      \"suburb\": \"Mitte\"\n    },\n    \"boundingbox\": [\n      \"52.5170798\",\n      \"52.5173311\",\n      \"13.3975116\",\n      \"13.3981577\"\n    ],\n    \"class\": \"historic\",\n    \"display_name\": \"Kommandantenhaus, 1, Unter den Linden, Friedrichswerder, Mitte, Berlin, 10117, Deutschland\",\n    \"importance\": 0.8135042058306902,\n    \"lat\": \"52.51720765\",\n    \"licence\": \"Data \u00a9 OpenStreetMap contributors, ODbL 1.0. https://osm.org/copyright\",\n    \"lon\": \"13.397834399325466\",\n    \"osm_id\": 15976890,\n    \"osm_type\": \"way\",\n    \"place_id\": 108681845,\n    \"svg\": \"M 13.3975116 -52.5172905 L 13.397549 -52.5170798 13.397715 -52.5170906 13.3977122 -52.5171064 13.3977392 -52.5171086 13.3977417 -52.5170924 13.3979655 -52.5171069 13.3979623 -52.5171233 13.3979893 -52.5171248 13.3979922 -52.5171093 13.3981577 -52.5171203 13.398121 -52.5173311 13.3978115 -52.5173103 Z\",\n    \"type\": \"house\"\n  }\n]\n</code></pre>"},{"location":"api/Search/#json-with-address-details","title":"JSON with address details","text":"<p>https://nominatim.openstreetmap.org/search?addressdetails=1&amp;q=bakery+in+berlin+wedding&amp;format=jsonv2&amp;limit=1</p> <pre><code>[\n  {\n    \"address\": {\n      \"ISO3166-2-lvl4\": \"DE-BE\",\n      \"borough\": \"Mitte\",\n      \"city\": \"Berlin\",\n      \"country\": \"Deutschland\",\n      \"country_code\": \"de\",\n      \"neighbourhood\": \"Sprengelkiez\",\n      \"postcode\": \"13347\",\n      \"road\": \"Lindower Stra\u00dfe\",\n      \"shop\": \"Ditsch\",\n      \"suburb\": \"Wedding\"\n    },\n    \"addresstype\": \"shop\",\n    \"boundingbox\": [\n      \"52.5427201\",\n      \"52.5427654\",\n      \"13.3668619\",\n      \"13.3669442\"\n    ],\n    \"category\": \"shop\",\n    \"display_name\": \"Ditsch, Lindower Stra\u00dfe, Sprengelkiez, Wedding, Mitte, Berlin, 13347, Deutschland\",\n    \"importance\": 9.99999999995449e-06,\n    \"lat\": \"52.54274275\",\n    \"licence\": \"Data \u00a9 OpenStreetMap contributors, ODbL 1.0. http://osm.org/copyright\",\n    \"lon\": \"13.36690305710228\",\n    \"name\": \"Ditsch\",\n    \"osm_id\": 437595031,\n    \"osm_type\": \"way\",\n    \"place_id\": 204751033,\n    \"place_rank\": 30,\n    \"type\": \"bakery\"\n  }\n]\n</code></pre>"},{"location":"api/Search/#geojson","title":"GeoJSON","text":"<p>https://nominatim.openstreetmap.org/search?q=17+Strada+Pictor+Alexandru+Romano%2C+Bukarest&amp;format=geojson</p> <pre><code>{\n  \"type\": \"FeatureCollection\",\n  \"licence\": \"Data \u00a9 OpenStreetMap contributors, ODbL 1.0. https://osm.org/copyright\",\n  \"features\": [\n    {\n      \"type\": \"Feature\",\n      \"properties\": {\n        \"place_id\": \"35811445\",\n        \"osm_type\": \"node\",\n        \"osm_id\": \"2846295644\",\n        \"display_name\": \"17, Strada Pictor Alexandru Romano, Bukarest, Bucharest, Sector 2, Bucharest, 023964, Romania\",\n        \"place_rank\": \"30\",\n        \"category\": \"place\",\n        \"type\": \"house\",\n        \"importance\": 0.62025\n      },\n      \"bbox\": [\n        26.1156689,\n        44.4354754,\n        26.1157689,\n        44.4355754\n      ],\n      \"geometry\": {\n        \"type\": \"Point\",\n        \"coordinates\": [\n          26.1157189,\n          44.4355254\n        ]\n      }\n    }\n  ]\n}\n</code></pre>"},{"location":"api/Search/#geocodejson","title":"GeocodeJSON","text":"<p>https://nominatim.openstreetmap.org/search?q=%CE%91%CE%B3%CE%AF%CE%B1+%CE%A4%CF%81%CE%B9%CE%AC%CE%B4%CE%B1%2C+%CE%91%CE%B4%CF%89%CE%BD%CE%B9%CE%B4%CE%BF%CF%82%2C+Athens%2C+Greece&amp;format=geocodejson</p> <pre><code>{\n  \"type\": \"FeatureCollection\",\n  \"geocoding\": {\n    \"version\": \"0.1.0\",\n    \"attribution\": \"Data \u00a9 OpenStreetMap contributors, ODbL 1.0. https://osm.org/copyright\",\n    \"licence\": \"ODbL\",\n    \"query\": \"\u0391\u03b3\u03af\u03b1 \u03a4\u03c1\u03b9\u03ac\u03b4\u03b1, \u0391\u03b4\u03c9\u03bd\u03b9\u03b4\u03bf\u03c2, Athens, Greece\"\n  },\n  \"features\": [\n    {\n      \"type\": \"Feature\",\n      \"properties\": {\n        \"geocoding\": {\n          \"type\": \"place_of_worship\",\n          \"label\": \"\u0391\u03b3\u03af\u03b1 \u03a4\u03c1\u03b9\u03ac\u03b4\u03b1, \u0391\u03b4\u03c9\u03bd\u03b9\u03b4\u03bf\u03c2, \u0386\u03b3\u03b9\u03bf\u03c2 \u039d\u03b9\u03ba\u03cc\u03bb\u03b1\u03bf\u03c2, 5\u00ba \u0394\u03b7\u03bc\u03bf\u03c4\u03b9\u03ba\u03cc \u0394\u03b9\u03b1\u03bc\u03ad\u03c1\u03b9\u03c3\u03bc\u03b1 \u0391\u03b8\u03b7\u03bd\u03ce\u03bd, Athens, Municipality of Athens, Regional Unit of Central Athens, Region of Attica, Attica, 11472, Greece\",\n          \"name\": \"\u0391\u03b3\u03af\u03b1 \u03a4\u03c1\u03b9\u03ac\u03b4\u03b1\",\n          \"admin\": null\n        }\n      },\n      \"geometry\": {\n        \"type\": \"Point\",\n        \"coordinates\": [\n          23.72949633941,\n          38.0051697\n        ]\n      }\n    }\n  ]\n}\n</code></pre>"},{"location":"api/Status/","title":"Status","text":"<p>Report on the state of the service and database. Useful for checking if the service is up and running. The JSON output also reports when the database was last updated.</p>"},{"location":"api/Status/#endpoint","title":"Endpoint","text":"<p>The status API has the following format:</p> <pre><code>https://nominatim.openstreetmap.org/status\n</code></pre> <p>Deprecation warning</p> <p>The API can also be used with the URL <code>https://nominatim.openstreetmap.org/status.php</code>. This is now deprecated and will be removed in future versions.</p>"},{"location":"api/Status/#parameters","title":"Parameters","text":"<p>The status endpoint takes a single optional parameter:</p> Parameter Value Default format one of: <code>text</code>, <code>json</code> 'text' <p>Selects the output format. See below.</p>"},{"location":"api/Status/#output","title":"Output","text":""},{"location":"api/Status/#text-format","title":"Text format","text":"<p>When everything is okay, a status code 200 is returned and a simple message: <code>OK</code></p> <p>On error it will return HTTP status code 500 and print a detailed error message, e.g. <code>ERROR: Database connection failed</code>.</p>"},{"location":"api/Status/#json-format","title":"JSON format","text":"<p>Always returns a HTTP code 200, when the status call could be executed.</p> <p>On success a JSON dictionary with the following structure is returned:</p> <pre><code>  {\n      \"status\": 0,\n      \"message\": \"OK\",\n      \"data_updated\": \"2020-05-04T14:47:00+00:00\",\n      \"software_version\": \"3.6.0-0\",\n      \"database_version\": \"3.6.0-0\"\n  }\n</code></pre> <p>The <code>software_version</code> field contains the version of Nominatim used to serve the API. The <code>database_version</code> field contains the version of the data format in the database.</p> <p>On error will return a shorter JSON dictionary with the error message and status only, e.g.</p> <pre><code>   {\n       \"status\": 700,\n       \"message\": \"Database connection failed\"\n   }\n</code></pre>"},{"location":"appendix/Install-on-Ubuntu-20/","title":"Installation on Ubuntu 20","text":"<p>Note: these installation instructions are also available in executable         form for use with vagrant under vagrant/Install-on-Ubuntu-20.sh.</p>"},{"location":"appendix/Install-on-Ubuntu-20/#installing-the-required-software","title":"Installing the Required Software","text":"<p>These instructions expect that you have a freshly installed Ubuntu 20.04.</p> <p>Make sure all packages are up-to-date by running:</p> <pre><code>sudo apt-get update -qq\n</code></pre> <p>Now you can install all packages needed for Nominatim:</p> <pre><code>sudo apt-get install -y build-essential cmake g++ libboost-dev libboost-system-dev \\\n                    libboost-filesystem-dev libexpat1-dev zlib1g-dev \\\n                    libbz2-dev libpq-dev liblua5.3-dev lua5.3 lua-dkjson \\\n                    nlohmann-json3-dev postgresql-12-postgis-3 \\\n                    postgresql-contrib-12 postgresql-12-postgis-3-scripts \\\n                    libicu-dev python3-dotenv \\\n                    python3-psycopg2 python3-psutil python3-jinja2 python3-pip \\\n                    python3-icu python3-datrie python3-yaml\n</code></pre> <p>Some of the Python packages that come with Ubuntu 20.04 are too old, so install the latest version from pip:</p> <pre><code>pip3 install --user sqlalchemy asyncpg\n</code></pre>"},{"location":"appendix/Install-on-Ubuntu-20/#system-configuration","title":"System Configuration","text":"<p>The following steps are meant to configure a fresh Ubuntu installation for use with Nominatim. You may skip some of the steps if you have your OS already configured.</p>"},{"location":"appendix/Install-on-Ubuntu-20/#creating-dedicated-user-accounts","title":"Creating Dedicated User Accounts","text":"<p>Nominatim will run as a global service on your machine. It is therefore best to install it under its own separate user account. In the following we assume this user is called nominatim and the installation will be in /srv/nominatim. To create the user and directory run:</p> <pre><code>sudo useradd -d /srv/nominatim -s /bin/bash -m nominatim\n</code></pre> <p>You may find a more suitable location if you wish.</p> <p>The following instructions assume you are logged in as this user. You can also switch to the user with:</p> <pre><code>sudo -u nominatim bash\n</code></pre> <p>To be able to copy and paste instructions from this manual, export user name and home directory now like this:</p> <pre><code>export USERNAME=nominatim\nexport USERHOME=/srv/nominatim\n</code></pre> <p>Never, ever run the installation as a root user. You have been warned.</p> <p>Make sure that system servers can read from the home directory:</p> <pre><code>chmod a+x $USERHOME\n</code></pre>"},{"location":"appendix/Install-on-Ubuntu-20/#setting-up-postgresql","title":"Setting up PostgreSQL","text":"<p>Tune the postgresql configuration, which is located in  <code>/etc/postgresql/12/main/postgresql.conf</code>. See section Tuning the PostgreSQL database in the installation page for the parameters to change.</p> <p>Restart the postgresql service after updating this config file.</p> <pre><code>sudo systemctl restart postgresql\n</code></pre> <p>Finally, we need to add two postgres users: one for the user that does the import and another for the webserver which should access the database for reading only:</p> <pre><code>sudo -u postgres createuser -s $USERNAME\nsudo -u postgres createuser www-data\n</code></pre>"},{"location":"appendix/Install-on-Ubuntu-20/#installing-nominatim","title":"Installing Nominatim","text":""},{"location":"appendix/Install-on-Ubuntu-20/#building-and-configuration","title":"Building and Configuration","text":"<p>Get the source code from Github and change into the source directory</p> <pre><code>cd $USERHOME\nwget https://nominatim.org/release/Nominatim-4.4.1.tar.bz2\ntar xf Nominatim-4.4.1.tar.bz2\n</code></pre> <p>The code must be built in a separate directory. Create this directory, then configure and build Nominatim in there:</p> <pre><code>mkdir $USERHOME/build\ncd $USERHOME/build\ncmake $USERHOME/Nominatim-4.4.1\nmake\nsudo make install\n</code></pre> <p>Nominatim is now ready to use. You can continue with importing a database from OSM data. If you want to set up the API frontend first, continue reading.</p>"},{"location":"appendix/Install-on-Ubuntu-20/#setting-up-the-python-frontend","title":"Setting up the Python frontend","text":"<p>Some of the Python packages in Ubuntu are too old. Therefore run the frontend from a Python virtualenv with current packages.</p> <p>To set up the virtualenv, run:</p> <pre><code>sudo apt-get install -y virtualenv\nvirtualenv $USERHOME/nominatim-venv\n$USERHOME/nominatim-venv/bin/pip install SQLAlchemy PyICU psycopg[binary] \\\n              psycopg2-binary python-dotenv PyYAML falcon uvicorn gunicorn\n</code></pre> <p>Next you need to create a systemd job that runs Nominatim on gunicorn. First create a systemd job that manages the socket file:</p> <pre><code>sudo tee /etc/systemd/system/nominatim.socket &lt;&lt; EOFSOCKETSYSTEMD\n[Unit]\nDescription=Gunicorn socket for Nominatim\n\n[Socket]\nListenStream=/run/nominatim.sock\nSocketUser=www-data\n\n[Install]\nWantedBy=multi-user.target\nEOFSOCKETSYSTEMD\n</code></pre> <p>Then create the service for Nominatim itself.</p> <pre><code>sudo tee /etc/systemd/system/nominatim.service &lt;&lt; EOFNOMINATIMSYSTEMD\n[Unit]\nDescription=Nominatim running as a gunicorn application\nAfter=network.target\nRequires=nominatim.socket\n\n[Service]\nType=simple\nEnvironment=\"PYTHONPATH=/usr/local/lib/nominatim/lib-python/\"\nUser=www-data\nGroup=www-data\nWorkingDirectory=$USERHOME/nominatim-project\nExecStart=$USERHOME/nominatim-venv/bin/gunicorn -b unix:/run/nominatim.sock -w 4 -k uvicorn.workers.UvicornWorker nominatim.server.falcon.server:run_wsgi\nExecReload=/bin/kill -s HUP \\$MAINPID\nStandardOutput=append:/var/log/gunicorn-nominatim.log\nStandardError=inherit\nPrivateTmp=true\nTimeoutStopSec=5\nKillMode=mixed\n\n[Install]\nWantedBy=multi-user.target\nEOFNOMINATIMSYSTEMD\n</code></pre> <p>Activate the services:</p> <pre><code>sudo systemctl daemon-reload\nsudo systemctl enable nominatim.socket\nsudo systemctl start nominatim.socket\nsudo systemctl enable nominatim.service\n</code></pre>"},{"location":"appendix/Install-on-Ubuntu-20/#setting-up-a-webserver","title":"Setting up a webserver","text":"<p>The webserver is only needed as a proxy between the public interface and the gunicorn service.</p> <p>The frontend will need configuration information from the project directory, which will be populated later during the import process Already create the project directory itself now:</p> <pre><code>mkdir $USERHOME/nominatim-project\n</code></pre>"},{"location":"appendix/Install-on-Ubuntu-20/#option-1-using-apache","title":"Option 1: Using Apache","text":"<p>First install apache itself and enable the proxy module:</p> <pre><code>sudo apt-get install -y apache2\nsudo a2enmod proxy_http\n</code></pre> <p>To set up proxying for Apache add the following configuration:</p> <pre><code>sudo tee /etc/apache2/conf-available/nominatim.conf &lt;&lt; EOFAPACHECONF\nProxyPass /nominatim \"unix:/run/nominatim.sock|http://localhost/\"\nEOFAPACHECONF\n</code></pre> <p>Then enable the configuration and restart apache</p> <pre><code>sudo a2enconf nominatim\n\n\n\nsudo systemctl restart apache2\n</code></pre> <p>The Nominatim API is now available at <code>http://localhost/nominatim/</code>.</p>"},{"location":"appendix/Install-on-Ubuntu-20/#option-2-using-nginx","title":"Option 2: Using nginx","text":"<p>First install nginx itself:</p> <pre><code>sudo apt-get install -y nginx\n</code></pre> <p>Then create a Nginx configuration to forward http requests to that socket.</p> <pre><code>sudo tee /etc/nginx/sites-available/default &lt;&lt; EOF_NGINX_CONF\nserver {\n    listen 80 default_server;\n    listen [::]:80 default_server;\n\n    root $USERHOME/nominatim-project/website;\n    index /search;\n\n    location /nominatim/ {\n            proxy_set_header Host \\$http_host;\n            proxy_set_header X-Forwarded-For \\$proxy_add_x_forwarded_for;\n            proxy_set_header X-Forwarded-Proto \\$scheme;\n            proxy_redirect off;\n            proxy_pass http://unix:/run/nominatim.sock:/;\n    }\n}\nEOF_NGINX_CONF\n</code></pre> <p>Enable the configuration and restart Nginx</p> <pre><code>sudo systemctl restart nginx\n</code></pre> <p>The Nominatim API is now available at <code>http://localhost/</code>.</p>"},{"location":"appendix/Install-on-Ubuntu-22/","title":"Installation on Ubuntu 22","text":"<p>Note: these installation instructions are also available in executable         form for use with vagrant under vagrant/Install-on-Ubuntu-22.sh.</p>"},{"location":"appendix/Install-on-Ubuntu-22/#installing-the-required-software","title":"Installing the Required Software","text":"<p>These instructions expect that you have a freshly installed Ubuntu 22.04.</p> <p>Make sure all packages are up-to-date by running:</p> <pre><code>sudo apt-get update -qq\n</code></pre> <p>Now you can install all packages needed for Nominatim:</p> <pre><code>sudo apt-get install -y build-essential cmake g++ libboost-dev libboost-system-dev \\\n                    libboost-filesystem-dev libexpat1-dev zlib1g-dev \\\n                    libbz2-dev libpq-dev liblua5.3-dev lua5.3 lua-dkjson \\\n                    nlohmann-json3-dev postgresql-14-postgis-3 \\\n                    postgresql-contrib-14 postgresql-14-postgis-3-scripts \\\n                    libicu-dev python3-dotenv \\\n                    python3-psycopg2 python3-psutil python3-jinja2 \\\n                    python3-sqlalchemy python3-asyncpg \\\n                    python3-icu python3-datrie python3-yaml\n</code></pre>"},{"location":"appendix/Install-on-Ubuntu-22/#system-configuration","title":"System Configuration","text":"<p>The following steps are meant to configure a fresh Ubuntu installation for use with Nominatim. You may skip some of the steps if you have your OS already configured.</p>"},{"location":"appendix/Install-on-Ubuntu-22/#creating-dedicated-user-accounts","title":"Creating Dedicated User Accounts","text":"<p>Nominatim will run as a global service on your machine. It is therefore best to install it under its own separate user account. In the following we assume this user is called nominatim and the installation will be in /srv/nominatim. To create the user and directory run:</p> <pre><code>sudo useradd -d /srv/nominatim -s /bin/bash -m nominatim\n</code></pre> <p>You may find a more suitable location if you wish.</p> <p>The following instructions assume you are logged in as this user. You can also switch to the user with:</p> <pre><code>sudo -u nominatim bash\n</code></pre> <p>To be able to copy and paste instructions from this manual, export user name and home directory now like this:</p> <pre><code>export USERNAME=nominatim\nexport USERHOME=/srv/nominatim\n</code></pre> <p>Never, ever run the installation as a root user. You have been warned.</p> <p>Make sure that system servers can read from the home directory:</p> <pre><code>chmod a+x $USERHOME\n</code></pre>"},{"location":"appendix/Install-on-Ubuntu-22/#setting-up-postgresql","title":"Setting up PostgreSQL","text":"<p>Tune the postgresql configuration, which is located in  <code>/etc/postgresql/14/main/postgresql.conf</code>. See section Tuning the PostgreSQL database in the installation page for the parameters to change.</p> <p>Restart the postgresql service after updating this config file.</p> <pre><code>sudo systemctl restart postgresql\n</code></pre> <p>Finally, we need to add two postgres users: one for the user that does the import and another for the webserver which should access the database for reading only:</p> <pre><code>sudo -u postgres createuser -s $USERNAME\nsudo -u postgres createuser www-data\n</code></pre>"},{"location":"appendix/Install-on-Ubuntu-22/#installing-nominatim","title":"Installing Nominatim","text":""},{"location":"appendix/Install-on-Ubuntu-22/#building-and-configuration","title":"Building and Configuration","text":"<p>Get the source code from Github and change into the source directory</p> <pre><code>cd $USERHOME\nwget https://nominatim.org/release/Nominatim-4.4.1.tar.bz2\ntar xf Nominatim-4.4.1.tar.bz2\n</code></pre> <p>When installing the latest source from github, you also need to download the country grid:</p> <pre><code>wget -O data/country_osm_grid.sql.gz https://nominatim.org/data/country_grid.sql.gz\n</code></pre> <p>The code must be built in a separate directory. Create this directory, then configure and build Nominatim in there:</p> <pre><code>mkdir $USERHOME/build\ncd $USERHOME/build\ncmake $USERHOME/Nominatim-4.4.1\nmake\nsudo make install\n</code></pre> <p>Nominatim is now ready to use. You can continue with importing a database from OSM data. If you want to set up the API frontend first, continue reading.</p>"},{"location":"appendix/Install-on-Ubuntu-22/#setting-up-the-python-frontend","title":"Setting up the Python frontend","text":"<p>Some of the Python packages in Ubuntu are too old. Therefore run the frontend from a Python virtualenv with current packages.</p> <p>To set up the virtualenv, run:</p> <pre><code>sudo apt-get install -y virtualenv\nvirtualenv $USERHOME/nominatim-venv\n$USERHOME/nominatim-venv/bin/pip install SQLAlchemy PyICU psycopg[binary] \\\n              psycopg2-binary python-dotenv PyYAML falcon uvicorn gunicorn\n</code></pre> <p>Next you need to create a systemd job that runs Nominatim on gunicorn. First create a systemd job that manages the socket file:</p> <pre><code>sudo tee /etc/systemd/system/nominatim.socket &lt;&lt; EOFSOCKETSYSTEMD\n[Unit]\nDescription=Gunicorn socket for Nominatim\n\n[Socket]\nListenStream=/run/nominatim.sock\nSocketUser=www-data\n\n[Install]\nWantedBy=multi-user.target\nEOFSOCKETSYSTEMD\n</code></pre> <p>Then create the service for Nominatim itself.</p> <pre><code>sudo tee /etc/systemd/system/nominatim.service &lt;&lt; EOFNOMINATIMSYSTEMD\n[Unit]\nDescription=Nominatim running as a gunicorn application\nAfter=network.target\nRequires=nominatim.socket\n\n[Service]\nType=simple\nEnvironment=\"PYTHONPATH=/usr/local/lib/nominatim/lib-python/\"\nUser=www-data\nGroup=www-data\nWorkingDirectory=$USERHOME/nominatim-project\nExecStart=$USERHOME/nominatim-venv/bin/gunicorn -b unix:/run/nominatim.sock -w 4 -k uvicorn.workers.UvicornWorker nominatim.server.falcon.server:run_wsgi\nExecReload=/bin/kill -s HUP \\$MAINPID\nStandardOutput=append:/var/log/gunicorn-nominatim.log\nStandardError=inherit\nPrivateTmp=true\nTimeoutStopSec=5\nKillMode=mixed\n\n[Install]\nWantedBy=multi-user.target\nEOFNOMINATIMSYSTEMD\n</code></pre> <p>Activate the services:</p> <pre><code>sudo systemctl daemon-reload\nsudo systemctl enable nominatim.socket\nsudo systemctl start nominatim.socket\nsudo systemctl enable nominatim.service\n</code></pre>"},{"location":"appendix/Install-on-Ubuntu-22/#setting-up-a-webserver","title":"Setting up a webserver","text":"<p>The webserver is only needed as a proxy between the public interface and the gunicorn service.</p> <p>The frontend will need configuration information from the project directory, which will be populated later during the import process Already create the project directory itself now:</p> <pre><code>mkdir $USERHOME/nominatim-project\n</code></pre>"},{"location":"appendix/Install-on-Ubuntu-22/#option-1-using-apache","title":"Option 1: Using Apache","text":"<p>First install apache itself and enable the proxy module:</p> <pre><code>sudo apt-get install -y apache2\nsudo a2enmod proxy_http\n</code></pre> <p>To set up proxying for Apache add the following configuration:</p> <pre><code>sudo tee /etc/apache2/conf-available/nominatim.conf &lt;&lt; EOFAPACHECONF\n\nProxyPass /nominatim \"unix:/run/nominatim.sock|http://localhost/\"\nEOFAPACHECONF\n</code></pre> <p>Then enable the configuration and restart apache</p> <pre><code>sudo a2enconf nominatim\n</code></pre> <pre><code>sudo systemctl restart apache2\n</code></pre> <p>The Nominatim API is now available at <code>http://localhost/nominatim/</code>.</p>"},{"location":"appendix/Install-on-Ubuntu-22/#option-2-using-nginx","title":"Option 2: Using nginx","text":"<p>First install nginx itself:</p> <pre><code>sudo apt-get install -y nginx\n</code></pre> <p>Then create a Nginx configuration to forward http requests to that socket.</p> <pre><code>sudo tee /etc/nginx/sites-available/default &lt;&lt; EOF_NGINX_CONF\nserver {\n    listen 80 default_server;\n    listen [::]:80 default_server;\n\n    root $USERHOME/nominatim-project/website;\n    index /search;\n\n    location /nominatim/ {\n            proxy_set_header Host \\$http_host;\n            proxy_set_header X-Forwarded-For \\$proxy_add_x_forwarded_for;\n            proxy_set_header X-Forwarded-Proto \\$scheme;\n            proxy_redirect off;\n            proxy_pass http://unix:/run/nominatim.sock:/;\n    }\n}\nEOF_NGINX_CONF\n</code></pre> <p>Enable the configuration and restart Nginx</p> <pre><code>sudo systemctl restart nginx\n</code></pre> <p>The Nominatim API is now available at <code>http://localhost/nominatim/</code>.</p>"},{"location":"customize/Country-Settings/","title":"Customizing Per-Country Data","text":"<p>Whenever an OSM is imported into Nominatim, the object is first assigned a country. Nominatim can use this information to adapt various aspects of the address computation to the local customs of the country. This section explains how country assignment works and the principal per-country localizations.</p>"},{"location":"customize/Country-Settings/#country-assignment","title":"Country assignment","text":"<p>Countries are assigned on the basis of country data from the OpenStreetMap input data itself. Countries are expected to be tagged according to the administrative boundary schema: a OSM relation with <code>boundary=administrative</code> and <code>admin_level=2</code>. Nominatim uses the country code to distinguish the countries.</p> <p>If there is no country data available for a point, then Nominatim uses the fallback data imported from <code>data/country_osm_grid.sql.gz</code>. This was computed from OSM data as well but is guaranteed to cover all countries.</p> <p>Some OSM objects may also be located outside any country, for example a buoy in the middle of the ocean. These object do not get any country assigned and get a default treatment when it comes to localized handling of data.</p>"},{"location":"customize/Country-Settings/#per-country-settings","title":"Per-country settings","text":""},{"location":"customize/Country-Settings/#global-country-settings","title":"Global country settings","text":"<p>The main place to configure settings per country is the file <code>settings/country_settings.yaml</code>. This file has one section per country that is recognised by Nominatim. Each section is tagged with the country code (in lower case) and contains the different localization information. Only countries which are listed in this file are taken into account for computations.</p> <p>For example, the section for Andorra looks like this:</p> <pre><code>    partition: 35\n    languages: ca\n    names: !include country-names/ad.yaml\n    postcode:\n      pattern: \"(ddd)\"\n      output: AD\\1\n</code></pre> <p>The individual settings are described below.</p>"},{"location":"customize/Country-Settings/#partition","title":"<code>partition</code>","text":"<p>Nominatim internally splits the data into multiple tables to improve performance. The partition number tells Nominatim into which table to put the country. This is purely internal management and has no effect on the output data.</p> <p>The default is to have one partition per country.</p>"},{"location":"customize/Country-Settings/#languages","title":"<code>languages</code>","text":"<p>A comma-separated list of ISO-639 language codes of default languages in the country. These are the languages used in name tags without a language suffix. Note that this is not necessarily the same as the list of official languages in the country. There may be officially recognised languages in a country which are only ever used in name tags with the appropriate language suffixes. Conversely, a non-official language may appear a lot in the name tags, for example when used as an unofficial Lingua Franca.</p> <p>List the languages in order of frequency of appearance with the most frequently used language first. It is not recommended to add languages when there are only very few occurrences.</p> <p>If only one language is listed, then Nominatim will 'auto-complete' the language of names without an explicit language-suffix.</p>"},{"location":"customize/Country-Settings/#names","title":"<code>names</code>","text":"<p>List of names of the country and its translations. These names are used as a baseline. It is always possible to search countries by the given names, no matter what other names are in the OSM data. They are also used as a fallback when a needed translation is not available.</p> <p>Note</p> <p>The list of names per country is currently fairly large because Nominatim supports translations in many languages per default. That is why the name lists have been separated out into extra files. You can find the name lists in the file <code>settings/country-names/&lt;country code&gt;.yaml</code>. The names section in the main country settings file only refers to these files via the special <code>!include</code> directive.</p>"},{"location":"customize/Country-Settings/#postcode","title":"<code>postcode</code>","text":"<p>Describes the format of the postcode that is in use in the country.</p> <p>When a country has no official postcodes, set this to no. Example:</p> <pre><code>ae:\n    postcode: no\n</code></pre> <p>When a country has a postcode, you need to state the postcode pattern and the default output format. Example:</p> <pre><code>bm:\n    postcode:\n      pattern: \"(ll)[ -]?(dd)\"\n      output: \\1 \\2\n</code></pre> <p>The pattern is a regular expression that describes the possible formats accepted as a postcode. The pattern follows the standard syntax for regular expressions in Python with two extra shortcuts: <code>d</code> is a shortcut for a single digit([0-9]) and <code>l</code> for a single ASCII letter ([A-Z]).</p> <p>Use match groups to indicate groups in the postcode that may optionally be separated with a space or a hyphen.</p> <p>For example, the postcode for Bermuda above always consists of two letters and two digits. They may optionally be separated by a space or hyphen. That means that Nominatim will consider <code>AB56</code>, <code>AB 56</code> and <code>AB-56</code> spelling variants for one and the same postcode.</p> <p>Never add the country code in front of the postcode pattern. Nominatim will automatically accept variants with a country code prefix for all postcodes.</p> <p>The output field is an optional field that describes what the canonical spelling of the postcode should be. The format is the regular expression expand syntax referring back to the bracket groups in the pattern.</p> <p>Most simple postcodes only have one spelling variant. In that case, the output can be omitted. The postcode will simply be used as is.</p> <p>In the Bermuda example above, the canonical spelling would be to have a space between letters and digits.</p> <p>Warning</p> <p>When your postcode pattern covers multiple variants of the postcode, then you must explicitly state the canonical output or Nominatim will not handle the variations correctly.</p>"},{"location":"customize/Country-Settings/#other-country-specific-configuration","title":"Other country-specific configuration","text":"<p>There are some other configuration files where you can set localized settings according to the assigned country. These are:</p> <ul> <li>Place ranking configuration</li> </ul> <p>Please see the linked documentation sections for more information.</p>"},{"location":"customize/Import-Styles/","title":"Import Styles","text":""},{"location":"customize/Import-Styles/#configuring-the-import","title":"Configuring the Import","text":"<p>In the very first step of a Nominatim import, OSM data is loaded into the database. Nominatim uses osm2pgsql for this task. It comes with a flex style specifically tailored to filter and convert OSM data into Nominatim's internal data representation.</p> <p>There are a number of default configurations for the flex style which result in geocoding databases of different detail. The Import section explains these default configurations in detail.</p> <p>You can also create your own custom style. Put the style file into your project directory and then set <code>NOMINATIM_IMPORT_STYLE</code> to the name of the file. It is always recommended to start with one of the standard styles and customize those. You find the standard styles under the name <code>import-&lt;stylename&gt;.lua</code> in the standard Nominatim configuration path (usually <code>/etc/nominatim</code> or <code>/usr/local/etc/nominatim</code>).</p> <p>The remainder of the page describes how the flex style works and how to customize it.</p>"},{"location":"customize/Import-Styles/#the-flex-baselua-module","title":"The <code>flex-base.lua</code> module","text":"<p>The core of Nominatim's flex import configuration is the <code>flex-base</code> module. It defines the table layout used by Nominatim and provides standard implementations for the import callbacks that make it easy to customize how OSM tags are used by Nominatim.</p> <p>Every custom style should include this module to make sure that the correct tables are created. Thus start your custom style as follows:</p> <pre><code>local flex = require('flex-base')\n</code></pre> <p>The following sections explain how the module can be customized.</p>"},{"location":"customize/Import-Styles/#changing-the-recognized-tags","title":"Changing the recognized tags","text":"<p>If you just want to change which OSM tags are recognized during import, then there are a number of convenience functions to set the tag lists used during the processing.</p> <p>Warning</p> <p>There are no built-in defaults for the tag lists, so all the functions need to be called from your style script to fully process the data. Make sure you start from one of the default style and only modify the data you are interested in. You can also derive your style from an existing style by importing the appropriate module, e.g. <code>local flex = require('import-street')</code>.</p> <p>Many of the following functions take key match lists. These lists can contain three kinds of strings to match against tag keys: A string that ends in an asterisk <code>*</code> is a prefix match and accordingly matches against any key that starts with the given string (minus the <code>*</code>).  A suffix match can be defined similarly with a string that starts with a <code>*</code>. Any other string is matched exactly against tag keys.</p>"},{"location":"customize/Import-Styles/#set_main_tags-principal-tags","title":"<code>set_main_tags()</code> - principal tags","text":"<p>If a principal or main tag is found on an OSM object, then the object is included in Nominatim's search index. A single object may also have multiple main tags. In that case, the object will be included multiple times in the index, once for each main tag.</p> <p>The flex script distinguishes between four types of main tags:</p> <ul> <li>always: a main tag that is used unconditionally</li> <li>named: consider this main tag only, if the object has a proper name   (a reference is not enough, see below).</li> <li>named_with_key: consider this main tag only, when the object has   a proper name with a domain prefix. For example, if the main tag is   <code>bridge=yes</code>, then it will only be added as an extra row, if there is   a tag <code>bridge:name[:XXX]</code> for the same object. If this property is set,   all other names that are not domain-specific are ignored.</li> <li>fallback: use this main tag only, if there is no other main tag.   Fallback always implied <code>named</code>, i.e. fallbacks are only tried for   named objects.</li> </ul> <p>The <code>set_main_tags()</code> function takes exactly one table parameter which defines the keys and key/value combinations to include and the kind of main tag. Each lua table key defines an OSM tag key. The value may be a string defining the kind of main key as described above. Then the tag will be considered a main tag for any possible value. To further restrict which values are acceptable, give a table with the permitted values and their kind of main tag. If the table contains a simple value without key, then this is used as default for values that are not listed.</p> <p>Example</p> <pre><code>local flex = require('import-full')\n\nflex.set_main_tags{\n    boundary = {administrative = 'named'},\n    highway = {'always', street_lamp = 'named'},\n    landuse = 'fallback'\n}\n</code></pre> <p>In this example an object with a <code>boundary</code> tag will only be included when it has a value of <code>administrative</code>. Objects with <code>highway</code> tags are always included. However when the value is <code>street_lamp</code> then the object must have a name, too. With any other value, the object is included independently of the name. Finally, if a <code>landuse</code> tag is present then it will be used independely of the concrete value if neither boundary nor highway tags were found and the object is named.</p>"},{"location":"customize/Import-Styles/#set_prefilters-ignoring-tags","title":"<code>set_prefilters()</code> - ignoring tags","text":"<p>Pre-filtering of tags allows to ignore them for any further processing. Thus pre-filtering takes precedence over any other tag processing. This is useful when some specific key/value combinations need to be excluded from processing. When tags are filtered, they may either be deleted completely or moved to <code>extratags</code>. Extra tags are saved with the object and returned to the user when requested, but are not used otherwise.</p> <p><code>set_prefilters()</code> takes a table with four optional fields:</p> <ul> <li>delete_keys is a key match list for tags that should be deleted</li> <li>delete_tags contains a table of tag keys pointing to a list of tag   values. Tags with matching key/value pairs are deleted.</li> <li>extra_keys is a key match list for tags which should be saved into   extratags</li> <li>extra_tags contains a table of tag keys pointing to a list of tag   values. Tags with matching key/value pairs are moved to extratags.</li> </ul> <p>Key list may contain three kinds of strings: A string that ends in an asterisk <code>*</code> is a prefix match and accordingly matches against any key that starts with the given string (minus the <code>*</code>).  A suffix match can be defined similarly with a string that starts with a <code>*</code>. Any other string is matched exactly against tag keys.</p> <p>Example</p> <pre><code>local flex = require('import-full')\n\nflex.set_prefilters{\n    delete_keys = {'source', 'source:*'},\n    extra_tags = {amenity = {'yes', 'no'}}\n}\nflex.set_main_tags{\n    amenity = 'always'\n}\n</code></pre> <p>In this example any tags <code>source</code> and tags that begin with <code>source:</code>  are deleted before any other processing is done. Getting rid of frequent tags this way can speed up the import.</p> <p>Tags with <code>amenity=yes</code> or <code>amenity=no</code> are moved to extratags. Later all tags with an <code>amenity</code> key are made a main tag. This effectively means that Nominatim will use all amenity tags except for those with value yes and no.</p>"},{"location":"customize/Import-Styles/#set_name_tags-defining-names","title":"<code>set_name_tags()</code> - defining names","text":"<p>The flex script distinguishes between two kinds of names:</p> <ul> <li>main: the primary names make an object fully searchable.   Main tags of type named will only cause the object to be included when   such a primary name is present. Primary names are usually those found   in the <code>name</code> tag and its variants.</li> <li>extra: extra names are still added to the search index but they are   alone not sufficient to make an object named.</li> </ul> <p><code>set_name_tags()</code> takes a table with two optional fields <code>main</code> and <code>extra</code>. They take key match lists for main and extra names respectively.</p> <p>Example</p> <pre><code>local flex = require('flex-base')\n\nflex.set_main_tags{highway = {traffic_light = 'named'}}\nflex.set_name_tags{main = {'name', 'name:*'},\n                   extra = {'ref'}\n                  }\n</code></pre> <p>This example creates a search index over traffic lights but will only include those that have a common name and not those which just have some reference ID from the city.</p>"},{"location":"customize/Import-Styles/#set_address_tags-defining-address-parts","title":"<code>set_address_tags()</code> - defining address parts","text":"<p>Address tags will be used to build up the address of an object.</p> <p><code>set_address_tags()</code> takes a table with arbitrary fields pointing to key match lists. To fields have a special meaning:</p> <ul> <li> <p>main: defines the tags that make a full address object out of the OSM object. This is usually the housenumber or variants thereof. If a main address tag appears, then the object will always be included, if necessary with a fallback of <code>place=house</code>. If the key has a prefix of <code>addr:</code> or <code>is_in:</code> this will be stripped.</p> </li> <li> <p>extra: defines all supplementary tags for addresses, tags like <code>addr:street</code>, <code>addr:city</code> etc. If the key has a prefix of <code>addr:</code> or <code>is_in:</code> this will be stripped.</p> </li> </ul> <p>All other fields will be handled as summary fields. If a key matches the key match list, then its value will be added to the address tags with the name of the field as key. If multiple tags match, then an arbitrary one wins.</p> <p>Country tags are handled slightly special. Only tags with a two-letter code are accepted, all other values are discarded.</p> <p>Example</p> <pre><code>local flex = require('import-full')\n\nflex.set_address_tags{\n    main = {'addr:housenumber'},\n    extra = {'addr:*'},\n    postcode = {'postal_code', 'postcode', 'addr:postcode'},\n    country = {'country-code', 'ISO3166-1'}\n}\n</code></pre> <p>In this example all tags which begin with <code>addr:</code> will be saved in the address tag list. If one of the tags is <code>addr:housenumber</code>, the object will fall back to be entered as a <code>place=house</code> in the database unless there is another interested main tag to be found.</p> <p>Tags with keys <code>country-code</code> and <code>ISO3166-1</code> are saved with their value under <code>country</code> in the address tag list. The same thing happens to postcodes, they will always be saved under the key <code>postcode</code> thus normalizing the multitude of keys that are used in the OSM database.</p>"},{"location":"customize/Import-Styles/#set_unused_handling-processing-remaining-tags","title":"<code>set_unused_handling()</code> - processing remaining tags","text":"<p>This function defines what to do with tags that remain after all tags have been classified using the functions above. There are two ways in which the function can be used:</p> <p><code>set_unused_handling(delete_keys = ..., delete_tags = ...)</code> deletes all keys that match the descriptions in the parameters and moves all remaining tags into the extratags list. <code>set_unused_handling(extra_keys = ..., extra_tags = ...)</code> moves all tags matching the parameters into the extratags list and then deletes the remaining tags. For the format of the parameters see the description in <code>set_prefilters()</code> above.</p> <p>Example</p> <pre><code>local flex = require('import-full')\n\nflex.set_address_tags{\n    main = {'addr:housenumber'},\n    extra = {'addr:*', 'tiger:county'}\n}\nflex.set_unused_handling{delete_keys = {'tiger:*'}}\n</code></pre> <p>In this example all remaining tags except those beginning with <code>tiger:</code> are moved to the extratags list. Note that it is not possible to already delete the tiger tags with <code>set_prefilters()</code> because that would remove tiger:county before the address tags are processed.</p>"},{"location":"customize/Import-Styles/#customizing-osm2pgsql-callbacks","title":"Customizing osm2pgsql callbacks","text":"<p>osm2pgsql expects the flex style to implement three callbacks, one process function per OSM type. If you want to implement special handling for certain OSM types, you can override the default implementations provided by the flex-base module.</p>"},{"location":"customize/Import-Styles/#changing-the-relation-types-to-be-handled","title":"Changing the relation types to be handled","text":"<p>The default scripts only allows relations of type <code>multipolygon</code>, <code>boundary</code> and <code>waterway</code>. To add other types relations, set <code>RELATION_TYPES</code> for the type to the kind of geometry that should be created. The following kinds of geometries can be used:</p> <ul> <li>relation_as_multipolygon creates a (Multi)Polygon from the ways in   the relation. If the ways do not form a valid area, then the object is   silently discarded.</li> <li>relation_as_multiline creates a (Multi)LineString from the ways in   the relations. Ways are combined as much as possible without any regards   to their order in the relation.</li> </ul> <p>Example</p> <pre><code>local flex = require('import-full')\n\nflex.RELATION_TYPES['site'] = flex.relation_as_multipolygon\n</code></pre> <p>With this line relations of <code>type=site</code> will be included in the index according to main tags found. This only works when the site relation resolves to a valid area. Nodes in the site relation are not part of the geometry.</p>"},{"location":"customize/Import-Styles/#adding-additional-logic-to-processing-functions","title":"Adding additional logic to processing functions","text":"<p>The default processing functions are also exported by the flex-base module as <code>process_node</code>, <code>process_way</code> and <code>process_relation</code>. These can be used to implement your own processing functions with some additional processing logic.</p> <p>Example</p> <pre><code>local flex = require('import-full')\n\nfunction osm2pgsql.process_relation(object)\n    if object.tags.boundary ~= 'administrative' or object.tags.admin_level ~= '2' then\n      flex.process_relation(object)\n    end\nend\n</code></pre> <p>This example discards all country-level boundaries and uses standard handling for everything else. This can be useful if you want to use your own custom country boundaries.</p>"},{"location":"customize/Import-Styles/#customizing-the-main-processing-function","title":"Customizing the main processing function","text":"<p>The main processing function of the flex style can be found in the function <code>process_tags</code>. This function is called for all OSM object kinds and is responsible for filtering the tags and writing out the rows into Postgresql.</p> <p>Example</p> <pre><code>local flex = require('import-full')\n\nlocal original_process_tags = flex.process_tags\n\nfunction flex.process_tags(o)\n    if o.object.tags.highway ~= nil and o.object.tags.access == 'no' then\n        return\n    end\n\n    original_process_tags(o)\nend\n</code></pre> <p>This example shows the most simple customization of the process_tags function. It simply adds some additional processing before running the original code. To do that, first save the original function and then overwrite process_tags from the module. In this example all highways which are not accessible by anyone will be ignored.</p>"},{"location":"customize/Import-Styles/#the-place-class","title":"The <code>Place</code> class","text":"<p>The <code>process_tags</code> function receives a Lua object of <code>Place</code> type which comes with some handy functions to collect the data necessary for geocoding and writing it into the place table. Always use this object to fill the table.</p> <p>The Place class has some attributes which you may access read-only:</p> <ul> <li>object is the original OSM object data handed in by osm2pgsql</li> <li>admin_level is the content of the admin_level tag, parsed into an   integer and normalized to a value between 0 and 15</li> <li>has_name is a boolean indicating if the object has a full name</li> <li>names is a table with the collected list of name tags</li> <li>address is a table with the collected list of address tags</li> <li>extratags is a table with the collected list of additional tags to save</li> </ul> <p>There are a number of functions to fill these fields. All functions expect a table parameter with fields as indicated in the description. Many of these functions expect match functions which are described in detail further below.</p> <ul> <li>delete{match=...} removes all tags that match the match function given   in match.</li> <li>grab_extratags{match=...} moves all tags that match the match function   given in match into extratags. Returns the number of tags moved.</li> <li>clean{delete=..., extra=...} deletes all tags that match delete and   moves the ones that match extra  into extratags</li> <li>grab_address_parts{groups=...} moves matching tags into the address table.   groups must be a group match function. Tags of the group <code>main</code> and   <code>extra</code> are added to the address table as is but with <code>addr:</code> and <code>is_in:</code>   prefixes removed from the tag key. All other groups are added with the   group name as key and the value from the tag. Multiple values of the same   group overwrite each other. The function returns the number of tags saved   from the main group.</li> <li>grab_main_parts{groups=...} moves matching tags into the name table.   groups must be a group match function. If a tags of the group <code>main</code> is   present, the object will be marked as having a name. Tags of group <code>house</code>   produce a fallback to <code>place=house</code>. This fallback is return by the function   if present.</li> </ul> <p>There are two functions to write a row into the place table. Both functions expect the main tag (key and value) for the row and then use the collected information from the name, address, extratags etc. fields to complete the row. They also have a boolean parameter <code>save_extra_mains</code> which defines how any unprocessed tags are handled: when True, the tags will be saved as extratags, when False, they will be simply discarded.</p> <ul> <li>write_row(key, value, save_extra_mains) creates a new table row from   the current state of the Place object.</li> <li>write_place(key, value, mtype, save_extra_mains) creates a new row   conditionally. When value is nil, the function will attempt to look up the   value in the object tags. If value is still nil or mtype is nil, the row   is ignored. An mtype of <code>always</code> will then always write out the row,   a mtype of <code>named</code> only, when the object has a full name. When mtype   is <code>named_with_key</code>, the function checks for a domain name, i.e. a name   tag prefixed with the name of the main key. Only if at least one is found,   the row will be written. The names are replaced with the domain names found.</li> </ul>"},{"location":"customize/Import-Styles/#match-functions","title":"Match functions","text":"<p>The Place functions usually expect either a match function or a group match function to find the tags to apply their function to.</p> <p>The match function is a Lua function which takes two parameters, key and value, and returns a boolean to indicate that a tag matches. The flex-base module has a convenience function <code>tag_match()</code> to create such a function. It takes a table with two optional fields: <code>keys</code> takes a key match list (see above), <code>tags</code> takes a table with keys that point to a list of possible values, thus defining key/value matches.</p> <p>The group match function is a Lua function which also takes two parameters, key and value, and returns a string indicating to which group or type they belong to. The <code>tag_group()</code> can be used to create such a function. It expects a table where the group names are the keys and the values are a key match list.</p>"},{"location":"customize/Import-Styles/#using-the-gazetteer-output-of-osm2pgsql","title":"Using the gazetteer output of osm2pgsql","text":"<p>Nominatim still allows you to configure the gazetteer output to remain backwards compatible with older imports. It will be automatically used when the style file name ends in <code>.style</code>. For documentation of the old import style, please refer to the documentation of older releases of Nominatim. Do not use the gazetteer output for new imports. There is no guarantee that new versions of Nominatim are fully compatible with the gazetteer output.</p>"},{"location":"customize/Import-Styles/#changing-the-style-of-existing-databases","title":"Changing the Style of Existing Databases","text":"<p>There is normally no issue changing the style of a database that is already imported and now kept up-to-date with change files. Just be aware that any change in the style applies to updates only. If you want to change the data that is already in the database, then a reimport is necessary.</p>"},{"location":"customize/Importance/","title":"Importance","text":""},{"location":"customize/Importance/#importance","title":"Importance","text":"<p>Search requests can yield multiple results which match equally well with the original query. In such case Nominatim needs to order the results according to a different criterion: importance. This is a measure for how likely it is that a user will search for a given place. This section explains the sources Nominatim uses for computing importance of a place and how to customize them.</p>"},{"location":"customize/Importance/#how-importance-is-computed","title":"How importance is computed","text":"<p>The main value for importance is derived from page ranking values for Wikipedia pages for a place. For places that do not have their own Wikipedia page, a formula is used that derives a static importance from the places search rank.</p> <p>In a second step, a secondary importance value is added which is meant to represent how well-known the general area is where the place is located. It functions as a tie-breaker between places with very similar primary importance values.</p> <p>nominatim.org has preprocessed importance tables for the primary Wikipedia rankings and for a secondary importance based on the number of tile views on openstreetmap.org.</p>"},{"location":"customize/Importance/#customizing-secondary-importance","title":"Customizing secondary importance","text":"<p>The secondary importance is implemented as a simple Postgis raster table, where Nominatim looks up the value for the coordinates of the centroid of a place. You can provide your own secondary importance raster in form of an SQL file named <code>secondary_importance.sql.gz</code> in your project directory.</p> <p>The SQL file needs to drop and (re)create a table <code>secondary_importance</code> which must as a minimum contain a column <code>rast</code> of type <code>raster</code>. The raster must be in EPSG:4326 and contain 16bit unsigned ints (`raster_constraint_pixel_types(rast) = '{16BUI}'). Any other columns in the table will be ignored. You must furthermore create an index as follows:</p> <pre><code>CREATE INDEX ON secondary_importance USING gist(ST_ConvexHull(gist))\n</code></pre> <p>The following raster2pgsql command will create a table that conforms to the requirements:</p> <pre><code>raster2pgsql -I -C -Y -d -t 128x128 input.tiff public.secondary_importance\n</code></pre>"},{"location":"customize/Overview/","title":"Overview","text":"<p>Nominatim comes with a predefined set of configuration options that should work for most standard installations. If you have special requirements, there are many places where the configuration can be adapted. This chapter describes the following configurable parts:</p> <ul> <li>Global Settings has a detailed description of all parameters that   can be set in your local <code>.env</code> configuration</li> <li>Import styles explains how to write your own import style   in order to control what kind of OSM data will be imported</li> <li>Place ranking describes the configuration around classifing   places in terms of their importance and their role in an address</li> <li>Tokenizers describes the configuration of the module   responsible for analysing and indexing names</li> <li>Special Phrases are common nouns or phrases that   can be used in search to identify a class of places</li> </ul> <p>There are also guides for adding the following external data:</p> <ul> <li>US house numbers from the TIGER dataset</li> <li>External postcodes</li> </ul>"},{"location":"customize/Postcodes/","title":"External postcode data","text":"<p>Nominatim creates a table of known postcode centroids during import. This table is used for searches of postcodes and for adding postcodes to places where the OSM data does not provide one. These postcode centroids are mainly computed from the OSM data itself. In addition, Nominatim supports reading postcode information from an external CSV file, to supplement the postcodes that are missing in OSM.</p> <p>To enable external postcode support, simply put one CSV file per country into your project directory and name it <code>&lt;CC&gt;_postcodes.csv</code>. <code>&lt;CC&gt;</code> must be the two-letter country code for which to apply the file. The file may also be gzipped. Then it must be called <code>&lt;CC&gt;_postcodes.csv.gz</code>.</p> <p>The CSV file must use commas as a delimiter and have a header line. Nominatim expects three columns to be present: <code>postcode</code>, <code>lat</code> and <code>lon</code>. All other columns are ignored. <code>lon</code> and <code>lat</code> must describe the x and y coordinates of the postcode centroids in WGS84.</p> <p>The postcode files are loaded only when there is data for the given country in your database. For example, if there is a <code>us_postcodes.csv</code> file in your project directory but you import only an excerpt of Italy, then the US postcodes will simply be ignored.</p> <p>As a rule, the external postcode data should be put into the project directory before starting the initial import. Still, you can add, remove and update the external postcode data at any time. Simply run:</p> <pre><code>nominatim refresh --postcodes\n</code></pre> <p>to make the changes visible in your database. Be aware, however, that the changes only have an immediate effect on searches for postcodes. Postcodes that were added to places are only updated, when they are reindexed. That usually happens only during replication updates.</p>"},{"location":"customize/Ranking/","title":"Place Ranking in Nominatim","text":"<p>Nominatim uses two metrics to rank a place: search rank and address rank. This chapter explains what place ranking means and how it can be customized.</p>"},{"location":"customize/Ranking/#search-rank","title":"Search rank","text":"<p>The search rank describes the extent and importance of a place. It is used when ranking search results. Simply put, if there are two results for a search query which are otherwise equal, then the result with the lower search rank will be appear higher in the result list.</p> <p>Search ranks are not so important these days because many well-known places use the Wikipedia importance ranking instead.</p> <p>The following table gives an overview of the kind of features that Nominatim expects for each rank:</p> rank typical place types extent 1-3 oceans, continents - 4 countries - 5-9 states, regions, provinces - 10-12 counties - 13-16 cities, municipalities, islands 15 km 17-18 towns, boroughs 4 km 19 villages, suburbs 2 km 20 hamlets, farms, neighbourhoods 1 km 21-25 isolated dwellings, city blocks 500 m <p>The extent column describes how far a feature is assumed to reach when it is mapped only as a point. Larger features like countries and states are usually available with their exact area in the OpenStreetMap data. That is why no extent is given.</p>"},{"location":"customize/Ranking/#address-rank","title":"Address rank","text":"<p>The address rank describes where a place shows up in an address hierarchy. Usually only administrative boundaries and place nodes and areas are eligible to be part of an address. Places that should not appear in the address must have an address rank of 0.</p> <p>The following table gives an overview how ranks are mapped to address parts:</p> rank address part 1-3 unused 4 country 5-9 state 10-12 county 13-16 city 17-21 suburb 22-24 neighbourhood 25 squares, farms, localities 26-27 street 28-30 POI/house number <p>The country rank 4 usually doesn't show up in the address parts of an object. The country is determined indirectly from the country code.</p> <p>Ranks 5-24 can be assigned more or less freely. They make up the major part of the address.</p> <p>Rank 25 is also an addressing rank but it is special because while it can be the parent to a POI with an addr:place of the same name, it cannot be a parent to streets. Use it for place features that are technically on the same level as a street (e.g. squares, city blocks) or for places that should not normally appear in an address unless explicitly tagged so (e.g place=locality which should be uninhabited and as such not addressable).</p> <p>The street ranks 26 and 27 are handled slightly differently. Only one object from these ranks shows up in an address.</p> <p>For POI level objects like shops, buildings or house numbers always use rank 30. Ranks 28 is reserved for house number interpolations. 29 is for internal use only.</p>"},{"location":"customize/Ranking/#rank-configuration","title":"Rank configuration","text":"<p>Search and address ranks are assigned to a place when it is first imported into the database. There are a few hard-coded rules for the assignment:</p> <ul> <li>postcodes follow special rules according to their length</li> <li>boundaries that are not areas and railway=rail are dropped completely</li> <li>the following are always search rank 30 and address rank 0:<ul> <li>highway nodes</li> <li>landuse that is not an area</li> </ul> </li> </ul> <p>Other than that, the ranks can be freely assigned via the JSON file according to their type and the country they are in. The name of the config file to be used can be changed with the setting <code>NOMINATIM_ADDRESS_LEVEL_CONFIG</code>.</p> <p>The address level configuration must consist of an array of configuration entries, each containing a tag definition and an optional country array:</p> <pre><code>[ {\n    \"tags\" : {\n      \"place\" : {\n        \"county\" : 12,\n        \"city\" : 16,\n      },\n      \"landuse\" : {\n        \"residential\" : 22,\n        \"\" : 30\n      }\n    }\n  },\n  {\n    \"countries\" : [ \"ca\", \"us\" ],\n    \"tags\" : {\n      \"boundary\" : {\n        \"administrative8\" : 18,\n        \"administrative9\" : 20\n      },\n      \"landuse\" : {\n        \"residential\" : [22, 0]\n      }\n    }\n  }\n]\n</code></pre> <p>The <code>countries</code> field contains a list of countries (as ISO 3166-1 alpha 2 code) for which the definition applies. When the field is omitted, then the definition is used as a fallback, when nothing more specific for a given country exists.</p> <p><code>tags</code> contains the ranks for key/value pairs. The ranks can be either a single number, in which case they are the search and address rank, or an array of search and address rank (in that order). The value may be left empty. Then the rank is used when no more specific value is found for the given key.</p> <p>Countries and key/value combination may appear in multiple definitions. Just make sure that each combination of country/key/value appears only once per file. Otherwise the import will fail with a UNIQUE INDEX constraint violation on import.</p>"},{"location":"customize/SQLite/","title":"Conversion to SQLite","text":"<p>A Nominatim database can be converted into an SQLite database and used as a read-only source for geocoding queries. This sections describes how to create and use an SQLite database.</p> <p>Danger</p> <p>This feature is in an experimental state at the moment. Use at your own risk.</p>"},{"location":"customize/SQLite/#installing-prerequisites","title":"Installing prerequisites","text":"<p>To use a SQLite database, you need to install:</p> <ul> <li>SQLite (&gt;= 3.30)</li> <li>Spatialite (&gt; 5.0.0)</li> </ul> <p>On Ubuntu/Debian, you can run:</p> <pre><code>sudo apt install sqlite3 libsqlite3-mod-spatialite libspatialite7\n</code></pre>"},{"location":"customize/SQLite/#creating-a-new-sqlite-database","title":"Creating a new SQLite database","text":"<p>Nominatim cannot import directly into SQLite database. Instead you have to first create a geocoding database in PostgreSQL by running a regular Nominatim import.</p> <p>Once this is done, the database can be converted to SQLite with</p> <pre><code>nominatim convert -o mydb.sqlite\n</code></pre> <p>This will create a database where all geocoding functions are available. Depending on what functions you need, the database can be made smaller:</p> <ul> <li><code>--without-reverse</code> omits indexes only needed for reverse geocoding</li> <li><code>--without-search</code> omit tables and indexes used for forward search</li> <li><code>--without-details</code> leaves out extra information only available in the   details API</li> </ul>"},{"location":"customize/SQLite/#using-an-sqlite-database","title":"Using an SQLite database","text":"<p>Once you have created the database, you can use it by simply pointing the database DSN to the SQLite file:</p> <pre><code>NOMINATIM_DATABASE_DSN=sqlite:dbname=mydb.sqlite\n</code></pre> <p>Please note that SQLite support is only available for the Python frontend. To use the test server with an SQLite database, you therefore need to switch the frontend engine:</p> <pre><code>nominatim serve --engine falcon\n</code></pre> <p>You need to install falcon or starlette for this, depending on which engine you choose.</p> <p>The CLI query commands and the library interface already use the new Python frontend and therefore work right out of the box.</p>"},{"location":"customize/Settings/","title":"Configuration Settings","text":"<p>This section provides a reference of all configuration parameters that can be used with Nominatim.</p>"},{"location":"customize/Settings/#configuring-nominatim","title":"Configuring Nominatim","text":"<p>Nominatim uses dotenv to manage its configuration settings. There are two means to set configuration variables: through an <code>.env</code> configuration file or through an environment variable.</p> <p>The <code>.env</code> configuration file needs to be placed into the project directory. It must contain configuration parameters in <code>&lt;parameter&gt;=&lt;value&gt;</code> format. Please refer to the dotenv documentation for details.</p> <p>The configuration options may also be set in the form of shell environment variables. This is particularly useful, when you want to temporarily change a configuration option. For example, to force the replication serve to download the next change, you can temporarily disable the update interval:</p> <pre><code>NOMINATIM_REPLICATION_UPDATE_INTERVAL=0 nominatim replication --once\n</code></pre> <p>If a configuration option is defined through .env file and environment variable, then the latter takes precedence. </p>"},{"location":"customize/Settings/#configuration-parameter-reference","title":"Configuration Parameter Reference","text":""},{"location":"customize/Settings/#import-and-database-settings","title":"Import and Database Settings","text":""},{"location":"customize/Settings/#nominatim_database_dsn","title":"NOMINATIM_DATABASE_DSN","text":"Summary Description: Database connection string Format: string: <code>pgsql:&lt;param1&gt;=&lt;value1&gt;;&lt;param2&gt;=&lt;value2&gt;;...</code> Default: pgsql:dbname=nominatim After Changes: run <code>nominatim refresh --website</code> <p>Sets the connection parameters for the Nominatim database. At a minimum the name of the database (<code>dbname</code>) is required. You can set any additional parameter that is understood by libpq. See the Postgres documentation for a full list.</p> <p>Note</p> <p>It is usually recommended not to set the password directly in this configuration parameter. Use a password file instead.</p>"},{"location":"customize/Settings/#nominatim_database_webuser","title":"NOMINATIM_DATABASE_WEBUSER","text":"Summary Description: Database query user Format: string Default: www-data After Changes: cannot be changed after import <p>Defines the name of the database user that will run search queries. Usually this is the user under which the webserver is executed. When running Nominatim via php-fpm, you can also define a separate query user. The Postgres user needs to be set up before starting the import.</p> <p>Nominatim grants minimal rights to this user to all tables that are needed for running geocoding queries.</p>"},{"location":"customize/Settings/#nominatim_database_module_path","title":"NOMINATIM_DATABASE_MODULE_PATH","text":"Summary Description: Directory where to find the PostgreSQL server module Format: path Default: empty (use <code>&lt;project_directory&gt;/module</code>) After Changes: run <code>nominatim refresh --functions</code> Comment: Legacy tokenizer only <p>Defines the directory in which the PostgreSQL server module <code>nominatim.so</code> is stored. The directory and module must be accessible by the PostgreSQL server.</p> <p>For information on how to use this setting when working with external databases, see Advanced Installations.</p> <p>The option is only used by the Legacy tokenizer and ignored otherwise.</p>"},{"location":"customize/Settings/#nominatim_tokenizer","title":"NOMINATIM_TOKENIZER","text":"Summary Description: Tokenizer used for normalizing and parsing queries and names Format: string Default: icu After Changes: cannot be changed after import <p>Sets the tokenizer type to use for the import. For more information on available tokenizers and how they are configured, see Tokenizers.</p>"},{"location":"customize/Settings/#nominatim_tokenizer_config","title":"NOMINATIM_TOKENIZER_CONFIG","text":"Summary Description: Configuration file for the tokenizer Format: path Default: empty (default file depends on tokenizer) After Changes: see documentation for each tokenizer <p>Points to the file with additional configuration for the tokenizer. See the Tokenizer descriptions for details on the file format.</p> <p>If a relative path is given, then the file is searched first relative to the project directory and then in the global settings directory.</p>"},{"location":"customize/Settings/#nominatim_max_word_frequency","title":"NOMINATIM_MAX_WORD_FREQUENCY","text":"Summary Description: Number of occurrences before a word is considered frequent Format: int Default: 50000 After Changes: cannot be changed after import Comment: Legacy tokenizer only <p>The word frequency count is used by the Legacy tokenizer to automatically identify stop words. Any partial term that occurs more often then what is defined in this setting, is effectively ignored during search.</p>"},{"location":"customize/Settings/#nominatim_limit_reindexing","title":"NOMINATIM_LIMIT_REINDEXING","text":"Summary Description: Avoid invalidating large areas Format: bool Default: yes <p>Nominatim computes the address of each place at indexing time. This has the advantage to make search faster but also means that more objects needs to be invalidated when the data changes. For example, changing the name of the state of Florida would require recomputing every single address point in the state to make the new name searchable in conjunction with addresses.</p> <p>Setting this option to 'yes' means that Nominatim skips reindexing of contained objects when the area becomes too large.</p>"},{"location":"customize/Settings/#nominatim_languages","title":"NOMINATIM_LANGUAGES","text":"Summary Description: Restrict search languages Format: string: comma-separated list of language codes Default: empty <p>Normally Nominatim will include all language variants of name:XX in the search index. Set this to a comma separated list of language codes, to restrict import to a subset of languages.</p> <p>Currently only affects the initial import of country names and special phrases.</p>"},{"location":"customize/Settings/#nominatim_term_normalization","title":"NOMINATIM_TERM_NORMALIZATION","text":"Summary Description: Rules for normalizing terms for comparisons Format: string: semicolon-separated list of ICU rules Default: :: NFD (); [:Nonspacing Mark:] &gt;;  :: lower (); [:Punctuation:]+ &gt; ' '; :: NFC (); Comment: Legacy tokenizer only <p>Special phrases have stricter matching requirements than normal search terms. They must appear exactly in the query after this term normalization has been applied.</p> <p>Only has an effect on the Legacy tokenizer. For the ICU tokenizer the rules defined in the normalization section will be used.</p>"},{"location":"customize/Settings/#nominatim_use_us_tiger_data","title":"NOMINATIM_USE_US_TIGER_DATA","text":"Summary Description: Enable searching for Tiger house number data Format: boolean Default: no After Changes: run <code>nominatim refresh --functions</code> <p>When this setting is enabled, search and reverse queries also take data from Tiger house number data into account.</p>"},{"location":"customize/Settings/#nominatim_use_aux_location_data","title":"NOMINATIM_USE_AUX_LOCATION_DATA","text":"Summary Description: Enable searching in external house number tables Format: boolean Default: no After Changes: run <code>nominatim refresh --functions</code> Comment: Do not use. <p>When this setting is enabled, search queries also take data from external house number tables into account.</p> <p>Warning: This feature is currently unmaintained and should not be used.</p>"},{"location":"customize/Settings/#nominatim_http_proxy","title":"NOMINATIM_HTTP_PROXY","text":"Summary Description: Use HTTP proxy when downloading data Format: boolean Default: no <p>When this setting is enabled and at least NOMINATIM_HTTP_PROXY_HOST and NOMINATIM_HTTP_PROXY_PORT are set, the configured proxy will be used, when downloading external data like replication diffs.</p>"},{"location":"customize/Settings/#nominatim_http_proxy_host","title":"NOMINATIM_HTTP_PROXY_HOST","text":"Summary Description: Host name of the proxy to use Format: string Default: empty <p>When NOMINATIM_HTTP_PROXY is enabled, this setting configures the proxy host name.</p>"},{"location":"customize/Settings/#nominatim_http_proxy_port","title":"NOMINATIM_HTTP_PROXY_PORT","text":"Summary Description: Port number of the proxy to use Format: integer Default: 3128 <p>When NOMINATIM_HTTP_PROXY is enabled, this setting configures the port number to use with the proxy.</p>"},{"location":"customize/Settings/#nominatim_http_proxy_login","title":"NOMINATIM_HTTP_PROXY_LOGIN","text":"Summary Description: Username for proxies that require login Format: string Default: empty <p>When NOMINATIM_HTTP_PROXY is enabled, use this setting to define the username for proxies that require a login.</p>"},{"location":"customize/Settings/#nominatim_http_proxy_password","title":"NOMINATIM_HTTP_PROXY_PASSWORD","text":"Summary Description: Password for proxies that require login Format: string Default: empty <p>When NOMINATIM_HTTP_PROXY is enabled, use this setting to define the password for proxies that require a login.</p>"},{"location":"customize/Settings/#nominatim_osm2pgsql_binary","title":"NOMINATIM_OSM2PGSQL_BINARY","text":"Summary Description: Location of the osm2pgsql binary Format: path Default: empty (use binary shipped with Nominatim) Comment: EXPERT ONLY <p>Nominatim uses osm2pgsql to load the OSM data initially into the database. Nominatim comes bundled with a version of osm2pgsql that is guaranteed to be compatible. Use this setting to use a different binary instead. You should do this only when you know exactly what you are doing. If the osm2pgsql version is not compatible, then the result is undefined.</p>"},{"location":"customize/Settings/#nominatim_wikipedia_data_path","title":"NOMINATIM_WIKIPEDIA_DATA_PATH","text":"Summary Description: Directory with the wikipedia importance data Format: path Default: empty (project directory) <p>Set a custom location for the wikipedia ranking file. When unset, Nominatim expects the data to be saved in the project directory.</p>"},{"location":"customize/Settings/#nominatim_address_level_config","title":"NOMINATIM_ADDRESS_LEVEL_CONFIG","text":"Summary Description: Configuration file for rank assignments Format: path Default: address-levels.json <p>The address level configuration defines the rank assignments for places. See Place Ranking for a detailed explanation what rank assignments are and what the configuration file must look like.</p> <p>When a relative path is given, then the file is searched first relative to the project directory and then in the global settings directory.</p>"},{"location":"customize/Settings/#nominatim_import_style","title":"NOMINATIM_IMPORT_STYLE","text":"Summary Description: Configuration to use for the initial OSM data import Format: string or path Default: extratags <p>The style configuration describes which OSM objects and tags are taken into consideration for the search database. Nominatim comes with a set of pre-configured styles, that may be configured here.</p> <p>You can also write your own custom style and point the setting to the file with the style. When a relative path is given, then the style file is searched first relative to the project directory and then in the global settings directory.</p> <p>See Import Styles for more information on the available internal styles and the format of the configuration file.</p>"},{"location":"customize/Settings/#nominatim_flatnode_file","title":"NOMINATIM_FLATNODE_FILE","text":"Summary Description: Location of osm2pgsql flatnode file Format: path Default: empty (do not use a flatnote file) After Changes: Only change when moving the file physically. <p>The <code>osm2pgsql flatnode file</code> is file that efficiently stores geographic location for OSM nodes. For larger imports it can significantly speed up the import. When this option is unset, then osm2pgsql uses a PsotgreSQL table to store the locations.</p> <p>When a relative path is given, then the flatnode file is created/searched relative to the project directory.</p> <p>Warning</p> <p>The flatnode file is not only used during the initial import but also when adding new data with <code>nominatim add-data</code> or <code>nominatim replication</code>. Make sure you keep the flatnode file around and this setting unmodified, if you plan to add more data or run regular updates.</p>"},{"location":"customize/Settings/#nominatim_tablespace_","title":"NOMINATIM_TABLESPACE_*","text":"Summary Description: Group of settings for distributing the database over tablespaces Format: string Default: empty (do not use a table space) After Changes: no effect after initial import <p>Nominatim allows to distribute the search database over up to 10 different PostgreSQL tablespaces. If you use this option, make sure that the tablespaces exist before starting the import.</p> <p>The available tablespace groups are:</p> NOMINATIM_TABLESPACE_SEARCH_DATA Data used by the geocoding frontend. NOMINATIM_TABLESPACE_SEARCH_INDEX Indexes used by the geocoding frontend. NOMINATIM_TABLESPACE_OSM_DATA Raw OSM data cache used for import and updates. NOMINATIM_TABLESPACE_OSM_DATA Indexes on the raw OSM data cache. NOMINATIM_TABLESPACE_PLACE_DATA Data table with the pre-filtered but still unprocessed OSM data.  Used only during imports and updates. NOMINATIM_TABLESPACE_PLACE_INDEX Indexes on raw data table. Used only during imports and updates. NOMINATIM_TABLESPACE_ADDRESS_DATA Data tables used for computing search terms and addresses of places  during import and updates. NOMINATIM_TABLESPACE_ADDRESS_INDEX Indexes on the data tables for search term and address computation.  Used only for import and updates. NOMINATIM_TABLESPACE_AUX_DATA Auxiliary data tables for non-OSM data, e.g. for Tiger house number data. NOMINATIM_TABLESPACE_AUX_INDEX Indexes on auxiliary data tables."},{"location":"customize/Settings/#replication-update-settings","title":"Replication Update Settings","text":""},{"location":"customize/Settings/#nominatim_replication_url","title":"NOMINATIM_REPLICATION_URL","text":"Summary Description: Base URL of the replication service Format: url Default: https://planet.openstreetmap.org/replication/minute After Changes: run <code>nominatim replication --init</code> <p>Replication services deliver updates to OSM data. Use this setting to choose which replication service to use. See Updates for more information on how to set up regular updates.</p>"},{"location":"customize/Settings/#nominatim_replication_max_diff","title":"NOMINATIM_REPLICATION_MAX_DIFF","text":"Summary Description: Maximum amount of data to download per update cycle (in MB) Format: integer Default: 50 After Changes: restart the replication process <p>At each update cycle Nominatim downloads diffs until either no more diffs are available on the server (i.e. the database is up-to-date) or the limit given in this setting is exceeded. Nominatim guarantees to downloads at least one diff, if one is available, no matter how small the setting.</p> <p>The default for this setting is fairly conservative because Nominatim keeps all data downloaded in one cycle in RAM. Using large values in a production server may interfere badly with the search frontend because it evicts data from RAM that is needed for speedy answers to incoming requests. It is usually a better idea to keep this setting lower and run multiple update cycles to catch up with updates.</p> <p>When catching up in non-production mode, for example after the initial import, the setting can easily be changed temporarily on the command line:</p> <pre><code>NOMINATIM_REPLICATION_MAX_DIFF=3000 nominatim replication\n</code></pre>"},{"location":"customize/Settings/#nominatim_replication_update_interval","title":"NOMINATIM_REPLICATION_UPDATE_INTERVAL","text":"Summary Description: Publication interval of the replication service (in seconds) Format: integer Default: 75 After Changes: restart the replication process <p>This setting determines when Nominatim will attempt to download again a new update. The time is computed from the publication date of the last diff downloaded. Setting this to a slightly higher value than the actual publication interval avoids unnecessary rechecks.</p>"},{"location":"customize/Settings/#nominatim_replication_recheck_interval","title":"NOMINATIM_REPLICATION_RECHECK_INTERVAL","text":"Summary Description: Wait time to recheck for a pending update (in seconds) Format: integer Default: 60 After Changes: restart the replication process <p>When replication updates are run in continuous mode (using <code>nominatim replication</code>), this setting determines how long Nominatim waits until it looks for updates again when updates were not available on the server.</p> <p>Note that this is different from NOMINATIM_REPLICATION_UPDATE_INTERVAL. Nominatim will never attempt to query for new updates for UPDATE_INTERVAL seconds after the current database date. Only after the update interval has passed it asks for new data. If then no new data is found, it waits for RECHECK_INTERVAL seconds before it attempts again.</p>"},{"location":"customize/Settings/#api-settings","title":"API Settings","text":""},{"location":"customize/Settings/#nominatim_cors_noaccesscontrol","title":"NOMINATIM_CORS_NOACCESSCONTROL","text":"Summary Description: Send permissive CORS access headers Format: boolean Default: yes After Changes: run <code>nominatim refresh --website</code> <p>When this setting is enabled, API HTTP responses include the HTTP CORS headers <code>access-control-allow-origin: *</code> and <code>access-control-allow-methods: OPTIONS,GET</code>.</p>"},{"location":"customize/Settings/#nominatim_mapicon_url","title":"NOMINATIM_MAPICON_URL","text":"Summary Description: URL prefix for static icon images Format: url Default: empty After Changes: run <code>nominatim refresh --website</code> <p>When a mapicon URL is configured, then Nominatim includes an additional <code>icon</code> field in the responses, pointing to an appropriate icon for the place type.</p> <p>Map icons used to be included in Nominatim itself but now have moved to the nominatim-ui project. If you want the URL to be included in API responses, make the <code>/mapicon</code> directory of the project available under a public URL and point this setting to the directory.</p>"},{"location":"customize/Settings/#nominatim_default_language","title":"NOMINATIM_DEFAULT_LANGUAGE","text":"Summary Description: Language of responses when no language is requested Format: language code Default: empty (use the local language of the feature) After Changes: run <code>nominatim refresh --website</code> <p>Nominatim localizes the place names in responses when the corresponding translation is available. Users can request a custom language setting through the HTTP accept-languages header or through the explicit parameter accept-languages. If neither is given, it falls back to this setting. If the setting is also empty, then the local languages (in OSM: the name tag without any language suffix) is used.</p>"},{"location":"customize/Settings/#nominatim_search_batch_mode","title":"NOMINATIM_SEARCH_BATCH_MODE","text":"Summary Description: Enable a special batch query mode Format: boolean Default: no After Changes: run <code>nominatim refresh --website</code> Comment: PHP frontend only <p>This feature is currently undocumented and potentially broken.</p>"},{"location":"customize/Settings/#nominatim_search_name_only_threshold","title":"NOMINATIM_SEARCH_NAME_ONLY_THRESHOLD","text":"Summary Description: Threshold for switching the search index lookup strategy Format: integer Default: 500 After Changes: run <code>nominatim refresh --website</code> Comment: PHP frontend only <p>This setting defines the threshold over which a name is no longer considered as rare. When searching for places with rare names, only the name is used for place lookups. Otherwise the name and any address information is used.</p> <p>This setting only has an effect after <code>nominatim refresh --word-counts</code> has been called to compute the word frequencies.</p>"},{"location":"customize/Settings/#nominatim_lookup_max_count","title":"NOMINATIM_LOOKUP_MAX_COUNT","text":"Summary Description: Maximum number of OSM ids accepted by /lookup Format: integer Default: 50 After Changes: run <code>nominatim refresh --website</code> <p>The /lookup point accepts list of ids to look up address details for. This setting restricts the number of places a user may look up with a single request.</p>"},{"location":"customize/Settings/#nominatim_polygon_output_max_types","title":"NOMINATIM_POLYGON_OUTPUT_MAX_TYPES","text":"Summary Description: Number of different geometry formats that may be returned Format: integer Default: 1 After Changes: run <code>nominatim refresh --website</code> <p>Nominatim supports returning full geometries of places. The geometries may be requested in different formats with one of the <code>polygon_*</code> parameters. Use this setting to restrict the number of geometry types that may be requested with a single query.</p> <p>Setting this parameter to 0 disables polygon output completely.</p>"},{"location":"customize/Settings/#nominatim_search_within_countries","title":"NOMINATIM_SEARCH_WITHIN_COUNTRIES","text":"Summary Description: Disable search for elements that are not in the country grid Format: boolean Default: no After Changes: run <code>nominatim refresh --website</code> Comment: PHP frontend only <p>Enable to search elements just within countries.</p> <p>When enabled, if, despite not finding a point within the static grid of countries, it finds a geometry of a region, do not return the geometry. Return \"Unable to geocode\" instead.</p>"},{"location":"customize/Settings/#nominatim_serve_legacy_urls","title":"NOMINATIM_SERVE_LEGACY_URLS","text":"Summary Description: Enable serving via URLs with a .php suffix Format: boolean Default: yes Comment: Python frontend only <p>When enabled, then endpoints are reachable as <code>/&lt;name&gt;</code> as well as <code>/&lt;name&gt;.php</code>. This can be useful when you want to be backwards-compatible with previous versions of Nominatim.</p>"},{"location":"customize/Settings/#nominatim_api_pool_size","title":"NOMINATIM_API_POOL_SIZE","text":"Summary Description: Number of parallel database connections per worker Format: number Default: 10 Comment: Python frontend only <p>Sets the maximum number of database connections available for a single instance of Nominatim. When configuring the maximum number of connections that your PostgreSQL database can handle, you need at least <code>NOMINATIM_API_POOL_SIZE</code> * <code>&lt;number of configured workers&gt;</code> connections. For configuring the number of workers, refer to the section about Deploying the Python frontend.</p>"},{"location":"customize/Settings/#nominatim_query_timeout","title":"NOMINATIM_QUERY_TIMEOUT","text":"Summary Description: Timeout for SQL queries to the database Format: number (seconds) Default: 10 Comment: Python frontend only <p>When this timeout is set, then all SQL queries that run longer than the specified numbers of seconds will be cancelled and the user receives a timeout exceptions. Users of the API see a 503 HTTP error.</p> <p>The timeout does ont apply when using the low-level DB access of the library. A timeout can be manually set, if required.</p>"},{"location":"customize/Settings/#nominatim_request_timeout","title":"NOMINATIM_REQUEST_TIMEOUT","text":"Summary Description: Timeout for search queries Format: number (seconds) Default: 60 Comment: Python frontend only <p>When this timeout is set, a search query will finish sending queries to the database after the timeout has passed and immediately return the results gathered so far.</p> <p>Note that under high load you may observe that users receive different results than usual without seeing an error. This may cause some confusion.</p>"},{"location":"customize/Settings/#logging-settings","title":"Logging Settings","text":""},{"location":"customize/Settings/#nominatim_log_db","title":"NOMINATIM_LOG_DB","text":"Summary Description: Log requests into the database Format: boolean Default: no After Changes: run <code>nominatim refresh --website</code> <p>Enable logging requests into a database table with this setting. The logs can be found in the table <code>new_query_log</code>.</p> <p>When using this logging method, it is advisable to set up a job that regularly clears out old logging information. Nominatim will not do that on its own.</p> <p>Can be used as the same time as NOMINATIM_LOG_FILE.</p>"},{"location":"customize/Settings/#nominatim_log_file","title":"NOMINATIM_LOG_FILE","text":"Summary Description: Log requests into a file Format: path Default: empty (logging disabled) After Changes: run <code>nominatim refresh --website</code> <p>Enable logging of requests into a file with this setting by setting the log file where to log to. A relative file name is assumed to be relative to the project directory.</p> <p>The entries in the log file have the following format:</p> <pre><code>&lt;request time&gt; &lt;execution time in s&gt; &lt;number of results&gt; &lt;type&gt; \"&lt;query string&gt;\"\n</code></pre> <p>Request time is the time when the request was started. The execution time is given in seconds and corresponds to the time the query took executing in PHP. type contains the name of the endpoint used.</p> <p>Can be used as the same time as NOMINATIM_LOG_DB.</p>"},{"location":"customize/Settings/#nominatim_debug_sql","title":"NOMINATIM_DEBUG_SQL","text":"Summary Description: Enable printing of raw SQL by SQLAlchemy Format: boolean Default: no Comment: For developers only. <p>This settings enables SQL debugging by SQLAlchemy. This can be helpful when debugging some bugs with internal query handling. It should only be used together with the CLI query functions. Enabling it for server mode may have unintended consequences. Use the <code>debug</code> parameter instead, which prints information on how the search is executed including SQL statements.</p>"},{"location":"customize/Special-Phrases/","title":"Special phrases","text":""},{"location":"customize/Special-Phrases/#importing-osm-user-maintained-special-phrases","title":"Importing OSM user-maintained special phrases","text":"<p>As described in the Import section, it is possible to import special phrases from the wiki with the following command:</p> <pre><code>nominatim special-phrases --import-from-wiki\n</code></pre>"},{"location":"customize/Special-Phrases/#importing-custom-special-phrases","title":"Importing custom special phrases","text":"<p>But, it is also possible to import some phrases from a csv file.  To do so, you have access to the following command:</p> <pre><code>nominatim special-phrases --import-from-csv &lt;csv file&gt;\n</code></pre> <p>Note that the two previous import commands will update the phrases from your database. This means that if you import some phrases from a csv file, only the phrases present in the csv file will be kept into the database. All other phrases will be removed.</p> <p>If you want to only add new phrases and not update the other ones you can add the argument <code>--no-replace</code> to the import command. For example:</p> <pre><code>nominatim special-phrases --import-from-csv &lt;csv file&gt; --no-replace\n</code></pre> <p>This will add the phrases present in the csv file into the database without removing the other ones.</p>"},{"location":"customize/Tiger/","title":"Installing TIGER housenumber data for the US","text":"<p>Nominatim is able to use the official TIGER address set to complement the OSM house number data in the US. You can add TIGER data to your own Nominatim instance by following these steps. The entire US adds about 10GB to your database.</p> <ol> <li> <p>Get preprocessed TIGER data:</p> <pre><code>cd $PROJECT_DIR\nwget https://nominatim.org/data/tiger-nominatim-preprocessed-latest.csv.tar.gz\n</code></pre> </li> <li> <p>Import the data into your Nominatim database:</p> <pre><code>nominatim add-data --tiger-data tiger-nominatim-preprocessed-latest.csv.tar.gz\n</code></pre> </li> <li> <p>Enable use of the Tiger data in your existing <code>.env</code> file by adding:</p> <pre><code>echo NOMINATIM_USE_US_TIGER_DATA=yes &gt;&gt; .env\n</code></pre> </li> <li> <p>Apply the new settings:</p> <pre><code>nominatim refresh --functions --website\n</code></pre> </li> </ol> <p>See the TIGER-data project for more information on how the data got preprocessed.</p>"},{"location":"customize/Tokenizers/","title":"Tokenizers","text":"<p>The tokenizer module in Nominatim is responsible for analysing the names given to OSM objects and the terms of an incoming query in order to make sure, they can be matched appropriately.</p> <p>Nominatim offers different tokenizer modules, which behave differently and have different configuration options. This sections describes the tokenizers and how they can be configured.</p> <p>Important</p> <p>The use of a tokenizer is tied to a database installation. You need to choose and configure the tokenizer before starting the initial import. Once the import is done, you cannot switch to another tokenizer anymore. Reconfiguring the chosen tokenizer is very limited as well. See the comments in each tokenizer section.</p>"},{"location":"customize/Tokenizers/#legacy-tokenizer","title":"Legacy tokenizer","text":"<p>The legacy tokenizer implements the analysis algorithms of older Nominatim versions. It uses a special Postgresql module to normalize names and queries. This tokenizer is automatically installed and used when upgrading an older database. It should not be used for new installations anymore.</p>"},{"location":"customize/Tokenizers/#compiling-the-postgresql-module","title":"Compiling the PostgreSQL module","text":"<p>The tokeinzer needs a special C module for PostgreSQL which is not compiled by default. If you need the legacy tokenizer, compile Nominatim as follows:</p> <pre><code>mkdir build\ncd build\ncmake -DBUILD_MODULE=on\nmake\n</code></pre>"},{"location":"customize/Tokenizers/#enabling-the-tokenizer","title":"Enabling the tokenizer","text":"<p>To enable the tokenizer add the following line to your project configuration:</p> <pre><code>NOMINATIM_TOKENIZER=legacy\n</code></pre> <p>The Postgresql module for the tokenizer is available in the <code>module</code> directory and also installed with the remainder of the software under <code>lib/nominatim/module/nominatim.so</code>. You can specify a custom location for the module with</p> <pre><code>NOMINATIM_DATABASE_MODULE_PATH=&lt;path to directory where nominatim.so resides&gt;\n</code></pre> <p>This is in particular useful when the database runs on a different server. See Advanced installations for details.</p> <p>There are no other configuration options for the legacy tokenizer. All normalization functions are hard-coded.</p>"},{"location":"customize/Tokenizers/#icu-tokenizer","title":"ICU tokenizer","text":"<p>The ICU tokenizer uses the ICU library to normalize names and queries. It also offers configurable decomposition and abbreviation handling. This tokenizer is currently the default.</p> <p>To enable the tokenizer add the following line to your project configuration:</p> <pre><code>NOMINATIM_TOKENIZER=icu\n</code></pre>"},{"location":"customize/Tokenizers/#how-it-works","title":"How it works","text":"<p>On import the tokenizer processes names in the following three stages:</p> <ol> <li>During the Sanitizer step incoming names are cleaned up and converted to    full names. This step can be used to regularize spelling, split multi-name    tags into their parts and tag names with additional attributes. See the    Sanitizers section below for available cleaning routines.</li> <li>The Normalization part removes all information from the full names    that are not relevant for search.</li> <li>The Token analysis step takes the normalized full names and creates    all transliterated variants under which the name should be searchable.    See the Token analysis section below for more    information.</li> </ol> <p>During query time, only normalization and transliteration are relevant. An incoming query is first split into name chunks (this usually means splitting the string at the commas) and the each part is normalised and transliterated. The result is used to look up places in the search index.</p>"},{"location":"customize/Tokenizers/#configuration","title":"Configuration","text":"<p>The ICU tokenizer is configured using a YAML file which can be configured using <code>NOMINATIM_TOKENIZER_CONFIG</code>. The configuration is read on import and then saved as part of the internal database status. Later changes to the variable have no effect.</p> <p>Here is an example configuration file:</p> <pre><code>normalization:\n    - \":: lower ()\"\n    - \"\u00df &gt; 'ss'\" # German szet is unambiguously equal to double ss\ntransliteration:\n    - !include /etc/nominatim/icu-rules/extended-unicode-to-asccii.yaml\n    - \":: Ascii ()\"\nsanitizers:\n    - step: split-name-list\ntoken-analysis:\n    - analyzer: generic\n      variants:\n          - !include icu-rules/variants-ca.yaml\n          - words:\n              - road -&gt; rd\n              - bridge -&gt; bdge,br,brdg,bri,brg\n      mutations:\n          - pattern: '\u00e4'\n            replacements: ['\u00e4', 'ae']\n</code></pre> <p>The configuration file contains four sections: <code>normalization</code>, <code>transliteration</code>, <code>sanitizers</code> and <code>token-analysis</code>.</p>"},{"location":"customize/Tokenizers/#normalization-and-transliteration","title":"Normalization and Transliteration","text":"<p>The normalization and transliteration sections each define a set of ICU rules that are applied to the names.</p> <p>The normalization rules are applied after sanitation. They should remove any information that is not relevant for search at all. Usual rules to be applied here are: lower-casing, removing of special characters, cleanup of spaces.</p> <p>The transliteration rules are applied at the end of the tokenization process to transfer the name into an ASCII representation. Transliteration can be useful to allow for further fuzzy matching, especially between different scripts.</p> <p>Each section must contain a list of ICU transformation rules. The rules are applied in the order in which they appear in the file. You can also include additional rules from external yaml file using the <code>!include</code> tag. The included file must contain a valid YAML list of ICU rules and may again include other files.</p> <p>Warning</p> <p>The ICU rule syntax contains special characters that conflict with the YAML syntax. You should therefore always enclose the ICU rules in double-quotes.</p>"},{"location":"customize/Tokenizers/#sanitizers","title":"Sanitizers","text":"<p>The sanitizers section defines an ordered list of functions that are applied to the name and address tags before they are further processed by the tokenizer. They allows to clean up the tagging and bring it to a standardized form more suitable for building the search index.</p> <p>Hint</p> <p>Sanitizers only have an effect on how the search index is built. They do not change the information about each place that is saved in the database. In particular, they have no influence on how the results are displayed. The returned results always show the original information as stored in the OpenStreetMap database.</p> <p>Each entry contains information of a sanitizer to be applied. It has a mandatory parameter <code>step</code> which gives the name of the sanitizer. Depending on the type, it may have additional parameters to configure its operation.</p> <p>The order of the list matters. The sanitizers are applied exactly in the order that is configured. Each sanitizer works on the results of the previous one.</p> <p>The following is a list of sanitizers that are shipped with Nominatim.</p>"},{"location":"customize/Tokenizers/#split-name-list","title":"split-name-list","text":"<p>Sanitizer that splits lists of names into their components.</p> PARAMETER DESCRIPTION <code>delimiters</code> <p>Define the set of characters to be used for         splitting the list. (default: ',;')</p> <p> </p>"},{"location":"customize/Tokenizers/#strip-brace-terms","title":"strip-brace-terms","text":"<p>This sanitizer creates additional name variants for names that have addendums in brackets (e.g. \"Halle (Saale)\"). The additional variant contains only the main name part with the bracket part removed.</p>"},{"location":"customize/Tokenizers/#tag-analyzer-by-language","title":"tag-analyzer-by-language","text":"<p>This sanitizer sets the <code>analyzer</code> property depending on the language of the tag. The language is taken from the suffix of the name. If a name already has an analyzer tagged, then this is kept.</p> <p>Arguments:</p> <pre><code>filter-kind: Restrict the names the sanitizer should be applied to\n             the given tags. The parameter expects a list of\n             regular expressions which are matched against 'kind'.\n             Note that a match against the full string is expected.\nwhitelist: Restrict the set of languages that should be tagged.\n           Expects a list of acceptable suffixes. When unset,\n           all 2- and 3-letter lower-case codes are accepted.\nuse-defaults:  Configure what happens when the name has no suffix.\n               When set to 'all', a variant is created for\n               each of the default languages in the country\n               the feature is in. When set to 'mono', a variant is\n               only created, when exactly one language is spoken\n               in the country. The default is to do nothing with\n               the default languages of a country.\nmode: Define how the variants are created and may be 'replace' or\n      'append'. When set to 'append' the original name (without\n      any analyzer tagged) is retained. (default: replace)\n</code></pre>"},{"location":"customize/Tokenizers/#clean-housenumbers","title":"clean-housenumbers","text":"<p>Sanitizer that preprocesses address tags for house numbers. The sanitizer allows to</p> <ul> <li>define which tags are to be considered house numbers (see 'filter-kind')</li> <li>split house number lists into individual numbers (see 'delimiters')</li> </ul> PARAMETER DESCRIPTION <code>delimiters</code> <p>Define the set of characters to be used for         splitting a list of house numbers into parts. (default: ',;')</p> <p> </p> <code>filter-kind</code> <p>Define the address tags that are considered to be a          house number. Either takes a single string or a list of strings,          where each string is a regular expression. An address item          is considered a house number if the 'kind' fully matches any          of the given regular expressions. (default: 'housenumber')</p> <p> </p> <code>convert-to-name</code> <p>Define house numbers that should be treated as a name              instead of a house number. Either takes a single string              or a list of strings, where each string is a regular              expression that must match the full house number value.</p> <p> </p>"},{"location":"customize/Tokenizers/#clean-postcodes","title":"clean-postcodes","text":"<p>Sanitizer that filters postcodes by their officially allowed pattern.</p> PARAMETER DESCRIPTION <code>convert-to-address</code> <p>If set to 'yes' (the default), then postcodes that do                 not conform with their country-specific pattern are                 converted to an address component. That means that                 the postcode does not take part when computing the                 postcode centroids of a country but is still searchable.                 When set to 'no', non-conforming postcodes are not                 searchable either.</p> <p> </p> <code>default-pattern</code> <p>Pattern to use, when there is none available for the                 country in question. Warning: will not be used for                 objects that have no country assigned. These are always                 assumed to have no postcode.</p> <p> </p>"},{"location":"customize/Tokenizers/#clean-tiger-tags","title":"clean-tiger-tags","text":"<p>Sanitizer that preprocesses tags from the TIGER import.</p> <p>It makes the following changes:</p> <ul> <li>remove state reference from tiger:county</li> </ul>"},{"location":"customize/Tokenizers/#delete-tags","title":"delete-tags","text":"<p>Sanitizer which prevents certain tags from getting into the search index. It remove tags which matches all properties given below.</p> PARAMETER DESCRIPTION <code>type</code> <p>Define which type of tags should be considered for removal.   There are two types of tags 'name' and 'address' tags.   Takes a string 'name' or 'address'. (default: 'name')</p> <p> </p> <code>filter-kind</code> <p>Define which 'kind' of tags should be removed.          Takes a string or list of strings where each          string is a regular expression. A tag is considered          to be a candidate for removal if its 'kind' property          fully matches any of the given regular expressions.          Note that by default all 'kind' of tags are considered.</p> <p> </p> <code>suffix</code> <p>Define the 'suffix' property of the tags which should be     removed. Takes a string or list of strings where each     string is a regular expression. A tag is considered to be a     candidate for removal if its 'suffix' property fully     matches any of the given regular expressions. Note that by     default tags with any suffix value are considered including     those which don't have a suffix at all.</p> <p> </p> <code>name</code> <p>Define the 'name' property corresponding to the 'kind' property   of the tag. Takes a string or list of strings where each string   is a regular expression. A tag is considered to be a candidate   for removal if its name fully matches any of the given regular   expressions. Note that by default tags with any 'name' are   considered.</p> <p> </p> <code>country_code</code> <p>Define the country code of places whose tags should be           considered for removed. Takes a string or list of strings           where each string is a two-letter lower-case country code.           Note that by default tags of places with any country code           are considered including those which don't have a country           code at all.</p> <p> </p> <code>rank_address</code> <p>Define the address rank of places whose tags should be           considered for removal. Takes a string or list of strings           where each string is a number or range of number or the           form -.           Note that default is '0-30', which means that tags of all           places are considered.           See https://nominatim.org/release-docs/latest/customize/Ranking/#address-rank           to learn more about address rank. <p> </p>"},{"location":"customize/Tokenizers/#tag-japanese","title":"tag-japanese","text":"<p>This sanitizer maps OSM data to Japanese block addresses. It replaces blocknumber and housenumber with housenumber, and quarter and neighbourhood with place.</p>"},{"location":"customize/Tokenizers/#token-analysis","title":"Token Analysis","text":"<p>Token analyzers take a full name and transform it into one or more normalized form that are then saved in the search index. In its simplest form, the analyzer only applies the transliteration rules. More complex analyzers create additional spelling variants of a name. This is useful to handle decomposition and abbreviation.</p> <p>The ICU tokenizer may use different analyzers for different names. To select the analyzer to be used, the name must be tagged with the <code>analyzer</code> attribute by a sanitizer (see for example the tag-analyzer-by-language sanitizer).</p> <p>The token-analysis section contains the list of configured analyzers. Each analyzer must have an <code>id</code> parameter that uniquely identifies the analyzer. The only exception is the default analyzer that is used when no special analyzer was selected. There are analysers with special ids:</p> <ul> <li>'@housenumber'. If an analyzer with that name is present, it is used    for normalization of house numbers.</li> <li>'@potcode'. If an analyzer with that name is present, it is used    for normalization of postcodes.</li> </ul> <p>Different analyzer implementations may exist. To select the implementation, the <code>analyzer</code> parameter must be set. The different implementations are described in the following.</p>"},{"location":"customize/Tokenizers/#generic-token-analyzer","title":"Generic token analyzer","text":"<p>The generic analyzer <code>generic</code> is able to create variants from a list of given abbreviation and decomposition replacements and introduce spelling variations.</p>"},{"location":"customize/Tokenizers/#variants","title":"Variants","text":"<p>The optional 'variants' section defines lists of replacements which create alternative spellings of a name. To create the variants, a name is scanned from left to right and the longest matching replacement is applied until the end of the string is reached.</p> <p>The variants section must contain a list of replacement groups. Each group defines a set of properties that describes where the replacements are applicable. In addition, the word section defines the list of replacements to be made. The basic replacement description is of the form:</p> <pre><code>&lt;source&gt;[,&lt;source&gt;[...]] =&gt; &lt;target&gt;[,&lt;target&gt;[...]]\n</code></pre> <p>The left side contains one or more <code>source</code> terms to be replaced. The right side lists one or more replacements. Each source is replaced with each replacement term.</p> <p>Tip</p> <p>The source and target terms are internally normalized using the normalization rules given in the configuration. This ensures that the strings match as expected. In fact, it is better to use unnormalized words in the configuration because then it is possible to change the rules for normalization later without having to adapt the variant rules.</p>"},{"location":"customize/Tokenizers/#decomposition","title":"Decomposition","text":"<p>In its standard form, only full words match against the source. There is a special notation to match the prefix and suffix of a word:</p> <pre><code>- ~strasse =&gt; str  # matches \"strasse\" as full word and in suffix position\n- hinter~ =&gt; hntr  # matches \"hinter\" as full word and in prefix position\n</code></pre> <p>There is no facility to match a string in the middle of the word. The suffix and prefix notation automatically trigger the decomposition mode: two variants are created for each replacement, one with the replacement attached to the word and one separate. So in above example, the tokenization of \"hauptstrasse\" will create the variants \"hauptstr\" and \"haupt str\". Similarly, the name \"rote strasse\" triggers the variants \"rote str\" and \"rotestr\". By having decomposition work both ways, it is sufficient to create the variants at index time. The variant rules are not applied at query time.</p> <p>To avoid automatic decomposition, use the '|' notation:</p> <pre><code>- ~strasse |=&gt; str\n</code></pre> <p>simply changes \"hauptstrasse\" to \"hauptstr\" and \"rote strasse\" to \"rote str\".</p>"},{"location":"customize/Tokenizers/#initial-and-final-terms","title":"Initial and final terms","text":"<p>It is also possible to restrict replacements to the beginning and end of a name:</p> <pre><code>- ^south =&gt; s  # matches only at the beginning of the name\n- road$ =&gt; rd  # matches only at the end of the name\n</code></pre> <p>So the first example would trigger a replacement for \"south 45th street\" but not for \"the south beach restaurant\".</p>"},{"location":"customize/Tokenizers/#replacements-vs-variants","title":"Replacements vs. variants","text":"<p>The replacement syntax <code>source =&gt; target</code> works as a pure replacement. It changes the name instead of creating a variant. To create an additional version, you'd have to write <code>source =&gt; source,target</code>. As this is a frequent case, there is a shortcut notation for it:</p> <pre><code>&lt;source&gt;[,&lt;source&gt;[...]] -&gt; &lt;target&gt;[,&lt;target&gt;[...]]\n</code></pre> <p>The simple arrow causes an additional variant to be added. Note that decomposition has an effect here on the source as well. So a rule</p> <pre><code>- \"~strasse -&gt; str\"\n</code></pre> <p>means that for a word like <code>hauptstrasse</code> four variants are created: <code>hauptstrasse</code>, <code>haupt strasse</code>, <code>hauptstr</code> and <code>haupt str</code>.</p>"},{"location":"customize/Tokenizers/#mutations","title":"Mutations","text":"<p>The 'mutation' section in the configuration describes an additional set of replacements to be applied after the variants have been computed.</p> <p>Each mutation is described by two parameters: <code>pattern</code> and <code>replacements</code>. The pattern must contain a single regular expression to search for in the variant name. The regular expressions need to follow the syntax for Python regular expressions. Capturing groups are not permitted. <code>replacements</code> must contain a list of strings that the pattern should be replaced with. Each occurrence of the pattern is replaced with all given replacements. Be mindful of combinatorial explosion of variants.</p>"},{"location":"customize/Tokenizers/#modes","title":"Modes","text":"<p>The generic analyser supports a special mode <code>variant-only</code>. When configured then it consumes the input token and emits only variants (if any exist). Enable the mode by adding:</p> <pre><code>  mode: variant-only\n</code></pre> <p>to the analyser configuration.</p>"},{"location":"customize/Tokenizers/#housenumber-token-analyzer","title":"Housenumber token analyzer","text":"<p>The analyzer <code>housenumbers</code> is purpose-made to analyze house numbers. It creates variants with optional spaces between numbers and letters. Thus, house numbers of the form '3 a', '3A', '3-A' etc. are all considered equivalent.</p> <p>The analyzer cannot be customized.</p>"},{"location":"customize/Tokenizers/#postcode-token-analyzer","title":"Postcode token analyzer","text":"<p>The analyzer <code>postcodes</code> is pupose-made to analyze postcodes. It supports a 'lookup' variant of the token, which produces variants with optional spaces. Use together with the clean-postcodes sanitizer.</p> <p>The analyzer cannot be customized.</p>"},{"location":"customize/Tokenizers/#reconfiguration","title":"Reconfiguration","text":"<p>Changing the configuration after the import is currently not possible, although this feature may be added at a later time.</p>"},{"location":"develop/Database-Layout/","title":"Database Layout","text":""},{"location":"develop/Database-Layout/#import-tables","title":"Import tables","text":"<p>OSM data is initially imported using osm2pgsql. Nominatim uses its own data output style 'gazetteer', which differs from the output style created for map rendering.</p> <p>The import process creates the following tables:</p> <p></p> <p>The <code>planet_osm_*</code> tables are the usual backing tables for OSM data. Note that Nominatim uses them to look up special relations and to find nodes on ways.</p> <p>The gazetteer style produces a single table <code>place</code> as output with the following columns:</p> <ul> <li><code>osm_type</code> - kind of OSM object (N - node, W - way, R - relation)</li> <li><code>osm_id</code> - original OSM ID</li> <li><code>class</code> - key of principal tag defining the object type</li> <li><code>type</code> - value of principal tag defining the object type</li> <li><code>name</code> - collection of tags that contain a name or reference</li> <li><code>admin_level</code> - numerical value of the tagged administrative level</li> <li><code>address</code> - collection of tags defining the address of an object</li> <li><code>extratags</code> - collection of additional interesting tags that are not                  directly relevant for searching</li> <li><code>geometry</code> - geometry of the object (in WGS84)</li> </ul> <p>A single OSM object may appear multiple times in this table when it is tagged with multiple tags that may constitute a principal tag. Take for example a motorway bridge. In OSM, this would be a way which is tagged with <code>highway=motorway</code> and <code>bridge=yes</code>. This way would appear in the <code>place</code> table once with <code>class</code> of <code>highway</code> and once with a <code>class</code> of <code>bridge</code>. Thus the unique key for <code>place</code> is (<code>osm_type</code>, <code>osm_id</code>, <code>class</code>).</p> <p>How raw OSM tags are mapped to the columns in the place table is to a certain degree configurable. See Customizing Import Styles for more information.</p>"},{"location":"develop/Database-Layout/#search-tables","title":"Search tables","text":"<p>The following tables carry all information needed to do the search:</p> <p></p> <p>The placex table is the central table that saves all information about the searchable places in Nominatim. The basic columns are the same as for the place table and have the same meaning. The placex tables adds the following additional columns:</p> <ul> <li><code>place_id</code> - the internal unique ID to identify the place</li> <li><code>partition</code> - the id to use with partitioned tables (see below)</li> <li><code>geometry_sector</code> - a location hash used for geographically close ordering</li> <li><code>parent_place_id</code> - the next higher place in the address hierarchy, only    relevant for POI-type places (with rank 30)</li> <li><code>linked_place_id</code> - place ID of the place this object has been merged with.    When this ID is set, then the place is invisible for search.</li> <li><code>importance</code> - measure how well known the place is</li> <li><code>rank_search</code>, <code>rank_address</code> - search and address rank (see Customizing ranking</li> <li><code>wikipedia</code> - the wikipedia page used for computing the importance of the place</li> <li><code>country_code</code> - the country the place is located in</li> <li><code>housenumber</code> - normalized housenumber, if the place has one</li> <li><code>postcode</code> - computed postcode for the place</li> <li><code>indexed_status</code> - processing status of the place (0 - ready, 1 - freshly inserted, 2 - needs updating, 100 - needs deletion)</li> <li><code>indexed_date</code> - timestamp when the place was processed last</li> <li><code>centroid</code> - a point feature for the place</li> </ul> <p>The location_property_osmline table is a special table for address interpolations. The columns have the same meaning and use as the columns with the same name in the placex table. Only three columns are special:</p> <ul> <li><code>startnumber</code> and <code>endnumber</code> - beginning and end of the number range     for the interpolation</li> <li><code>interpolationtype</code> - a string <code>odd</code>, <code>even</code> or <code>all</code> to indicate     the interval between the numbers</li> </ul> <p>Address interpolations are always ways in OSM, which is why there is no column <code>osm_type</code>.</p> <p>The location_postcode table holds computed centroids of all postcodes that can be found in the OSM data. The meaning of the columns is again the same as that of the placex table.</p> <p>Every place needs an address, a set of surrounding places that describe the location of the place. The set of address places is made up of OSM places themselves. The place_addressline table cross-references for each place all the places that make up its address. Two columns define the address relation:</p> <ul> <li><code>place_id</code> - reference to the place being addressed</li> <li><code>address_place_id</code> - reference to the place serving as an address part</li> </ul> <p>The most of the columns cache information from the placex entry of the address part. The exceptions are:</p> <ul> <li><code>fromarea</code> - is true if the address part has an area geometry and can     therefore be considered preceise</li> <li><code>isaddress</code> - is true if the address part should show up in the address     output. Sometimes there are multiple places competing for for same address     type (e.g. multiple cities) and this field resolves the tie.</li> </ul> <p>The search_name table contains the search index proper. It saves for each place the terms with which the place can be found. The terms are split into the name itself and all terms that make up the address. The table mirrors some of the columns from placex for faster lookup.</p> <p>Search terms are not saved as strings. Each term is assigned an integer and those integers are saved in the name and address vectors of the search_name table. The word table serves as the lookup table from string to such a word ID. The exact content of the word table depends on the tokenizer used.</p>"},{"location":"develop/Database-Layout/#address-computation-tables","title":"Address computation tables","text":"<p>Next to the main search tables, there is a set of secondary helper tables used to compute the address relations between places. These tables are partitioned. Each country is assigned a partition number in the country_name table (see below) and the data is then split between a set of tables, one for each partition. Note that Nominatim still manually manages partitioned tables. Native support for partitions in PostgreSQL only became usable with version 13. It will be a little while before Nominatim drops support for older versions.</p> <p></p> <p>The search_name_X tables are used to look up streets that appear in the <code>addr:street</code> tag.</p> <p>The location_area_large_X tables are used to look up larger areas (administrative boundaries and place nodes) either through their geographic closeness or through <code>addr:*</code> entries.</p> <p>The location_road_X tables are used to find the closest street for a dependent place.</p> <p>All three table cache specific information from the placex table for their selected subset of places:</p> <ul> <li><code>keywords</code> and <code>name_vector</code> contain lists of term ids (from the word table)    that the full name of the place should match against</li> <li><code>isguess</code> is true for places that are not described by an area</li> </ul> <p>All other columns reflect their counterpart in the placex table.</p>"},{"location":"develop/Database-Layout/#static-data-tables","title":"Static data tables","text":"<p>Nominatim also creates a number of static tables at import:</p> <ul> <li><code>nominatim_properties</code> saves settings that must not be changed after     import</li> <li><code>address_levels</code> save the rank information from the    ranking configuration</li> <li><code>country_name</code> contains a fallback of names for all countries, their    default languages and saves the assignment of countries to partitions.</li> <li><code>country_osm_grid</code> provides a fallback for country geometries</li> </ul>"},{"location":"develop/Database-Layout/#auxiliary-data-tables","title":"Auxiliary data tables","text":"<p>Finally there are some table for auxiliary data:</p> <ul> <li><code>location_property_tiger</code> - saves housenumber from the Tiger import. Its    layout is similar to that of <code>location_propoerty_osmline</code>.</li> <li><code>place_class_*</code> tables are helper tables to facilitate lookup of POIs    by their class and type. They exist because it is not possible to create    combined indexes with geometries.</li> </ul>"},{"location":"develop/Development-Environment/","title":"Setting up Nominatim for Development","text":"<p>This chapter gives an overview how to set up Nominatim for development and how to run tests.</p> <p>Important</p> <p>This guide assumes that you develop under the latest version of Ubuntu. You can of course also use your favourite distribution. You just might have to adapt the commands below slightly, in particular the commands for installing additional software.</p>"},{"location":"develop/Development-Environment/#installing-nominatim","title":"Installing Nominatim","text":"<p>The first step is to install Nominatim itself. Please follow the installation instructions in the Admin section. You don't need to set up a webserver for development, the webserver that is included with PHP is sufficient.</p> <p>If you want to run Nominatim in a VM via Vagrant, use the default <code>ubuntu</code> setup. Vagrant's libvirt provider runs out-of-the-box under Ubuntu. You also need to install an NFS daemon to enable directory sharing between host and guest. The following packages should get you started:</p> <pre><code>sudo apt install vagrant vagrant-libvirt libvirt-daemon nfs-kernel-server\n</code></pre>"},{"location":"develop/Development-Environment/#prerequisites-for-testing-and-documentation","title":"Prerequisites for testing and documentation","text":"<p>The Nominatim test suite consists of behavioural tests (using behave) and unit tests (using PHPUnit for PHP code and pytest for Python code). It has the following additional requirements:</p> <ul> <li>behave test framework &gt;= 1.2.6</li> <li>phpunit (9.5 is known to work)</li> <li>PHP CodeSniffer</li> <li>Pylint (CI always runs the latest version from pip)</li> <li>mypy (plus typing information for external libs)</li> <li>Python Typing Extensions (for Python &lt; 3.9)</li> <li>pytest</li> <li>pytest-asyncio</li> </ul> <p>For testing the Python search frontend, you need to install extra dependencies depending on your choice of webserver framework:</p> <ul> <li>httpx (starlette only)</li> <li>asgi-lifespan (starlette only)</li> </ul> <p>The documentation is built with mkdocs:</p> <ul> <li>mkdocs &gt;= 1.1.2</li> <li>mkdocstrings &gt;= 0.18</li> <li>mkdocstrings-python</li> </ul>"},{"location":"develop/Development-Environment/#installing-prerequisites-on-ubuntudebian","title":"Installing prerequisites on Ubuntu/Debian","text":"<p>Some of the Python packages require the newest version which is not yet available with the current distributions. Therefore it is recommended to install pip to get the newest versions.</p> <p>To install all necessary packages run:</p> <pre><code>sudo apt install php-cgi phpunit php-codesniffer \\\n                 python3-pip python3-setuptools python3-dev\n\npip3 install --user behave mkdocs mkdocstrings pytest pytest-asyncio pylint \\\n                    mypy types-PyYAML types-jinja2 types-psycopg2 types-psutil \\\n                    types-ujson types-requests types-Pygments typing-extensions\\\n                    httpx asgi-lifespan\n</code></pre> <p>The <code>mkdocs</code> executable will be located in <code>.local/bin</code>. You may have to add this directory to your path, for example by running:</p> <pre><code>echo 'export PATH=~/.local/bin:$PATH' &gt; ~/.profile\n</code></pre> <p>If your distribution does not have PHPUnit 7.3+, you can install it (as well as CodeSniffer) via composer:</p> <pre><code>sudo apt-get install composer\ncomposer global require \"squizlabs/php_codesniffer=*\"\ncomposer global require \"phpunit/phpunit=8.*\"\n</code></pre> <p>The binaries are found in <code>.config/composer/vendor/bin</code>. You need to add this to your PATH as well:</p> <pre><code>echo 'export PATH=~/.config/composer/vendor/bin:$PATH' &gt; ~/.profile\n</code></pre>"},{"location":"develop/Development-Environment/#executing-tests","title":"Executing Tests","text":"<p>All tests are located in the <code>/test</code> directory.</p> <p>To run all tests just go to the build directory and run make:</p> <pre><code>cd build\nmake test\n</code></pre> <p>For more information about the structure of the tests and how to change and extend the test suite, see the Testing chapter.</p>"},{"location":"develop/Development-Environment/#documentation-pages","title":"Documentation Pages","text":"<p>The Nominatim documentation is built using the MkDocs static site generation framework. The master branch is automatically deployed every night on https://nominatim.org/release-docs/develop/</p> <p>To build the documentation, go to the build directory and run</p> <pre><code>make doc\nINFO - Cleaning site directory\nINFO - Building documentation to directory: /home/vagrant/build/site-html\n</code></pre> <p>This runs <code>mkdocs build</code> plus extra transformation of some files and adds symlinks (see <code>CMakeLists.txt</code> for the exact steps).</p> <p>Now you can start webserver for local testing</p> <pre><code>build&gt; make serve-doc\n[server:296] Serving on http://127.0.0.1:8000\n[handlers:62] Start watching changes\n</code></pre> <p>If you develop inside a Vagrant virtual machine, use a port that is forwarded to your host:</p> <pre><code>build&gt; PYTHONPATH=$SRCDIR mkdocs serve --dev-addr 0.0.0.0:8088\n[server:296] Serving on http://0.0.0.0:8088\n[handlers:62] Start watching changes\n</code></pre>"},{"location":"develop/ICU-Tokenizer-Modules/","title":"Writing custom sanitizer and token analysis modules for the ICU tokenizer","text":"<p>The ICU tokenizer provides a highly customizable method to pre-process and normalize the name information of the input data before it is added to the search index. It comes with a selection of sanitizers and token analyzers which you can use to adapt your installation to your needs. If the provided modules are not enough, you can also provide your own implementations. This section describes the API of sanitizers and token analysis.</p> <p>Warning</p> <p>This API is currently in early alpha status. While this API is meant to be a public API on which other sanitizers and token analyzers may be implemented, it is not guaranteed to be stable at the moment.</p>"},{"location":"develop/ICU-Tokenizer-Modules/#using-non-standard-sanitizers-and-token-analyzers","title":"Using non-standard sanitizers and token analyzers","text":"<p>Sanitizer names (in the <code>step</code> property) and token analysis names (in the <code>analyzer</code>) may refer to externally supplied modules. There are two ways to include external modules: through a library or from the project directory.</p> <p>To include a module from a library, use the absolute import path as name and make sure the library can be found in your PYTHONPATH.</p> <p>To use a custom module without creating a library, you can put the module somewhere in your project directory and then use the relative path to the file. Include the whole name of the file including the <code>.py</code> ending.</p>"},{"location":"develop/ICU-Tokenizer-Modules/#custom-sanitizer-modules","title":"Custom sanitizer modules","text":"<p>A sanitizer module must export a single factory function <code>create</code> with the following signature:</p> <pre><code>def create(config: SanitizerConfig) -&gt; Callable[[ProcessInfo], None]\n</code></pre> <p>The function receives the custom configuration for the sanitizer and must return a callable (function or class) that transforms the name and address terms of a place. When a place is processed, then a <code>ProcessInfo</code> object is created from the information that was queried from the database. This object is sequentially handed to each configured sanitizer, so that each sanitizer receives the result of processing from the previous sanitizer. After the last sanitizer is finished, the resulting name and address lists are forwarded to the token analysis module.</p> <p>Sanitizer functions are instantiated once and then called for each place that is imported or updated. They don't need to be thread-safe. If multi-threading is used, each thread creates their own instance of the function.</p>"},{"location":"develop/ICU-Tokenizer-Modules/#sanitizer-configuration","title":"Sanitizer configuration","text":"<p>The <code>SanitizerConfig</code> class is a read-only dictionary with configuration options for the sanitizer. In addition to the usual dictionary functions, the class provides accessors to standard sanitizer options that are used by many of the sanitizers.</p>"},{"location":"develop/ICU-Tokenizer-Modules/#nominatim.tokenizer.sanitizers.config.SanitizerConfig.get_bool","title":"<code>get_bool(param, default=None)</code>","text":"<p>Extract a configuration parameter as a boolean.</p> <p>Parameters:</p> Name Type Description Default <code>param</code> <code>str</code> <p>Name of the configuration parameter. The parameter must    contain one of the yaml boolean values or an    UsageError will be raised.</p> required <code>default</code> <code>Optional[bool]</code> <p>Value to return, when the parameter is missing.      When set to <code>None</code>, the parameter must be defined.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>Boolean value of the given parameter.</p>"},{"location":"develop/ICU-Tokenizer-Modules/#nominatim.tokenizer.sanitizers.config.SanitizerConfig.get_delimiter","title":"<code>get_delimiter(default=',;')</code>","text":"<p>Return the 'delimiters' parameter in the configuration as a compiled regular expression that can be used to split strings on these delimiters.</p> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>str</code> <p>Delimiters to be used when 'delimiters' parameter      is not explicitly configured.</p> <code>',;'</code> <p>Returns:</p> Type Description <code>Pattern[str]</code> <p>A regular expression pattern which can be used to split a string. The regular expression makes sure that the resulting names are stripped and that repeated delimiters are ignored. It may still create empty fields on occasion. The code needs to filter those.</p>"},{"location":"develop/ICU-Tokenizer-Modules/#nominatim.tokenizer.sanitizers.config.SanitizerConfig.get_filter","title":"<code>get_filter(param, default='PASS_ALL')</code>","text":"<p>Returns a filter function for the given parameter of the sanitizer configuration.</p> <p>The value provided for the parameter in sanitizer configuration should be a string or list of strings, where each string is a regular expression. These regular expressions will later be used by the filter function to filter strings.</p> <p>Parameters:</p> Name Type Description Default <code>param</code> <code>str</code> <p>The parameter for which the filter function    will be created.</p> required <code>default</code> <code>Union[str, Sequence[str]]</code> <p>Defines the behaviour of filter function if      parameter is missing in the sanitizer configuration.      Takes a string(PASS_ALL or FAIL_ALL) or a list of strings.      Any other value of string or an empty list is not allowed,      and will raise a ValueError. If the value is PASS_ALL, the filter      function will let all strings to pass, if the value is FAIL_ALL,      filter function will let no strings to pass.      If value provided is a list of strings each string      is treated as a regular expression. In this case these regular      expressions will be used by the filter function.      By default allow filter function to let all strings pass.</p> <code>'PASS_ALL'</code> <p>Returns:</p> Type Description <code>Callable[[str], bool]</code> <p>A filter function that takes a target string as the argument and returns True if it fully matches any of the regular expressions otherwise returns False.</p>"},{"location":"develop/ICU-Tokenizer-Modules/#nominatim.tokenizer.sanitizers.config.SanitizerConfig.get_string_list","title":"<code>get_string_list(param, default=tuple())</code>","text":"<p>Extract a configuration parameter as a string list.</p> <p>Parameters:</p> Name Type Description Default <code>param</code> <code>str</code> <p>Name of the configuration parameter.</p> required <code>default</code> <code>Sequence[str]</code> <p>Takes a tuple or list of strings which will      be returned if the parameter is missing in the      sanitizer configuration.      Note that if this default parameter is not      provided then an empty list is returned.</p> <code>tuple()</code> <p>Returns:</p> Type Description <code>Sequence[str]</code> <p>If the parameter value is a simple string, it is returned as a one-item list. If the parameter value does not exist, the given default is returned. If the parameter value is a list, it is checked to contain only strings before being returned.</p>"},{"location":"develop/ICU-Tokenizer-Modules/#the-main-filter-function-of-the-sanitizer","title":"The main filter function of the sanitizer","text":"<p>The filter function receives a single object of type <code>ProcessInfo</code> which has with three members:</p> <ul> <li><code>place: PlaceInfo</code>: read-only information about the place being processed.    See PlaceInfo below.</li> <li><code>names: List[PlaceName]</code>: The current list of names for the place.</li> <li><code>address: List[PlaceName]</code>: The current list of address names for the place.</li> </ul> <p>While the <code>place</code> member is provided for information only, the <code>names</code> and <code>address</code> lists are meant to be manipulated by the sanitizer. It may add and remove entries, change information within a single entry (for example by adding extra attributes) or completely replace the list with a different one.</p>"},{"location":"develop/ICU-Tokenizer-Modules/#placeinfo-information-about-the-place","title":"PlaceInfo - information about the place","text":"<p>This data class contains all information the tokenizer can access about a place.</p>"},{"location":"develop/ICU-Tokenizer-Modules/#nominatim.data.place_info.PlaceInfo.address","title":"<code>address: Optional[Mapping[str, str]]</code>  <code>property</code>","text":"<p>A dictionary with the address elements of the place. They key usually corresponds to the suffix part of the key of an OSM 'addr:' or 'isin:' tag. There are also some special keys like <code>country</code> or <code>country_code</code> which merge OSM keys that contain the same information. See Import Styles for details.</p> <p>The property may be None if the place has no address information.</p>"},{"location":"develop/ICU-Tokenizer-Modules/#nominatim.data.place_info.PlaceInfo.centroid","title":"<code>centroid: Optional[Tuple[float, float]]</code>  <code>property</code>","text":"<p>A center point of the place in WGS84. May be None when the geometry of the place is unknown.</p>"},{"location":"develop/ICU-Tokenizer-Modules/#nominatim.data.place_info.PlaceInfo.country_code","title":"<code>country_code: Optional[str]</code>  <code>property</code>","text":"<p>The country code of the country the place is in. Guaranteed to be a two-letter lower-case string. If the place is not inside any country, the property is set to None.</p>"},{"location":"develop/ICU-Tokenizer-Modules/#nominatim.data.place_info.PlaceInfo.name","title":"<code>name: Optional[Mapping[str, str]]</code>  <code>property</code>","text":"<p>A dictionary with the names of the place. Keys and values represent the full key and value of the corresponding OSM tag. Which tags are saved as names is determined by the import style. The property may be None if the place has no names.</p>"},{"location":"develop/ICU-Tokenizer-Modules/#nominatim.data.place_info.PlaceInfo.rank_address","title":"<code>rank_address: int</code>  <code>property</code>","text":"<p>The rank address before any rank correction is applied.</p>"},{"location":"develop/ICU-Tokenizer-Modules/#nominatim.data.place_info.PlaceInfo.is_a","title":"<code>is_a(key, value)</code>","text":"<p>Set to True when the place's primary tag corresponds to the given key and value.</p>"},{"location":"develop/ICU-Tokenizer-Modules/#nominatim.data.place_info.PlaceInfo.is_country","title":"<code>is_country()</code>","text":"<p>Set to True when the place is a valid country boundary.</p>"},{"location":"develop/ICU-Tokenizer-Modules/#placename-extended-naming-information","title":"PlaceName - extended naming information","text":"<p>Each name and address part of a place is encapsulated in an object of this class. It saves not only the name proper but also describes the kind of name with two properties:</p> <ul> <li><code>kind</code> describes the name of the OSM key used without any suffixes   (i.e. the part after the colon removed)</li> <li><code>suffix</code> contains the suffix of the OSM tag, if any. The suffix   is the part of the key after the first colon.</li> </ul> <p>In addition to that, a name may have arbitrary additional attributes. How attributes are used, depends on the sanitizers and token analysers. The exception is the 'analyzer' attribute. This attribute determines which token analysis module will be used to finalize the treatment of names.</p>"},{"location":"develop/ICU-Tokenizer-Modules/#nominatim.data.place_name.PlaceName.clone","title":"<code>clone(name=None, kind=None, suffix=None, attr=None)</code>","text":"<p>Create a deep copy of the place name, optionally with the given parameters replaced. In the attribute list only the given keys are updated. The list is not replaced completely. In particular, the function cannot to be used to remove an attribute from a place name.</p>"},{"location":"develop/ICU-Tokenizer-Modules/#nominatim.data.place_name.PlaceName.get_attr","title":"<code>get_attr(key, default=None)</code>","text":"<p>Return the given property or the value of 'default' if it is not set.</p>"},{"location":"develop/ICU-Tokenizer-Modules/#nominatim.data.place_name.PlaceName.has_attr","title":"<code>has_attr(key)</code>","text":"<p>Check if the given attribute is set.</p>"},{"location":"develop/ICU-Tokenizer-Modules/#nominatim.data.place_name.PlaceName.set_attr","title":"<code>set_attr(key, value)</code>","text":"<p>Add the given property to the name. If the property was already set, then the value is overwritten.</p>"},{"location":"develop/ICU-Tokenizer-Modules/#example-filter-for-us-street-prefixes","title":"Example: Filter for US street prefixes","text":"<p>The following sanitizer removes the directional prefixes from street names in the US:</p> <pre><code>import re\n\ndef _filter_function(obj):\n    if obj.place.country_code == 'us' \\\n       and obj.place.rank_address &gt;= 26 and obj.place.rank_address &lt;= 27:\n        for name in obj.names:\n            name.name = re.sub(r'^(north|south|west|east) ',\n                               '',\n                               name.name,\n                               flags=re.IGNORECASE)\n\ndef create(config):\n    return _filter_function\n</code></pre> <p>This is the most simple form of a sanitizer module. If defines a single filter function and implements the required <code>create()</code> function by returning the filter.</p> <p>The filter function first checks if the object is interesting for the sanitizer. Namely it checks if the place is in the US (through <code>country_code</code>) and it the place is a street (a <code>rank_address</code> of 26 or 27). If the conditions are met, then it goes through all available names and removes any leading directional prefix using a simple regular expression.</p> <p>Save the source code in a file in your project directory, for example as <code>us_streets.py</code>. Then you can use the sanitizer in your <code>icu_tokenizer.yaml</code>:</p> <pre><code>...\nsanitizers:\n    - step: us_streets.py\n...\n</code></pre> <p>Warning</p> <p>This example is just a simplified show case on how to create a sanitizer. It is not really read for real-world use: while the sanitizer would correctly transform <code>West 5th Street</code> into <code>5th Street</code>. it would also shorten a simple <code>North Street</code> to <code>Street</code>.</p> <p>For more sanitizer examples, have a look at the sanitizers provided by Nominatim. They can be found in the directory <code>nominatim/tokenizer/sanitizers</code>.</p>"},{"location":"develop/ICU-Tokenizer-Modules/#custom-token-analysis-module","title":"Custom token analysis module","text":"<p>The setup of the token analysis is split into two parts: configuration and analyser factory. A token analysis module must therefore implement the two functions here described.</p> <p>The <code>create()</code> function of an analysis module needs to return an object that implements the following functions.</p>"},{"location":"develop/ICU-Tokenizer-Modules/#nominatim.tokenizer.token_analysis.base.AnalysisModule.configure","title":"<code>configure(rules, normalizer, transliterator)</code>","text":"<p>Prepare the configuration of the analysis module. This function should prepare all data that can be shared between instances of this analyser.</p> <p>Parameters:</p> Name Type Description Default <code>rules</code> <code>Mapping[str, Any]</code> <p>A dictionary with the additional configuration options    as specified in the tokenizer configuration.</p> required <code>normalizer</code> <code>Any</code> <p>an ICU Transliterator with the compiled         global normalization rules.</p> required <code>transliterator</code> <code>Any</code> <p>an ICU Transliterator with the compiled             global transliteration rules.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>A data object with configuration data. This will be handed as is into the <code>create()</code> function and may be used freely by the analysis module as needed.</p>"},{"location":"develop/ICU-Tokenizer-Modules/#nominatim.tokenizer.token_analysis.base.AnalysisModule.create","title":"<code>create(normalizer, transliterator, config)</code>","text":"<p>Create a new instance of the analyser. A separate instance of the analyser is created for each thread when used in multi-threading context.</p> <p>Parameters:</p> Name Type Description Default <code>normalizer</code> <code>Any</code> <p>an ICU Transliterator with the compiled normalization         rules.</p> required <code>transliterator</code> <code>Any</code> <p>an ICU Transliterator with the compiled             transliteration rules.</p> required <code>config</code> <code>Any</code> <p>The object that was returned by the call to configure().</p> required <p>Returns:</p> Type Description <code>Analyzer</code> <p>A new analyzer instance. This must be an object that implements the Analyzer protocol.</p>"},{"location":"develop/ICU-Tokenizer-Modules/#nominatim.tokenizer.token_analysis.base.Analyzer.compute_variants","title":"<code>compute_variants(canonical_id)</code>","text":"<p>Compute the transliterated spelling variants for the given canonical ID.</p> <p>Parameters:</p> Name Type Description Default <code>canonical_id</code> <code>str</code> <p>ID string previously computed with           <code>get_canonical_id()</code>.</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>A list of possible spelling variants. All strings must have been transformed with the global normalizer and transliterator ICU rules. Otherwise they cannot be matched against the input by the query frontend. The list may be empty, when there are no useful spelling variants. This may happen when an analyzer only usually outputs additional variants to the canonical spelling and there are no such variants.</p>"},{"location":"develop/ICU-Tokenizer-Modules/#nominatim.tokenizer.token_analysis.base.Analyzer.get_canonical_id","title":"<code>get_canonical_id(name)</code>","text":"<p>Return the canonical form of the given name. The canonical ID must be unique (the same ID must always yield the same variants) and must be a form from which the variants can be derived.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>PlaceName</code> <p>Extended place name description as prepared by   the sanitizers.</p> required <p>Returns:</p> Type Description <code>str</code> <p>ID string with a canonical form of the name. The string may be empty, when the analyzer cannot analyze the name at all, for example because the character set in use does not match.</p>"},{"location":"develop/ICU-Tokenizer-Modules/#example-creating-acronym-variants-for-long-names","title":"Example: Creating acronym variants for long names","text":"<p>The following example of a token analysis module creates acronyms from very long names and adds them as a variant:</p> <pre><code>class AcronymMaker:\n    \"\"\" This class is the actual analyzer.\n    \"\"\"\n    def __init__(self, norm, trans):\n        self.norm = norm\n        self.trans = trans\n\n\n    def get_canonical_id(self, name):\n        # In simple cases, the normalized name can be used as a canonical id.\n        return self.norm.transliterate(name.name).strip()\n\n\n    def compute_variants(self, name):\n        # The transliterated form of the name always makes up a variant.\n        variants = [self.trans.transliterate(name)]\n\n        # Only create acronyms from very long words.\n        if len(name) &gt; 20:\n            # Take the first letter from each word to form the acronym.\n            acronym = ''.join(w[0] for w in name.split())\n            # If that leds to an acronym with at least three letters,\n            # add the resulting acronym as a variant.\n            if len(acronym) &gt; 2:\n                # Never forget to transliterate the variants before returning them.\n                variants.append(self.trans.transliterate(acronym))\n\n        return variants\n\n# The following two functions are the module interface.\n\ndef configure(rules, normalizer, transliterator):\n    # There is no configuration to parse and no data to set up.\n    # Just return an empty configuration.\n    return None\n\n\ndef create(normalizer, transliterator, config):\n    # Return a new instance of our token analysis class above.\n    return AcronymMaker(normalizer, transliterator)\n</code></pre> <p>Given the name <code>Trans-Siberian Railway</code>, the code above would return the full name <code>Trans-Siberian Railway</code> and the acronym <code>TSR</code> as variant, so that searching would work for both.</p>"},{"location":"develop/ICU-Tokenizer-Modules/#sanitizers-vs-token-analysis-what-to-use-for-variants","title":"Sanitizers vs. Token analysis - what to use for variants?","text":"<p>It is not always clear when to implement variations in the sanitizer and when to write a token analysis module. Just take the acronym example above: it would also have been possible to write a sanitizer which adds the acronym as an additional name to the name list. The result would have been similar. So which should be used when?</p> <p>The most important thing to keep in mind is that variants created by the token analysis are only saved in the word lookup table. They do not need extra space in the search index. If there are many spelling variations, this can mean quite a significant amount of space is saved.</p> <p>When creating additional names with a sanitizer, these names are completely independent. In particular, they can be fed into different token analysis modules. This gives a much greater flexibility but at the price that the additional names increase the size of the search index.</p>"},{"location":"develop/Indexing/","title":"Indexing Places","text":"<p>In Nominatim, the word indexing refers to the process that takes the raw OpenStreetMap data from the place table, enriches it with address information and creates the search indexes. This section explains the basic data flow.</p>"},{"location":"develop/Indexing/#initial-import","title":"Initial import","text":"<p>After osm2pgsql has loaded the raw OSM data into the place table, the data is copied to the final search tables placex and location_property_osmline. While they are copied, some basic properties are added:</p> <ul> <li>country_code, geometry_sector and partition</li> <li>initial search and address rank</li> </ul> <p>In addition the column <code>indexed_status</code> is set to <code>1</code> marking the place as one that needs to be indexed.</p> <p>All this happens in the triggers <code>placex_insert</code> and <code>osmline_insert</code>.</p>"},{"location":"develop/Indexing/#indexing","title":"Indexing","text":"<p>The main work horse of the data import is the indexing step, where Nominatim takes every place from the placex and location_property_osmline tables where the indexed_status != 0 and computes the search terms and the address parts of the place.</p> <p>The indexing happens in three major steps:</p> <ol> <li> <p>Data preparation - The indexer gets the data for the place to be indexed    from the database.</p> </li> <li> <p>Search name processing - The prepared data is given to the    tokenizer which computes the search terms from the names    and potentially other information.</p> </li> <li> <p>Address processing - The indexer then hands the prepared data and the    tokenizer information back to the database via an <code>INSERT</code> statement which    also sets the indexed_status to <code>0</code>. This triggers the update triggers    <code>placex_update</code>/<code>osmline_update</code> which do the work of computing address    parts and filling all the search tables.</p> </li> </ol> <p>When computing the address terms of a place, Nominatim relies on the processed search names of all the address parts. That is why places are processed in rank order, from smallest rank to largest. To ensure correct handling of linked place nodes, administrative boundaries are processed before all other places.</p> <p>Apart from these restrictions, each place can be indexed independently from the others. This allows a large degree of parallelization during the indexing. It also means that the indexing process can be interrupted at any time and will simply pick up where it left of when restarted.</p>"},{"location":"develop/Indexing/#data-preparation","title":"Data preparation","text":"<p>The data preparation step computes and retrieves all data for a place that might be needed for the next step of processing the search name. That includes</p> <ul> <li>location information (country code)</li> <li>place classification (class, type, ranks)</li> <li>names (including names of linked places)</li> <li>address information (<code>addr:*</code> tags)</li> </ul> <p>Data preparation is implemented in pl/PgSQL mostly in the functions <code>placex_indexing_prepare()</code> and <code>get_interpolation_address()</code>.</p>"},{"location":"develop/Indexing/#addr-tag-inheritance","title":"<code>addr:*</code> tag inheritance","text":"<p>Nominatim has limited support for inheriting address tags from a building to POIs inside the building. This only works when the address tags are on the building outline. Any rank 30 object inside such a building or on its outline inherits all address tags when it does not have any address tags of its own.</p> <p>The inheritance is computed in the data preparation step.</p>"},{"location":"develop/Indexing/#search-name-processing","title":"Search name processing","text":"<p>The prepared place information is handed to the tokenizer next. This is a Python module responsible for processing the names  from both name and address terms and building up the word index from them. The process is explained in more detail in the Tokenizer chapter.</p>"},{"location":"develop/Indexing/#address-processing","title":"Address processing","text":"<p>Finally, the preprocessed place information and the results of the search name processing are written back to the database. At this point the update trigger of the placex/location_property_osmline tables take over and fill all the dependent tables. This makes up the most work-intensive part of the indexing.</p> <p>Nominatim distinguishes between dependent and independent places. Dependent places are all places on rank 30: house numbers, POIs etc. These places don't have a full address of their own. Instead they are attached to a parent street or place and use the information of the parent for searching and displaying information. Everything else are independent places: streets, parks, water bodies, suburbs, cities, states etc.  They receive a full address on their own.</p> <p>The address processing for both types of places is very different.</p>"},{"location":"develop/Indexing/#independent-places","title":"Independent places","text":"<p>To compute the address of an independent place Nominatim searches for all places that cover the place to compute the address for at least partially. For places with an area, that area is used to check for coverage. For place nodes an artificial square area is computed according to the rank of the place. The lower the rank the lager the area. The <code>location_area_large_X</code> tables are there to facilitate the lookup. All places that can function as the address of another place are saved in those tables.</p> <p><code>addr:*</code> and <code>isin:*</code> tags are taken into account to compute the address, too. Nominatim will give preference to places with the same name as in these tags when looking for places in the vicinity. If there are no matching place names at all, then the tags are at least added to the search index. That means that the names will not be shown in the result as the 'address' of the place, but searching by them still works.</p> <p>Independent places are always added to the global search index <code>search_name</code>.</p>"},{"location":"develop/Indexing/#dependent-places","title":"Dependent places","text":"<p>Dependent places skip the full address computation for performance reasons. Instead they just find a parent place to attach themselves to.</p> <p></p> <p>By default a POI or house number will be attached to the closest street. That can be any major or minor street indexed by Nominatim. In the default configuration that means that it can attach itself to a footway but only when it has a name.</p> <p>When the dependent place has an <code>addr:street</code> tag, then Nominatim will first try to find a street with the same name before falling back to the closest street.</p> <p>There are also addresses in OSM, where the housenumber does not belong to a street at all. These have an <code>addr:place</code> tag. For these places, Nominatim tries to find a place with the given name in the indexed places with an address rank between 16 and 25. If none is found, then the dependent place is attached to the closest place in that category and the addr:place name is added as unlisted place, which indicates to Nominatim that it needs to add it to the address output, no matter what. This special case is necessary to cover addresses that don't really refer to an existing object.</p> <p>When an address has both the <code>addr:street</code> and <code>addr:place</code> tag, then Nominatim assumes that the <code>addr:place</code> tag in fact should be the city part of the address and give the POI the usual street number address.</p> <p>Dependent places are only added to the global search index <code>search_name</code> when they have either a name themselves or when they have address tags that are not covered by the places that make up their address. The latter ensures that addresses are always searchable by those address tags.</p>"},{"location":"develop/Testing/","title":"Nominatim Test Suite","text":"<p>This chapter describes the tests in the <code>/test</code> directory, how they are structured and how to extend them. For a quick introduction on how to run the tests, see the Development setup chapter.</p>"},{"location":"develop/Testing/#overall-structure","title":"Overall structure","text":"<p>There are two kind of tests in this test suite. There are functional tests which test the API interface using a BDD test framework and there are unit tests for specific PHP functions.</p> <p>This test directory is structured as follows:</p> <pre><code> -+-   bdd         Functional API tests\n  | \\\n  | +-  steps      Step implementations for test descriptions\n  | +-  osm2pgsql  Tests for data import via osm2pgsql\n  | +-  db         Tests for internal data processing on import and update\n  | +-  api        Tests for API endpoints (search, reverse, etc.)\n  |\n  +-   php         PHP unit tests\n  +-   python      Python unit tests\n  +-   testdb      Base data for generating API test database\n  +-   testdata    Additional test data used by unit tests\n</code></pre>"},{"location":"develop/Testing/#php-unit-tests-testphp","title":"PHP Unit Tests (<code>test/php</code>)","text":"<p>Unit tests for PHP code can be found in the <code>php/</code> directory. They test selected PHP functions. Very low coverage.</p> <p>To execute the test suite run</p> <pre><code>cd test/php\nUNIT_TEST_DSN='pgsql:dbname=nominatim_unit_tests' phpunit ../\n</code></pre> <p>It will read phpunit.xml which points to the library, test path, bootstrap strip and sets other parameters.</p> <p>It will use (and destroy) a local database 'nominatim_unit_tests'. You can set a different connection string with e.g. UNIT_TEST_DSN='pgsql:dbname=foo_unit_tests'.</p>"},{"location":"develop/Testing/#python-unit-tests-testpython","title":"Python Unit Tests (<code>test/python</code>)","text":"<p>Unit tests for Python code can be found in the <code>python/</code> directory. The goal is to have complete coverage of the Python library in <code>nominatim</code>.</p> <p>To execute the tests run</p> <pre><code>py.test-3 test/python\n</code></pre> <p>or</p> <pre><code>pytest test/python\n</code></pre> <p>The name of the pytest binary depends on your installation.</p>"},{"location":"develop/Testing/#bdd-functional-tests-testbdd","title":"BDD Functional Tests (<code>test/bdd</code>)","text":"<p>Functional tests are written as BDD instructions. For more information on the philosophy of BDD testing, see the Behave manual.</p> <p>The following explanation assume that the reader is familiar with the BDD notations of features, scenarios and steps.</p> <p>All possible steps can be found in the <code>steps</code> directory and should ideally be documented.</p>"},{"location":"develop/Testing/#general-usage","title":"General Usage","text":"<p>To run the functional tests, do</p> <pre><code>cd test/bdd\nbehave\n</code></pre> <p>The tests can be configured with a set of environment variables (<code>behave -D key=val</code>):</p> <ul> <li><code>BUILDDIR</code> - build directory of Nominatim installation to test</li> <li><code>TEMPLATE_DB</code> - name of template database used as a skeleton for                    the test databases (db tests)</li> <li><code>TEST_DB</code> - name of test database (db tests)</li> <li><code>API_TEST_DB</code> - name of the database containing the API test data (api tests)</li> <li><code>API_TEST_FILE</code> - OSM file to be imported into the API test database (api tests)</li> <li><code>API_ENGINE</code> - webframe to use for running search queries, same values as                   <code>nominatim serve --engine</code> parameter</li> <li><code>DB_HOST</code> - (optional) hostname of database host</li> <li><code>DB_PORT</code> - (optional) port of database on host</li> <li><code>DB_USER</code> - (optional) username of database login</li> <li><code>DB_PASS</code> - (optional) password for database login</li> <li><code>SERVER_MODULE_PATH</code> - (optional) path on the Postgres server to Nominatim                           module shared library file</li> <li><code>REMOVE_TEMPLATE</code> - if true, the template and API database will not be reused                        during the next run. Reusing the base templates speeds                        up tests considerably but might lead to outdated errors                        for some changes in the database layout.</li> <li><code>KEEP_TEST_DB</code> - if true, the test database will not be dropped after a test                     is finished. Should only be used if one single scenario is                     run, otherwise the result is undefined.</li> </ul> <p>Logging can be defined through command line parameters of behave itself. Check out <code>behave --help</code> for details. Also have a look at the 'work-in-progress' feature of behave which comes in handy when writing new tests.</p>"},{"location":"develop/Testing/#api-tests-testbddapi","title":"API Tests (<code>test/bdd/api</code>)","text":"<p>These tests are meant to test the different API endpoints and their parameters. They require to import several datasets into a test database. This is normally done automatically during setup of the test. The API test database is then kept around and reused in subsequent runs of behave. Use <code>behave -DREMOVE_TEMPLATE</code> to force a reimport of the database.</p> <p>The official test dataset is saved in the file <code>test/testdb/apidb-test-data.pbf</code> and compromises the following data:</p> <ul> <li>Geofabrik extract of Liechtenstein</li> <li>extract of Autauga country, Alabama, US (for tests against Tiger data)</li> <li>additional data from <code>test/testdb/additional_api_test.data.osm</code></li> </ul> <p>API tests should only be testing the functionality of the website PHP code. Most tests should be formulated as BDD DB creation tests (see below) instead.</p>"},{"location":"develop/Testing/#code-coverage-php-engine-only","title":"Code Coverage (PHP engine only)","text":"<p>The API tests also support code coverage tests. You need to install PHP_CodeCoverage. On Debian/Ubuntu run:</p> <pre><code>apt-get install php-codecoverage php-xdebug\n</code></pre> <p>Then run the API tests as follows:</p> <pre><code>behave api -DPHPCOV=&lt;coverage output dir&gt;\n</code></pre> <p>The output directory must be an absolute path. To generate reports, you can use the phpcov tool:</p> <pre><code>phpcov merge --html=&lt;report output dir&gt; &lt;coverage output dir&gt;\n</code></pre>"},{"location":"develop/Testing/#db-creation-tests-testbdddb","title":"DB Creation Tests (<code>test/bdd/db</code>)","text":"<p>These tests check the import and update of the Nominatim database. They do not test the correctness of osm2pgsql. Each test will write some data into the <code>place</code> table (and optionally the <code>planet_osm_*</code> tables if required) and then run Nominatim's processing functions on that.</p> <p>These tests need to create their own test databases. By default they will be called <code>test_template_nominatim</code> and <code>test_nominatim</code>. Names can be changed with the environment variables <code>TEMPLATE_DB</code> and <code>TEST_DB</code>. The user running the tests needs superuser rights for postgres.</p>"},{"location":"develop/Testing/#import-tests-testbddosm2pgsql","title":"Import Tests (<code>test/bdd/osm2pgsql</code>)","text":"<p>These tests check that data is imported correctly into the place table. They use the same template database as the DB Creation tests, so the same remarks apply.</p>"},{"location":"develop/Tokenizers/","title":"Tokenizers","text":"<p>The tokenizer is the component of Nominatim that is responsible for analysing names of OSM objects and queries. Nominatim provides different tokenizers that use different strategies for normalisation. This page describes how tokenizers are expected to work and the public API that needs to be implemented when creating a new tokenizer. For information on how to configure a specific tokenizer for a database see the tokenizer chapter in the Customization Guide.</p>"},{"location":"develop/Tokenizers/#generic-architecture","title":"Generic Architecture","text":""},{"location":"develop/Tokenizers/#about-search-tokens","title":"About Search Tokens","text":"<p>Search in Nominatim is organised around search tokens. Such a token represents string that can be part of the search query. Tokens are used so that the search index does not need to be organised around strings. Instead the database saves for each place which tokens match this place's name, address, house number etc. To be able to distinguish between these different types of information stored with the place, a search token also always has a certain type: name, house number, postcode etc.</p> <p>During search an incoming query is transformed into a ordered list of such search tokens (or rather many lists, see below) and this list is then converted into a database query to find the right place.</p> <p>It is the core task of the tokenizer to create, manage and assign the search tokens. The tokenizer is involved in two distinct operations:</p> <ul> <li>at import time: scanning names of OSM objects, normalizing them and   building up the list of search tokens.</li> <li>at query time: scanning the query and returning the appropriate search   tokens.</li> </ul>"},{"location":"develop/Tokenizers/#importing","title":"Importing","text":"<p>The indexer is responsible to enrich an OSM object (or place) with all data required for geocoding. It is split into two parts: the controller collects the places that require updating, enriches the place information as required and hands the place to Postgresql. The collector is part of the Nominatim library written in Python. Within Postgresql, the <code>placex_update</code> trigger is responsible to fill out all secondary tables with extra geocoding information. This part is written in PL/pgSQL.</p> <p>The tokenizer is involved in both parts. When the indexer prepares a place, it hands it over to the tokenizer to inspect the names and create all the search tokens applicable for the place. This usually involves updating the tokenizer's internal token lists and creating a list of all token IDs for the specific place. This list is later needed in the PL/pgSQL part where the indexer needs to add the token IDs to the appropriate search tables. To be able to communicate the list between the Python part and the pl/pgSQL trigger, the <code>placex</code> table contains a special JSONB column <code>token_info</code> which is there for the exclusive use of the tokenizer.</p> <p>The Python part of the tokenizer returns a structured information about the tokens of a place to the indexer which converts it to JSON and inserts it into the <code>token_info</code> column. The content of the column is then handed to the PL/pqSQL callbacks of the tokenizer which extracts the required information. Usually the tokenizer then removes all information from the <code>token_info</code> structure, so that no information is ever persistently saved in the table. All information that went in should have been processed after all and put into secondary tables. This is however not a hard requirement. If the tokenizer needs to store additional information about a place permanently, it may do so in the <code>token_info</code> column. It just may never execute searches over it and consequently not create any special indexes on it.</p>"},{"location":"develop/Tokenizers/#querying","title":"Querying","text":"<p>At query time, Nominatim builds up multiple interpretations of the search query. Each of these interpretations is tried against the database in order of the likelihood with which they match to the search query. The first interpretation that yields results wins.</p> <p>The interpretations are encapsulated in the <code>SearchDescription</code> class. An instance of this class is created by applying a sequence of search tokens to an initially empty SearchDescription. It is the responsibility of the tokenizer to parse the search query and derive all possible sequences of search tokens. To that end the tokenizer needs to parse the search query and look up matching words in its own data structures.</p>"},{"location":"develop/Tokenizers/#tokenizer-api","title":"Tokenizer API","text":"<p>The following section describes the functions that need to be implemented for a custom tokenizer implementation.</p> <p>Warning</p> <p>This API is currently in early alpha status. While this API is meant to be a public API on which other tokenizers may be implemented, the API is far away from being stable at the moment.</p>"},{"location":"develop/Tokenizers/#directory-structure","title":"Directory Structure","text":"<p>Nominatim expects two files for a tokenizer:</p> <ul> <li><code>nominatim/tokenizer/&lt;NAME&gt;_tokenizer.py</code> containing the Python part of the   implementation</li> <li><code>lib-php/tokenizer/&lt;NAME&gt;_tokenizer.php</code> with the PHP part of the   implementation</li> </ul> <p>where <code>&lt;NAME&gt;</code> is a unique name for the tokenizer consisting of only lower-case letters, digits and underscore. A tokenizer also needs to install some SQL functions. By convention, these should be placed in <code>lib-sql/tokenizer</code>.</p> <p>If the tokenizer has a default configuration file, this should be saved in the <code>settings/&lt;NAME&gt;_tokenizer.&lt;SUFFIX&gt;</code>.</p>"},{"location":"develop/Tokenizers/#configuration-and-persistence","title":"Configuration and Persistence","text":"<p>Tokenizers may define custom settings for their configuration. All settings must be prefixed with <code>NOMINATIM_TOKENIZER_</code>. Settings may be transient or persistent. Transient settings are loaded from the configuration file when Nominatim is started and may thus be changed at any time. Persistent settings are tied to a database installation and must only be read during installation time. If they are needed for the runtime then they must be saved into the <code>nominatim_properties</code> table and later loaded from there.</p>"},{"location":"develop/Tokenizers/#the-python-module","title":"The Python module","text":"<p>The Python module is expect to export a single factory function:</p> <pre><code>def create(dsn: str, data_dir: Path) -&gt; AbstractTokenizer\n</code></pre> <p>The <code>dsn</code> parameter contains the DSN of the Nominatim database. The <code>data_dir</code> is a directory in the project directory that the tokenizer may use to save database-specific data. The function must return the instance of the tokenizer class as defined below.</p>"},{"location":"develop/Tokenizers/#python-tokenizer-class","title":"Python Tokenizer Class","text":"<p>All tokenizers must inherit from <code>nominatim.tokenizer.base.AbstractTokenizer</code> and implement the abstract functions defined there.</p> <p>The tokenizer instance is the central instance of the tokenizer in the system. There will only be a single instance of the tokenizer active at any time.</p>"},{"location":"develop/Tokenizers/#nominatim.tokenizer.base.AbstractTokenizer.check_database","title":"<code>check_database(config)</code>  <code>abstractmethod</code>","text":"<p>Check that the database is set up correctly and ready for being queried.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Configuration</code> <p>Read-only object with configuration options.</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>If an issue was found, return an error message with the   description of the issue as well as hints for the user on   how to resolve the issue. If everything is okay, return <code>None</code>.</p>"},{"location":"develop/Tokenizers/#nominatim.tokenizer.base.AbstractTokenizer.finalize_import","title":"<code>finalize_import(config)</code>  <code>abstractmethod</code>","text":"<p>This function is called at the very end of an import when all data has been imported and indexed. The tokenizer may create at this point any additional indexes and data structures needed during query time.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Configuration</code> <p>Read-only object with configuration options.</p> required"},{"location":"develop/Tokenizers/#nominatim.tokenizer.base.AbstractTokenizer.init_from_project","title":"<code>init_from_project(config)</code>  <code>abstractmethod</code>","text":"<p>Initialise the tokenizer from an existing database setup.</p> <p>The function should load all previously saved configuration from the project directory and/or the property table.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Configuration</code> <p>Read-only object with configuration options.</p> required"},{"location":"develop/Tokenizers/#nominatim.tokenizer.base.AbstractTokenizer.init_new_db","title":"<code>init_new_db(config, init_db=True)</code>  <code>abstractmethod</code>","text":"<p>Set up a new tokenizer for the database.</p> <p>The function should copy all necessary data into the project directory or save it in the property table to make sure that the tokenizer remains stable over updates.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Configuration</code> <p>Read-only object with configuration options.</p> required <code>init_db</code> <code>bool</code> <p>When set to False, then initialisation of database tables should be skipped. This option is only required for migration purposes and can be safely ignored by custom tokenizers.</p> <code>True</code>"},{"location":"develop/Tokenizers/#nominatim.tokenizer.base.AbstractTokenizer.most_frequent_words","title":"<code>most_frequent_words(conn, num)</code>  <code>abstractmethod</code>","text":"<p>Return a list of the most frequent full words in the database.</p> <p>Parameters:</p> Name Type Description Default <code>conn</code> <code>Connection</code> <p>Open connection to the database which may be used to     retrieve the words.</p> required <code>num</code> <code>int</code> <p>Maximum number of words to return.</p> required"},{"location":"develop/Tokenizers/#nominatim.tokenizer.base.AbstractTokenizer.name_analyzer","title":"<code>name_analyzer()</code>  <code>abstractmethod</code>","text":"<p>Create a new analyzer for tokenizing names and queries using this tokinzer. Analyzers are context managers and should be used accordingly:</p> <pre><code>with tokenizer.name_analyzer() as analyzer:\n    analyser.tokenize()\n</code></pre> <p>When used outside the with construct, the caller must ensure to call the close() function before destructing the analyzer.</p>"},{"location":"develop/Tokenizers/#nominatim.tokenizer.base.AbstractTokenizer.update_sql_functions","title":"<code>update_sql_functions(config)</code>  <code>abstractmethod</code>","text":"<p>Update the SQL part of the tokenizer. This function is called automatically on migrations or may be called explicitly by the user through the <code>nominatim refresh --functions</code> command.</p> <p>The tokenizer must only update the code of the tokenizer. The data structures or data itself must not be changed by this function.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Configuration</code> <p>Read-only object with configuration options.</p> required"},{"location":"develop/Tokenizers/#nominatim.tokenizer.base.AbstractTokenizer.update_statistics","title":"<code>update_statistics(config)</code>  <code>abstractmethod</code>","text":"<p>Recompute any tokenizer statistics necessary for efficient lookup. This function is meant to be called from time to time by the user to improve performance. However, the tokenizer must not depend on it to be called in order to work.</p>"},{"location":"develop/Tokenizers/#nominatim.tokenizer.base.AbstractTokenizer.update_word_tokens","title":"<code>update_word_tokens()</code>  <code>abstractmethod</code>","text":"<p>Do house-keeping on the tokenizers internal data structures. Remove unused word tokens, resort data etc.</p>"},{"location":"develop/Tokenizers/#python-analyzer-class","title":"Python Analyzer Class","text":"<p>The analyzer provides the functions for analysing names and building the token database.</p> <p>Analyzers are instantiated on a per-thread base. Access to global data structures must be synchronised accordingly.</p>"},{"location":"develop/Tokenizers/#nominatim.tokenizer.base.AbstractAnalyzer.add_country_names","title":"<code>add_country_names(country_code, names)</code>  <code>abstractmethod</code>","text":"<p>Add the given names to the tokenizer's list of country tokens.</p> <p>Parameters:</p> Name Type Description Default <code>country_code</code> <code>str</code> <p>two-letter country code for the country the names           refer to.</p> required <code>names</code> <code>Dict[str, str]</code> <p>Dictionary of name type to name.</p> required"},{"location":"develop/Tokenizers/#nominatim.tokenizer.base.AbstractAnalyzer.close","title":"<code>close()</code>  <code>abstractmethod</code>","text":"<p>Free all resources used by the analyzer.</p>"},{"location":"develop/Tokenizers/#nominatim.tokenizer.base.AbstractAnalyzer.get_word_token_info","title":"<code>get_word_token_info(words)</code>  <code>abstractmethod</code>","text":"<p>Return token information for the given list of words.</p> <p>The function is used for testing and debugging only and does not need to be particularly efficient.</p> <p>Parameters:</p> Name Type Description Default <code>words</code> <code>List[str]</code> <p>A list of words to look up the tokens for.    If a word starts with # it is assumed to be a full name    otherwise is a partial term.</p> required <p>Returns:</p> Type Description <code>List[Tuple[str, str, int]]</code> <p>The function returns the list of all tuples that could be found for the given words. Each list entry is a tuple of (original word, word token, word id).</p>"},{"location":"develop/Tokenizers/#nominatim.tokenizer.base.AbstractAnalyzer.normalize_postcode","title":"<code>normalize_postcode(postcode)</code>  <code>abstractmethod</code>","text":"<p>Convert the postcode to its standardized form.</p> <p>This function must yield exactly the same result as the SQL function <code>token_normalized_postcode()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>postcode</code> <code>str</code> <p>The postcode to be normalized.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The given postcode after normalization.</p>"},{"location":"develop/Tokenizers/#nominatim.tokenizer.base.AbstractAnalyzer.process_place","title":"<code>process_place(place)</code>  <code>abstractmethod</code>","text":"<p>Extract tokens for the given place and compute the information to be handed to the PL/pgSQL processor for building the search index.</p> <p>Parameters:</p> Name Type Description Default <code>place</code> <code>PlaceInfo</code> <p>Place information retrieved from the database.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>A JSON-serialisable structure that will be handed into the database via the <code>token_info</code> field.</p>"},{"location":"develop/Tokenizers/#nominatim.tokenizer.base.AbstractAnalyzer.update_postcodes_from_db","title":"<code>update_postcodes_from_db()</code>  <code>abstractmethod</code>","text":"<p>Update the tokenizer's postcode tokens from the current content of the <code>location_postcode</code> table.</p>"},{"location":"develop/Tokenizers/#nominatim.tokenizer.base.AbstractAnalyzer.update_special_phrases","title":"<code>update_special_phrases(phrases, should_replace)</code>  <code>abstractmethod</code>","text":"<p>Update the tokenizer's special phrase tokens from the given list of special phrases.</p> <p>Parameters:</p> Name Type Description Default <code>phrases</code> <code>Iterable[Tuple[str, str, str, str]]</code> <p>The new list of special phrases. Each entry is      a tuple of (phrase, class, type, operator).</p> required <code>should_replace</code> <code>bool</code> <p>If true, replace the current list of phrases.             When false, just add the given phrases to the             ones that already exist.</p> required"},{"location":"develop/Tokenizers/#plpgsql-functions","title":"PL/pgSQL Functions","text":"<p>The tokenizer must provide access functions for the <code>token_info</code> column to the indexer which extracts the necessary information for the global search tables. If the tokenizer needs additional SQL functions for private use, then these functions must be prefixed with <code>token_</code> in order to ensure that there are no naming conflicts with the SQL indexer code.</p> <p>The following functions are expected:</p> <pre><code>FUNCTION token_get_name_search_tokens(info JSONB) RETURNS INTEGER[]\n</code></pre> <p>Return an array of token IDs of search terms that should match the name(s) for the given place. These tokens are used to look up the place by name and, where the place functions as part of an address for another place, by address. Must return NULL when the place has no name.</p> <pre><code>FUNCTION token_get_name_match_tokens(info JSONB) RETURNS INTEGER[]\n</code></pre> <p>Return an array of token IDs of full names of the place that should be used to match addresses. The list of match tokens is usually more strict than search tokens as it is used to find a match between two OSM tag values which are expected to contain matching full names. Partial terms should not be used for match tokens. Must return NULL when the place has no name.</p> <pre><code>FUNCTION token_get_housenumber_search_tokens(info JSONB) RETURNS INTEGER[]\n</code></pre> <p>Return an array of token IDs of house number tokens that apply to the place. Note that a place may have multiple house numbers, for example when apartments each have their own number. Must be NULL when the place has no house numbers.</p> <pre><code>FUNCTION token_normalized_housenumber(info JSONB) RETURNS TEXT\n</code></pre> <p>Return the house number(s) in the normalized form that can be matched against a house number token text. If a place has multiple house numbers they must be listed with a semicolon as delimiter. Must be NULL when the place has no house numbers.</p> <pre><code>FUNCTION token_is_street_address(info JSONB) RETURNS BOOLEAN\n</code></pre> <p>Return true if this is an object that should be parented against a street. Only relevant for objects with address rank 30.</p> <pre><code>FUNCTION token_has_addr_street(info JSONB) RETURNS BOOLEAN\n</code></pre> <p>Return true if there are street names to match against for finding the parent of the object.</p> <pre><code>FUNCTION token_has_addr_place(info JSONB) RETURNS BOOLEAN\n</code></pre> <p>Return true if there are place names to match against for finding the parent of the object.</p> <pre><code>FUNCTION token_matches_street(info JSONB, street_tokens INTEGER[]) RETURNS BOOLEAN\n</code></pre> <p>Check if the given tokens (previously saved from <code>token_get_name_match_tokens()</code>) match against the <code>addr:street</code> tag name. Must return either NULL or FALSE when the place has no <code>addr:street</code> tag.</p> <pre><code>FUNCTION token_matches_place(info JSONB, place_tokens INTEGER[]) RETURNS BOOLEAN\n</code></pre> <p>Check if the given tokens (previously saved from <code>token_get_name_match_tokens()</code>) match against the <code>addr:place</code> tag name. Must return either NULL or FALSE when the place has no <code>addr:place</code> tag.</p> <pre><code>FUNCTION token_addr_place_search_tokens(info JSONB) RETURNS INTEGER[]\n</code></pre> <p>Return the search token IDs extracted from the <code>addr:place</code> tag. These tokens are used for searches by address when no matching place can be found in the database. Must be NULL when the place has no <code>addr:place</code> tag.</p> <pre><code>FUNCTION token_get_address_keys(info JSONB) RETURNS SETOF TEXT\n</code></pre> <p>Return the set of keys for which address information is provided. This should correspond to the list of (relevant) <code>addr:*</code> tags with the <code>addr:</code> prefix removed or the keys used in the <code>address</code> dictionary of the place info.</p> <pre><code>FUNCTION token_get_address_search_tokens(info JSONB, key TEXT) RETURNS INTEGER[]\n</code></pre> <p>Return the array of search tokens for the given address part. <code>key</code> can be expected to be one of those returned with <code>token_get_address_keys()</code>. The search tokens are added to the address search vector of the place, when no corresponding OSM object could be found for the given address part from which to copy the name information.</p> <pre><code>FUNCTION token_matches_address(info JSONB, key TEXT, tokens INTEGER[])\n</code></pre> <p>Check if the given tokens match against the address part <code>key</code>.</p> <p>Warning: the tokens that are handed in are the lists previously saved from <code>token_get_name_search_tokens()</code>, not from the match token list. This is an historical oddity which will be fixed at some point in the future. Currently, tokenizers are encouraged to make sure that matching works against both the search token list and the match token list.</p> <pre><code>FUNCTION token_get_postcode(info JSONB) RETURNS TEXT\n</code></pre> <p>Return the postcode for the object, if any exists. The postcode must be in the form that should also be presented to the end-user.</p> <pre><code>FUNCTION token_strip_info(info JSONB) RETURNS JSONB\n</code></pre> <p>Return the part of the <code>token_info</code> field that should be stored in the database permanently. The indexer calls this function when all processing is done and replaces the content of the <code>token_info</code> column with the returned value before the trigger stores the information in the database. May return NULL if no information should be stored permanently.</p>"},{"location":"develop/Tokenizers/#php-tokenizer-class","title":"PHP Tokenizer class","text":"<p>The PHP tokenizer class is instantiated once per request and responsible for analyzing the incoming query. Multiple requests may be in flight in parallel.</p> <p>The class is expected to be found under the name of <code>\\Nominatim\\Tokenizer</code>. To find the class the PHP code includes the file <code>tokenizer/tokenizer.php</code> in the project directory. This file must be created when the tokenizer is first set up on import. The file should initialize any configuration variables by setting PHP constants and then require the file with the actual implementation of the tokenizer.</p> <p>The tokenizer class must implement the following functions:</p> <pre><code>public function __construct(object &amp;$oDB)\n</code></pre> <p>The constructor of the class receives a database connection that can be used to query persistent data in the database.</p> <pre><code>public function checkStatus()\n</code></pre> <p>Check that the tokenizer can access its persistent data structures. If there is an issue, throw an <code>\\Exception</code>.</p> <pre><code>public function normalizeString(string $sTerm) : string\n</code></pre> <p>Normalize string to a form to be used for comparisons when reordering results. Nominatim reweighs results how well the final display string matches the actual query. Before comparing result and query, names and query are normalised against this function. The tokenizer can thus remove all properties that should not be taken into account for reweighing, e.g. special characters or case.</p> <pre><code>public function tokensForSpecialTerm(string $sTerm) : array\n</code></pre> <p>Return the list of special term tokens that match the given term.</p> <pre><code>public function extractTokensFromPhrases(array &amp;$aPhrases) : TokenList\n</code></pre> <p>Parse the given phrases, splitting them into word lists and retrieve the matching tokens.</p> <p>The phrase array may take on two forms. In unstructured searches (using <code>q=</code> parameter) the search query is split at the commas and the elements are put into a sorted list. For structured searches the phrase array is an associative array where the key designates the type of the term (street, city, county etc.) The tokenizer may ignore the phrase type at this stage in parsing. Matching phrase type and appropriate search token type will be done later when the SearchDescription is built.</p> <p>For each phrase in the list of phrases, the function must analyse the phrase string and then call <code>setWordSets()</code> to communicate the result of the analysis. A word set is a list of strings, where each string refers to a search token. A phrase may have multiple interpretations. Therefore a list of word sets is usually attached to the phrase. The search tokens themselves are returned by the function in an associative array, where the key corresponds to the strings given in the word sets. The value is a list of search tokens. Thus a single string in the list of word sets may refer to multiple search tokens.</p>"},{"location":"develop/data-sources/","title":"Additional Data Sources","text":"<p>This guide explains how data sources other than OpenStreetMap mentioned in the install instructions got obtained and converted.</p>"},{"location":"develop/data-sources/#country-grid","title":"Country grid","text":"<p>Nominatim uses pre-generated country borders data. In case one imports only a subset of a country. And to assign each place a partition. Nominatim database tables are split into partitions for performance.</p> <p>More details in osm-search/country-grid-data.</p>"},{"location":"develop/data-sources/#us-census-tiger","title":"US Census TIGER","text":"<p>For the United States you can choose to import additional street-level data. The data isn't mixed into OSM data but queried as fallback when no OSM result can be found.</p> <p>More details in osm-search/TIGER-data.</p>"},{"location":"develop/data-sources/#gb-postcodes","title":"GB postcodes","text":"<p>For Great Britain you can choose to import Royalmail postcode centroids.</p> <p>More details in osm-search/gb-postcode-data.</p>"},{"location":"develop/data-sources/#wikipedia-wikidata-rankings","title":"Wikipedia &amp; Wikidata rankings","text":"<p>Nominatim can import \"importance\" data of place names. This greatly improves ranking of results.</p> <p>More details in osm-search/wikipedia-wikidata.</p>"},{"location":"develop/overview/","title":"Basic Architecture","text":"<p>Nominatim provides geocoding based on OpenStreetMap data. It uses a PostgreSQL database as a backend for storing the data.</p> <p>There are three basic parts to Nominatim's architecture: the data import, the address computation and the search frontend.</p> <p>The data import stage reads the raw OSM data and extracts all information that is useful for geocoding. This part is done by osm2pgsql, the same tool that can also be used to import a rendering database. It uses the special gazetteer output plugin in <code>osm2pgsql/src/output-gazetter.[ch]pp</code>. The result of the import can be found in the database table <code>place</code>.</p> <p>The address computation or indexing stage takes the data from <code>place</code> and adds additional information needed for geocoding. It ranks the places by importance, links objects that belong together and computes addresses and the search index. Most of this work is done in PL/pgSQL via database triggers and can be found in the files in the <code>sql/functions/</code> directory.</p> <p>The search frontend implements the actual API. It takes search and reverse geocoding queries from the user, looks up the data and returns the results in the requested format. This part is written in PHP and can be found in the <code>lib/</code> and <code>website/</code> directories.</p>"},{"location":"library/Configuration/","title":"Configuration","text":"<p>When using Nominatim through the library, it can be configured in exactly the same way as when running as a service. This means that you should have created a project directory which contains all files belonging to the Nominatim instance. It can also contain an <code>.env</code> file with configuration options. Setting configuration parameters via environment variables works as well.</p> <p>Configuration options are resolved in the following order:</p> <ul> <li>from the OS environment (or the dictionary given in <code>environ</code>,   (see NominatimAPI.md#nominatim.api.core.NominatimAPI.init)</li> <li>from the .env file in the project directory of the installation</li> <li>from the default installation in the configuration directory</li> </ul> <p>For more information on configuration via dotenv and a list of possible configuration parameters, see the Configuration page.</p>"},{"location":"library/Configuration/#configuration-class","title":"<code>Configuration</code> class","text":"<p>This class wraps access to the configuration settings for the Nominatim instance in use.</p> <p>All Nominatim configuration options are prefixed with 'NOMINATIM_' to avoid conflicts with other environment variables. All settings can be accessed as properties of the class under the same name as the setting but with the <code>NOMINATIM_</code> prefix removed. In addition, there are accessor functions that convert the setting values to types other than string.</p>"},{"location":"library/Configuration/#nominatim.config.Configuration.get_bool","title":"<code>get_bool(name: str) -&gt; bool</code>","text":"<p>Return the given configuration parameter as a boolean.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the configuration parameter with the NOMINATIM_ prefix removed.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> for values of '1', 'yes' and 'true', <code>False</code> otherwise.</p>"},{"location":"library/Configuration/#nominatim.config.Configuration.get_int","title":"<code>get_int(name: str) -&gt; int</code>","text":"<p>Return the given configuration parameter as an int.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the configuration parameter with the NOMINATIM_ prefix removed.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The configuration value converted to int.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>when the value is not a number.</p>"},{"location":"library/Configuration/#nominatim.config.Configuration.get_str_list","title":"<code>get_str_list(name: str) -&gt; Optional[List[str]]</code>","text":"<p>Return the given configuration parameter as a list of strings. The values are assumed to be given as a comma-sparated list and will be stripped before returning them. </p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the configuration parameter with the NOMINATIM_ prefix removed.</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>The comma-split parameter as a list. The elements are stripped of leading and final spaces before being returned.</p> <code>None</code> <p>The configuration parameter was unset or empty.</p>"},{"location":"library/Configuration/#nominatim.config.Configuration.get_path","title":"<code>get_path(name: str) -&gt; Optional[Path]</code>","text":"<p>Return the given configuration parameter as a Path.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the configuration parameter with the NOMINATIM_ prefix removed.</p> required <p>Returns:</p> Type Description <code>Path</code> <p>A Path object of the parameter value.   If a relative path is configured, then the function converts this   into an absolute path with the project directory as root path.</p> <code>None</code> <p>The configuration parameter was unset or empty.</p>"},{"location":"library/Getting-Started/","title":"Getting Started","text":"<p>The Nominatim search frontend can directly be used as a Python library in scripts and applications. When you have imported your own Nominatim database, then it is no longer necessary to run a full web service for it and access the database through http requests. There are also less constraints on the kinds of data that can be accessed. The library allows to get access to more detailed information about the objects saved in the database.</p> <p>Danger</p> <p>The library interface is currently in an experimental stage. There might be some smaller adjustments to the public interface until the next version.</p> <p>The library also misses a proper installation routine, so some manipulation of the PYTHONPATH is required. At the moment, use is only recommended for developers with some experience in Python.</p>"},{"location":"library/Getting-Started/#installation","title":"Installation","text":"<p>To use the Nominatim library, you need access to a local Nominatim database. Follow the installation and import instructions to set up your database.</p> <p>It is not yet possible to install it in the usual way via pip or inside a virtualenv. To get access to the library you need to set an appropriate <code>PYTHONPATH</code>. With the default installation, the python library can be found under <code>/usr/local/share/nominatim/lib-python</code>. If you have installed Nominatim under a different prefix, adapt the <code>/usr/local/</code> part accordingly. You can also point the <code>PYTHONPATH</code> to the Nominatim source code.</p>"},{"location":"library/Getting-Started/#a-simple-search-example","title":"A simple search example","text":"<p>To query the Nominatim database you need to first set up a connection. This is done by creating an Nominatim API object. This object exposes all the search functions of Nominatim that are also known from its web API.</p> <p>This code snippet implements a simple search for the town of 'Brugge':</p> <p>Example</p> NominatimAPIAsyncNominatimAPI <pre><code>from pathlib import Path\nimport asyncio\n\nimport nominatim.api as napi\n\nasync def search(query):\n    api = napi.NominatimAPIAsync(Path('.'))\n\n    return await api.search(query)\n\nresults = asyncio.run(search('Brugge'))\nif not results:\n    print('Cannot find Brugge')\nelse:\n    print(f'Found a place at {results[0].centroid.x},{results[0].centroid.y}')\n</code></pre> <pre><code>from pathlib import Path\n\nimport nominatim.api as napi\n\napi = napi.NominatimAPI(Path('.'))\n\nresults = api.search('Brugge')\n\nif not results:\n    print('Cannot find Brugge')\nelse:\n    print(f'Found a place at {results[0].centroid.x},{results[0].centroid.y}')\n</code></pre> <p>The Nominatim library is designed around asyncio. <code>NominatimAPIAsync</code> provides you with an interface of coroutines. If you have many requests to make, coroutines can speed up your applications significantly.</p> <p>For smaller scripts there is also a synchronous wrapper around the API. By using <code>NominatimAPI</code>, you get exactly the same interface using classic functions.</p> <p>The examples in this chapter will always show-case both implementations. The documentation itself will usually refer only to 'Nominatim API class' when both flavours are meant. If a functionality is available only for the synchronous or asynchronous version, this will be explicitly mentioned.</p>"},{"location":"library/Getting-Started/#defining-which-database-to-use","title":"Defining which database to use","text":"<p>The Configuration section explains how Nominatim is configured using the dotenv library. The same configuration mechanism is used with the Nominatim API library. You should therefore be sure you are familiar with the section.</p> <p>The constructor of the 'Nominatim API class' takes one mandatory parameter: the path to the project directory. You should have set up this directory as part of the Nominatim import. Any configuration found in the <code>.env</code> file in this directory will automatically used.</p> <p>Yo may also configure Nominatim be setting environment variables. Normally, Nominatim will check the operating system environment. This can be overwritten by giving the constructor a dictionary of configuration parameters.</p> <p>Let us look up 'Brugge' in the special database named 'belgium' instead of the standard 'nominatim' database:</p> <p>Example</p> NominatimAPIAsyncNominatimAPI <pre><code>from pathlib import Path\nimport asyncio\n\nimport nominatim.api as napi\n\nconfig_params = {\n    'NOMINATIM_DATABASE_DSN': 'pgsql:dbname=belgium'\n}\n\nasync def search(query):\n    api = napi.NominatimAPIAsync(Path('.'), environ=config_params)\n\n    return await api.search(query)\n\nresults = asyncio.run(search('Brugge'))\n</code></pre> <pre><code>from pathlib import Path\n\nimport nominatim.api as napi\n\nconfig_params = {\n    'NOMINATIM_DATABASE_DSN': 'pgsql:dbname=belgium'\n}\n\napi = napi.NominatimAPI(Path('.'), environ=config_params)\n\nresults = api.search('Brugge')\n</code></pre>"},{"location":"library/Getting-Started/#presenting-results-to-humans","title":"Presenting results to humans","text":"<p>All search functions return the raw results from the database. There is no full human-readable label. To create such a label, you need two things:</p> <ul> <li>the address details of the place</li> <li>adapt the result to the language you wish to use for display</li> </ul> <p>Again searching for 'Brugge', this time with a nicely formatted result:</p> <p>Example</p> NominatimAPIAsyncNominatimAPI <pre><code>from pathlib import Path\nimport asyncio\n\nimport nominatim.api as napi\n\nasync def search(query):\n    api = napi.NominatimAPIAsync(Path('.'))\n\n    return await api.search(query, address_details=True)\n\nresults = asyncio.run(search('Brugge'))\n\nlocale = napi.Locales(['fr', 'en'])\nfor i, result in enumerate(results):\n    address_parts = result.address_rows.localize(locale)\n    print(f\"{i + 1}. {', '.join(address_parts)}\")\n</code></pre> <pre><code>from pathlib import Path\n\nimport nominatim.api as napi\n\napi = napi.NominatimAPI(Path('.'))\n\nresults = api.search('Brugge', address_details=True)\n\nlocale = napi.Locales(['fr', 'en'])\nfor i, result in enumerate(results):\n    address_parts = result.address_rows.localize(locale)\n    print(f\"{i + 1}. {', '.join(address_parts)}\")\n</code></pre> <p>To request information about the address of a result, add the optional parameter 'address_details' to your search:</p> <pre><code>&gt;&gt;&gt; results = api.search('Brugge', address_details=True)\n</code></pre> <p>An additional field <code>address_rows</code> will set in results that are returned. It contains a list of all places that make up the address of the place. For simplicity, this includes name and house number of the place itself. With the names in this list it is possible to create a human-readable description of the result. To do that, you first need to decide in which language the results should be presented. As with the names in the result itself, the places in <code>address_rows</code> contain all possible name translation for each row.</p> <p>The library has a helper class <code>Locale</code> which helps extracting a name of a place in the preferred language. It takes a single parameter with a list of language codes in the order of preference. So</p> <pre><code>locale = napi.Locale(['fr', 'en'])\n</code></pre> <p>creates a helper class that returns the name preferably in French. If that is not possible, it tries English and eventually falls back to the default <code>name</code> or <code>ref</code>.</p> <p>The <code>Locale</code> object can be applied to a name dictionary to return the best-matching name out of it:</p> <pre><code>&gt;&gt;&gt; print(locale.display_name(results[0].names))\n'Brugges'\n</code></pre> <p>The <code>address_row</code> field has a helper function to apply the function to all its members and save the result in the <code>local_name</code> field. It also returns all the localized names as a convenient simple list. This list can be used to create a human-readable output:</p> <pre><code>&gt;&gt;&gt; address_parts = results[0].address_rows.localize(locale)\n&gt;&gt;&gt; print(', '.join(address_parts))\nBruges, Flandre-Occidentale, Flandre, Belgique\n</code></pre> <p>This is a fairly simple way to create a human-readable description. The place information in <code>address_rows</code> contains further information about each place. For example, which OSM <code>adlin_level</code> was used, what category the place belongs to or what rank Nominatim has assigned. Use this to adapt the output to local address formats.</p> <p>For more information on address rows, see detailed address description.</p>"},{"location":"library/Input-Parameter-Types/","title":"Input Parameter Types","text":"<p>This page describes in more detail some of the input parameter types used in the query functions of the API object.</p>"},{"location":"library/Input-Parameter-Types/#place-identification","title":"Place identification","text":"<p>The details and lookup functions require references to places in the database. Below the possible types for place identification are listed. All types are dataclasses.</p>"},{"location":"library/Input-Parameter-Types/#placeid","title":"PlaceID","text":"<p>Reference a place by Nominatim's internal ID.</p> <p>A PlaceID may reference place from the main table placex, from the interpolation tables or the postcode tables. Place IDs are not stable between installations. You may use this type theefore only with place IDs obtained from the same database.</p>"},{"location":"library/Input-Parameter-Types/#nominatim.api.PlaceID.place_id","title":"<code>place_id: int</code>  <code>instance-attribute</code>","text":"<p>The internal ID of the place to reference.</p>"},{"location":"library/Input-Parameter-Types/#osmid","title":"OsmID","text":"<p>Reference a place by its OSM ID and potentially the basic category.</p> <p>The OSM ID may refer to places in the main table placex and OSM interpolation lines.</p>"},{"location":"library/Input-Parameter-Types/#nominatim.api.OsmID.osm_class","title":"<code>osm_class: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The same OSM object may appear multiple times in the database under different categories. The optional class parameter allows to distinguish the different categories and corresponds to the key part of the category. If there are multiple objects in the database and <code>osm_class</code> is left out, then one of the objects is returned at random.</p>"},{"location":"library/Input-Parameter-Types/#nominatim.api.OsmID.osm_id","title":"<code>osm_id: int</code>  <code>instance-attribute</code>","text":"<p>The OSM ID of the object.</p>"},{"location":"library/Input-Parameter-Types/#nominatim.api.OsmID.osm_type","title":"<code>osm_type: str</code>  <code>instance-attribute</code>","text":"<p>OSM type of the object. Must be one of <code>N</code>(node), <code>W</code>(way) or <code>R</code>(relation).</p>"},{"location":"library/Input-Parameter-Types/#geometry-types","title":"Geometry types","text":"<p>All search functions support returning the full geometry of a place in various formats. The internal geometry is converted by PostGIS to the desired format and then returned as a string. It is possible to request multiple formats at the same time.</p>"},{"location":"library/Input-Parameter-Types/#nominatim.api.GeometryFormat.NONE","title":"<code>NONE = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>No geometry requested. Alias for a empty flag.</p>"},{"location":"library/Input-Parameter-Types/#nominatim.api.GeometryFormat.GEOJSON","title":"<code>GEOJSON = enum.auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>GeoJSON format</p>"},{"location":"library/Input-Parameter-Types/#nominatim.api.GeometryFormat.KML","title":"<code>KML = enum.auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>KML format</p>"},{"location":"library/Input-Parameter-Types/#nominatim.api.GeometryFormat.SVG","title":"<code>SVG = enum.auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>SVG format</p>"},{"location":"library/Input-Parameter-Types/#nominatim.api.GeometryFormat.TEXT","title":"<code>TEXT = enum.auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>WKT format</p>"},{"location":"library/Input-Parameter-Types/#geometry-input","title":"Geometry input","text":""},{"location":"library/Input-Parameter-Types/#point","title":"Point","text":"<p>A geographic point in WGS84 projection.</p>"},{"location":"library/Input-Parameter-Types/#nominatim.api.Point.lat","title":"<code>lat: float</code>  <code>property</code>","text":"<p>Return the latitude of the point.</p>"},{"location":"library/Input-Parameter-Types/#nominatim.api.Point.lon","title":"<code>lon: float</code>  <code>property</code>","text":"<p>Return the longitude of the point.</p>"},{"location":"library/Input-Parameter-Types/#nominatim.api.Point.from_param","title":"<code>from_param(inp: Any) -&gt; Point</code>  <code>staticmethod</code>","text":"<p>Create a point from an input parameter. The parameter may be given as a point, a string or a sequence of strings or floats. Raises a UsageError if the format is not correct.</p>"},{"location":"library/Input-Parameter-Types/#nominatim.api.Point.from_wkb","title":"<code>from_wkb(wkb: Union[str, bytes]) -&gt; Point</code>  <code>staticmethod</code>","text":"<p>Create a point from EWKB as returned from the database.</p>"},{"location":"library/Input-Parameter-Types/#nominatim.api.Point.to_geojson","title":"<code>to_geojson() -&gt; str</code>","text":"<p>Return the point in GeoJSON format.</p>"},{"location":"library/Input-Parameter-Types/#nominatim.api.Point.to_wkt","title":"<code>to_wkt() -&gt; str</code>","text":"<p>Return the WKT representation of the point.</p>"},{"location":"library/Input-Parameter-Types/#bbox","title":"Bbox","text":"<p>A bounding box in WGS84 projection.</p> <p>The coordinates are available as an array in the 'coord' property in the order (minx, miny, maxx, maxy).</p>"},{"location":"library/Input-Parameter-Types/#nominatim.api.Bbox.__init__","title":"<code>__init__(minx: float, miny: float, maxx: float, maxy: float) -&gt; None</code>","text":"<p>Create a new bounding box with the given coordinates in WGS84 projection.</p>"},{"location":"library/Input-Parameter-Types/#nominatim.api.Bbox.minlat","title":"<code>minlat: float</code>  <code>property</code>","text":"<p>Southern-most latitude, corresponding to the minimum y coordinate.</p>"},{"location":"library/Input-Parameter-Types/#nominatim.api.Bbox.maxlat","title":"<code>maxlat: float</code>  <code>property</code>","text":"<p>Northern-most latitude, corresponding to the maximum y coordinate.</p>"},{"location":"library/Input-Parameter-Types/#nominatim.api.Bbox.minlon","title":"<code>minlon: float</code>  <code>property</code>","text":"<p>Western-most longitude, corresponding to the minimum x coordinate.</p>"},{"location":"library/Input-Parameter-Types/#nominatim.api.Bbox.maxlon","title":"<code>maxlon: float</code>  <code>property</code>","text":"<p>Eastern-most longitude, corresponding to the maximum x coordinate.</p>"},{"location":"library/Input-Parameter-Types/#nominatim.api.Bbox.area","title":"<code>area: float</code>  <code>property</code>","text":"<p>Return the area of the box in WGS84.</p>"},{"location":"library/Input-Parameter-Types/#nominatim.api.Bbox.contains","title":"<code>contains(pt: Point) -&gt; bool</code>","text":"<p>Check if the point is inside or on the boundary of the box.</p>"},{"location":"library/Input-Parameter-Types/#nominatim.api.Bbox.to_wkt","title":"<code>to_wkt() -&gt; str</code>","text":"<p>Return the WKT representation of the Bbox. This is a simple polygon with four points.</p>"},{"location":"library/Input-Parameter-Types/#nominatim.api.Bbox.from_wkb","title":"<code>from_wkb(wkb: Union[None, str, bytes]) -&gt; Optional[Bbox]</code>  <code>staticmethod</code>","text":"<p>Create a Bbox from a bounding box polygon as returned by the database. Returns <code>None</code> if the input value is None.</p>"},{"location":"library/Input-Parameter-Types/#nominatim.api.Bbox.from_point","title":"<code>from_point(pt: Point, buffer: float) -&gt; Bbox</code>  <code>staticmethod</code>","text":"<p>Return a Bbox around the point with the buffer added to all sides.</p>"},{"location":"library/Input-Parameter-Types/#nominatim.api.Bbox.from_param","title":"<code>from_param(inp: Any) -&gt; Bbox</code>  <code>staticmethod</code>","text":"<p>Return a Bbox from an input parameter. The box may be given as a Bbox, a string or a list or strings or integer. Raises a UsageError if the format is incorrect.</p>"},{"location":"library/Input-Parameter-Types/#layers","title":"Layers","text":"<p>Layers allow to restrict the search result to thematic groups. This is orthogonal to restriction by address ranks, which groups places by their geographic extent.</p> <p>The <code>DataLayer</code> flag type defines the layers that can be selected for reverse and forward search.</p>"},{"location":"library/Input-Parameter-Types/#nominatim.api.DataLayer.ADDRESS","title":"<code>ADDRESS = enum.auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The address layer contains all places relevant for addresses: fully qualified addresses with a house number (or a house name equivalent, for some addresses) and places that can be part of an address like roads, cities, states.</p>"},{"location":"library/Input-Parameter-Types/#nominatim.api.DataLayer.POI","title":"<code>POI = enum.auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Layer for points of interest like shops, restaurants but also recycling bins or postboxes.</p>"},{"location":"library/Input-Parameter-Types/#nominatim.api.DataLayer.RAILWAY","title":"<code>RAILWAY = enum.auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Layer with railway features including tracks and other infrastructure. Note that in Nominatim's standard configuration, only very few railway features are imported into the database. Thus a custom configuration is required to make full use of this layer.</p>"},{"location":"library/Input-Parameter-Types/#nominatim.api.DataLayer.NATURAL","title":"<code>NATURAL = enum.auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Layer with natural features like rivers, lakes and mountains.</p>"},{"location":"library/Input-Parameter-Types/#nominatim.api.DataLayer.MANMADE","title":"<code>MANMADE = enum.auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Layer with other human-made features and boundaries. This layer is the catch-all and includes all features not covered by the other layers. A typical example for this layer are national park boundaries.</p>"},{"location":"library/Low-Level-DB-Access/","title":"Low-level connections","text":"<p>The <code>NominatimAPIAsync</code> class allows to directly access the underlying database connection to explore the raw data. Nominatim uses SQLAlchemy for building queries. Please refer to the documentation of the library to understand how to write SQL.</p> <p>To get access to a search connection, use the <code>begin()</code> function of your API object. This returns a <code>SearchConnection</code> object described below wrapped in a context manager. Its <code>t</code> property has definitions for all Nominatim search tables. For an overview of available tables, refer to the Development Layout in in the development chapter. Note that only tables that are needed for search are accessible as SQLAlchemy tables.</p> <p>Warning</p> <p>The database layout is not part of the API definition and may change without notice. If you play with the low-level access functions, you need to be prepared for such changes.</p> <p>Here is a simple example, which prints how many places are available in the placex table:</p> <pre><code>import asyncio\nfrom pathlib import Path\nimport sqlalchemy as sa\nfrom nominatim.api import NominatimAPIAsync\n\nasync def print_table_size():\n    api = NominatimAPIAsync(Path('.'))\n\n    async with api.begin() as conn:\n        cnt = await conn.scalar(sa.select(sa.func.count()).select_from(conn.t.placex))\n        print(f'placex table has {cnt} rows.')\n\nasyncio.run(print_table_size())\n</code></pre> <p>Warning</p> <p>Low-level connections may only be used to read data from the database. Do not use it to add or modify data or you might break Nominatim's normal functions.</p>"},{"location":"library/Low-Level-DB-Access/#searchconnection-class","title":"SearchConnection class","text":"<p>An extended SQLAlchemy connection class, that also contains then table definitions. The underlying asynchronous SQLAlchemy connection can be accessed with the 'connection' property. The 't' property is the collection of Nominatim tables.</p>"},{"location":"library/Low-Level-DB-Access/#nominatim.api.SearchConnection.scalar","title":"<code>scalar(sql, params=None)</code>  <code>async</code>","text":"<p>Execute a 'scalar()' query on the connection.</p>"},{"location":"library/Low-Level-DB-Access/#nominatim.api.SearchConnection.execute","title":"<code>execute(sql, params=None)</code>  <code>async</code>","text":"<p>Execute a 'execute()' query on the connection.</p>"},{"location":"library/Low-Level-DB-Access/#nominatim.api.SearchConnection.get_class_table","title":"<code>get_class_table(cls, typ)</code>  <code>async</code>","text":"<p>Lookup up if there is a classtype table for the given category and return a SQLAlchemy table for it, if it exists.</p>"},{"location":"library/Low-Level-DB-Access/#nominatim.api.SearchConnection.get_db_property","title":"<code>get_db_property(name)</code>  <code>async</code>","text":"<p>Get a setting from the database. At the moment, only 'server_version', the version of the database software, can be retrieved with this function.</p> <p>Raises a ValueError if the property does not exist.</p>"},{"location":"library/Low-Level-DB-Access/#nominatim.api.SearchConnection.get_property","title":"<code>get_property(name, cached=True)</code>  <code>async</code>","text":"<p>Get a property from Nominatim's property table.</p> <p>Property values are normally cached so that they are only retrieved from the database when they are queried for the first time with this function. Set 'cached' to False to force reading the property from the database.</p> <p>Raises a ValueError if the property does not exist.</p>"},{"location":"library/NominatimAPI/","title":"The Nominatim API classes","text":"<p>The API classes are the core object of the search library. Always instantiate one of these classes first. The API classes are not threadsafe. You need to instantiate a separate instance for each thread.</p>"},{"location":"library/NominatimAPI/#nominatimapi","title":"NominatimAPI","text":"<p>This class provides a thin synchronous wrapper around the asynchronous Nominatim functions. It creates its own event loop and runs each synchronous function call to completion using that loop.</p>"},{"location":"library/NominatimAPI/#nominatim.api.NominatimAPI.__init__","title":"<code>__init__(project_dir, environ=None)</code>","text":"<p>Initiate a new frontend object with synchronous API functions.</p> <p>Parameters:</p> Name Type Description Default <code>project_dir</code> <code>Path</code> <p>Path to the   project directory   of the local Nominatim installation.</p> required <code>environ</code> <code>Optional[Mapping[str, str]]</code> <p>Mapping of configuration parameters.   When set, replaces any configuration via environment variables.   Settings in this mapping also have precedence over any   parameters found in the <code>.env</code> file of the project directory.</p> <code>None</code>"},{"location":"library/NominatimAPI/#nominatim.api.NominatimAPI.config","title":"<code>config: Configuration</code>  <code>property</code>","text":"<p>Provide read-only access to the configuration used by the API.</p>"},{"location":"library/NominatimAPI/#nominatim.api.NominatimAPI.close","title":"<code>close()</code>","text":"<p>Close all active connections to the database.</p> <p>This function also closes the asynchronous worker loop making the NominatimAPI object unusable.</p>"},{"location":"library/NominatimAPI/#nominatim.api.NominatimAPI.status","title":"<code>status()</code>","text":"<p>Return the status of the database as a dataclass object with the fields described below.</p> <p>Returns:</p> Name Type Description <code>status</code> <code>int</code> <p>A status code as described on the status page.</p> <code>message</code> <code>str</code> <p>Either 'OK' or a human-readable message of the   problem encountered.</p> <code>software_version</code> <code>tuple</code> <p>A tuple with the version of the   Nominatim library consisting of (major, minor, patch, db-patch)   version.</p> <code>database_version</code> <code>tuple</code> <p>A tuple with the version of the library   which was used for the import or last migration.   Also consists of (major, minor, patch, db-patch).</p> <code>data_updated</code> <code>datetime</code> <p>Timestamp with the age of the data.</p>"},{"location":"library/NominatimAPI/#nominatim.api.NominatimAPI.details","title":"<code>details(place, **params)</code>","text":"<p>Get detailed information about a place in the database.</p> <p>The result is a dataclass object with the fields described below or <code>None</code> if the place could not be found in the database.</p> <p>Parameters:</p> Name Type Description Default <code>place</code> <code>PlaceRef</code> <p>Description of the place to look up. See      Place identification      for the various ways to reference a place.</p> required <p>Other Parameters:</p> Name Type Description <code>geometry_output</code> <code>enum</code> <p>Add the full geometry of the place to the result. Multiple formats may be selected. Note that geometries can become quite large. (Default: none)</p> <code>geometry_simplification</code> <code>float</code> <p>Simplification factor to use on the geometries before returning them. The factor expresses the tolerance in degrees from which the geometry may differ. Topology is preserved. (Default: 0.0)</p> <code>address_details</code> <code>bool</code> <p>Add detailed information about the places that make up the address of the requested object. (Default: False)</p> <code>linked_places</code> <code>bool</code> <p>Add detailed information about the places that link to the result. (Default: False)</p> <code>parented_places</code> <code>bool</code> <p>Add detailed information about all places for which the requested object is a parent, i.e. all places for which the object provides the address details. Only POI places can have parents. (Default: False)</p> <code>keywords</code> <code>bool</code> <p>Add detailed information about the search terms used for this place.</p> <p>Returns:</p> Name Type Description <code>source_table</code> <code>enum</code> <p>Data source of the place. See below for possible values.</p> <code>category</code> <code>tuple</code> <p>A tuple of two strings with the primary OSM tag   and value.</p> <code>centroid</code> <code>Point</code> <p>Point position of the place.</p> <code>place_id</code> <code>Optional[int]</code> <p>Internal ID of the place. This ID may differ   for the same place between different installations.</p> <code>parent_place_id</code> <code>Optional(int]</code> <p>Internal ID of the parent of this   place. Only meaning full for POI-like objects (places with a   rank_address of 30).</p> <code>linked_place_id</code> <code>Optional[int]</code> <p>Internal ID of the place this object   links to. When this ID is set then there is no guarantee that   the rest of the result information is complete.</p> <code>admin_level</code> <code>int</code> <p>Value of the <code>admin_level</code> OSM tag. Only meaningful   for administrative boundary objects.</p> <code>indexed_date</code> <code>datetime</code> <p>Timestamp when the place was last updated.</p> <code>osm_object</code> <code>Optional[tuple]</code> <p>OSM type and ID of the place, if available.</p> <code>names</code> <code>Optional[dict]</code> <p>Dictionary of names of the place. Keys are   usually the corresponding OSM tag keys.</p> <code>address</code> <code>Optional[dict]</code> <p>Dictionary of address parts directly   attributed to the place. Keys are usually the corresponding   OSM tag keys with the <code>addr:</code> prefix removed.</p> <code>extratags</code> <code>Optional[dict]</code> <p>Dictionary of additional attributes for   the place. Usually OSM tag keys and values.</p> <code>housenumber</code> <code>Optional[str]</code> <p>House number of the place, normalised   for lookup. To get the house number in its original spelling,   use <code>address['housenumber']</code>.</p> <code>postcode</code> <code>Optional[str]</code> <p>Computed postcode for the place. To get   directly attributed postcodes, use <code>address['postcode']</code> instead.</p> <code>wikipedia</code> <code>Optional[str]</code> <p>Reference to a wikipedia site for the place.   The string has the format :. <code>rank_address</code> <code>int</code> <p>Address rank.</p> <code>rank_search</code> <code>int</code> <p>Search rank.</p> <code>importance</code> <code>Optional[float]</code> <p>Relative importance of the place. This is a measure   how likely the place will be searched for.</p> <code>country_code</code> <code>Optional[str]</code> <p>Country the feature is in as   ISO 3166-1 alpha-2 country code.</p> <code>address_rows</code> <code>Optional[AddressLines]</code> <p>List of places that make up the   computed address. <code>None</code> when <code>address_details</code> parameter was False.</p> <code>linked_rows</code> <code>Optional[AddressLines]</code> <p>List of places that link to the object.   <code>None</code> when <code>linked_places</code> parameter was False.</p> <code>parented_rows</code> <code>Optional[AddressLines]</code> <p>List of direct children of the place.   <code>None</code> when <code>parented_places</code> parameter was False.</p> <code>name_keywords</code> <code>Optional[WordInfos]</code> <p>List of search words for the name of    the place. <code>None</code> when <code>keywords</code> parameter is set to False.</p> <code>address_keywords</code> <code>Optional[WordInfos]</code> <p>List of search word for the address of    the place. <code>None</code> when <code>keywords</code> parameter is set to False.</p> <code>geometry</code> <code>dict</code> <p>Dictionary containing the full geometry of the place    in the formats requested in the <code>geometry_output</code> parameter.</p>"},{"location":"library/NominatimAPI/#nominatim.api.NominatimAPI.lookup","title":"<code>lookup(places, **params)</code>","text":"<p>Get simple information about a list of places.</p> <p>Returns a list of place information for all IDs that were found. Each result is a dataclass with the fields detailed below.</p> <p>Parameters:</p> Name Type Description Default <code>places</code> <code>Sequence[PlaceRef]</code> <p>List of descriptions of the place to look up. See       Place identification       for the various ways to reference a place.</p> required <p>Other Parameters:</p> Name Type Description <code>geometry_output</code> <code>enum</code> <p>Add the full geometry of the place to the result. Multiple formats may be selected. Note that geometries can become quite large. (Default: none)</p> <code>geometry_simplification</code> <code>float</code> <p>Simplification factor to use on the geometries before returning them. The factor expresses the tolerance in degrees from which the geometry may differ. Topology is preserved. (Default: 0.0)</p> <code>address_details</code> <code>bool</code> <p>Add detailed information about the places that make up the address of the requested object. (Default: False)</p> <code>linked_places</code> <code>bool</code> <p>Add detailed information about the places that link to the result. (Default: False)</p> <code>parented_places</code> <code>bool</code> <p>Add detailed information about all places for which the requested object is a parent, i.e. all places for which the object provides the address details. Only POI places can have parents. (Default: False)</p> <code>keywords</code> <code>bool</code> <p>Add detailed information about the search terms used for this place.</p> <p>Returns:</p> Name Type Description <code>source_table</code> <code>enum</code> <p>Data source of the place. See below for possible values.</p> <code>category</code> <code>tuple</code> <p>A tuple of two strings with the primary OSM tag   and value.</p> <code>centroid</code> <code>Point</code> <p>Point position of the place.</p> <code>place_id</code> <code>Optional[int]</code> <p>Internal ID of the place. This ID may differ   for the same place between different installations.</p> <code>osm_object</code> <code>Optional[tuple]</code> <p>OSM type and ID of the place, if available.</p> <code>names</code> <code>Optional[dict]</code> <p>Dictionary of names of the place. Keys are   usually the corresponding OSM tag keys.</p> <code>address</code> <code>Optional[dict]</code> <p>Dictionary of address parts directly   attributed to the place. Keys are usually the corresponding   OSM tag keys with the <code>addr:</code> prefix removed.</p> <code>extratags</code> <code>Optional[dict]</code> <p>Dictionary of additional attributes for   the place. Usually OSM tag keys and values.</p> <code>housenumber</code> <code>Optional[str]</code> <p>House number of the place, normalised   for lookup. To get the house number in its original spelling,   use <code>address['housenumber']</code>.</p> <code>postcode</code> <code>Optional[str]</code> <p>Computed postcode for the place. To get   directly attributed postcodes, use <code>address['postcode']</code> instead.</p> <code>wikipedia</code> <code>Optional[str]</code> <p>Reference to a wikipedia site for the place.   The string has the format :. <code>rank_address</code> <code>int</code> <p>Address rank.</p> <code>rank_search</code> <code>int</code> <p>Search rank.</p> <code>importance</code> <code>Optional[float]</code> <p>Relative importance of the place. This is a measure   how likely the place will be searched for.</p> <code>country_code</code> <code>Optional[str]</code> <p>Country the feature is in as   ISO 3166-1 alpha-2 country code.</p> <code>address_rows</code> <code>Optional[AddressLines]</code> <p>List of places that make up the   computed address. <code>None</code> when <code>address_details</code> parameter was False.</p> <code>linked_rows</code> <code>Optional[AddressLines]</code> <p>List of places that link to the object.   <code>None</code> when <code>linked_places</code> parameter was False.</p> <code>parented_rows</code> <code>Optional[AddressLines]</code> <p>List of direct children of the place.   <code>None</code> when <code>parented_places</code> parameter was False.</p> <code>name_keywords</code> <code>Optional[WordInfos]</code> <p>List of search words for the name of    the place. <code>None</code> when <code>keywords</code> parameter is set to False.</p> <code>address_keywords</code> <code>Optional[WordInfos]</code> <p>List of search word for the address of    the place. <code>None</code> when <code>keywords</code> parameter is set to False.</p> <code>bbox</code> <code>Bbox</code> <p>Bounding box of the full geometry of the place.    If the place is a single point, then the size of the bounding    box is guessed according to the type of place.</p> <code>geometry</code> <code>dict</code> <p>Dictionary containing the full geometry of the place    in the formats requested in the <code>geometry_output</code> parameter.</p>"},{"location":"library/NominatimAPI/#nominatim.api.NominatimAPI.reverse","title":"<code>reverse(coord, **params)</code>","text":"<p>Find a place by its coordinates. Also known as reverse geocoding.</p> <p>Returns the closest result that can be found or <code>None</code> if no place matches the given criteria. The result is a dataclass with the fields as detailed below.</p> <p>Parameters:</p> Name Type Description Default <code>coord</code> <code>AnyPoint</code> <p>Coordinate to lookup the place for as a Point      or a tuple (x, y). Must be in WGS84 projection.</p> required <p>Other Parameters:</p> Name Type Description <code>max_rank</code> <code>int</code> <p>Highest address rank to return. Can be used to restrict search to streets or settlements.</p> <code>layers</code> <code>enum</code> <p>Defines the kind of data to take into account. See description of layers below. (Default: addresses and POIs)</p> <code>geometry_output</code> <code>enum</code> <p>Add the full geometry of the place to the result. Multiple formats may be selected. Note that geometries can become quite large. (Default: none)</p> <code>geometry_simplification</code> <code>float</code> <p>Simplification factor to use on the geometries before returning them. The factor expresses the tolerance in degrees from which the geometry may differ. Topology is preserved. (Default: 0.0)</p> <code>address_details</code> <code>bool</code> <p>Add detailed information about the places that make up the address of the requested object. (Default: False)</p> <code>linked_places</code> <code>bool</code> <p>Add detailed information about the places that link to the result. (Default: False)</p> <code>parented_places</code> <code>bool</code> <p>Add detailed information about all places for which the requested object is a parent, i.e. all places for which the object provides the address details. Only POI places can have parents. (Default: False)</p> <code>keywords</code> <code>bool</code> <p>Add detailed information about the search terms used for this place.</p> <p>Returns:</p> Name Type Description <code>source_table</code> <code>enum</code> <p>Data source of the place. See below for possible values.</p> <code>category</code> <code>tuple</code> <p>A tuple of two strings with the primary OSM tag   and value.</p> <code>centroid</code> <code>Point</code> <p>Point position of the place.</p> <code>place_id</code> <code>Optional[int]</code> <p>Internal ID of the place. This ID may differ   for the same place between different installations.</p> <code>osm_object</code> <code>Optional[tuple]</code> <p>OSM type and ID of the place, if available.</p> <code>names</code> <code>Optional[dict]</code> <p>Dictionary of names of the place. Keys are   usually the corresponding OSM tag keys.</p> <code>address</code> <code>Optional[dict]</code> <p>Dictionary of address parts directly   attributed to the place. Keys are usually the corresponding   OSM tag keys with the <code>addr:</code> prefix removed.</p> <code>extratags</code> <code>Optional[dict]</code> <p>Dictionary of additional attributes for   the place. Usually OSM tag keys and values.</p> <code>housenumber</code> <code>Optional[str]</code> <p>House number of the place, normalised   for lookup. To get the house number in its original spelling,   use <code>address['housenumber']</code>.</p> <code>postcode</code> <code>Optional[str]</code> <p>Computed postcode for the place. To get   directly attributed postcodes, use <code>address['postcode']</code> instead.</p> <code>wikipedia</code> <code>Optional[str]</code> <p>Reference to a wikipedia site for the place.   The string has the format :. <code>rank_address</code> <code>int</code> <p>Address rank.</p> <code>rank_search</code> <code>int</code> <p>Search rank.</p> <code>importance</code> <code>Optional[float]</code> <p>Relative importance of the place. This is a measure   how likely the place will be searched for.</p> <code>country_code</code> <code>Optional[str]</code> <p>Country the feature is in as   ISO 3166-1 alpha-2 country code.</p> <code>address_rows</code> <code>Optional[AddressLines]</code> <p>List of places that make up the   computed address. <code>None</code> when <code>address_details</code> parameter was False.</p> <code>linked_rows</code> <code>Optional[AddressLines]</code> <p>List of places that link to the object.   <code>None</code> when <code>linked_places</code> parameter was False.</p> <code>parented_rows</code> <code>Optional[AddressLines]</code> <p>List of direct children of the place.   <code>None</code> when <code>parented_places</code> parameter was False.</p> <code>name_keywords</code> <code>Optional[WordInfos]</code> <p>List of search words for the name of    the place. <code>None</code> when <code>keywords</code> parameter is set to False.</p> <code>address_keywords</code> <code>Optional[WordInfos]</code> <p>List of search word for the address of    the place. <code>None</code> when <code>keywords</code> parameter is set to False.</p> <code>bbox</code> <code>Bbox</code> <p>Bounding box of the full geometry of the place.    If the place is a single point, then the size of the bounding    box is guessed according to the type of place.</p> <code>geometry</code> <code>dict</code> <p>Dictionary containing the full geometry of the place    in the formats requested in the <code>geometry_output</code> parameter.</p> <code>distance</code> <code>Optional[float]</code> <p>Distance in degree from the input point.</p>"},{"location":"library/NominatimAPI/#nominatim.api.NominatimAPI.search","title":"<code>search(query, **params)</code>","text":"<p>Find a place by free-text search. Also known as forward geocoding.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>Free-form text query searching for a place.</p> required <p>Other Parameters:</p> Name Type Description <code>max_results</code> <code>int</code> <p>Maximum number of results to return. The actual number of results may be less. (Default: 10)</p> <code>min_rank</code> <code>int</code> <p>Lowest permissible rank for the result. For addressable places this is the minimum address rank. For all other places the search rank is used.</p> <code>max_rank</code> <code>int</code> <p>Highest permissible rank for the result. See min_rank above.</p> <code>layers</code> <code>enum</code> <p>Defines the kind of data to take into account. See layers section for details. (Default: addresses and POIs)</p> <code>countries</code> <code>list[str]</code> <p>Restrict search to countries with the given ISO 3166-1 alpha-2 country code. An empty list (the default) disables this filter.</p> <code>excluded</code> <code>list[int]</code> <p>A list of internal IDs of places to exclude from the search.</p> <code>viewbox</code> <code>Optional[Bbox]</code> <p>Bounding box of an area to focus search on.</p> <code>bounded_viewbox</code> <code>bool</code> <p>Consider the bounding box given in <code>viewbox</code> as a filter and return only results within the bounding box.</p> <code>near</code> <code>Optional[Point]</code> <p>Focus search around the given point and return results ordered by distance to the given point.</p> <code>near_radius</code> <code>Optional[float]</code> <p>Restrict results to results within the given distance in degrees of <code>near</code> point. Ignored, when <code>near</code> is not set.</p> <code>categories</code> <code>list[tuple]</code> <p>Restrict search to places of the given categories. The category is the main OSM tag assigned to each place. An empty list (the default) disables this filter.</p> <code>geometry_output</code> <code>enum</code> <p>Add the full geometry of the place to the result. Multiple formats may be selected. Note that geometries can become quite large. (Default: none)</p> <code>geometry_simplification</code> <code>float</code> <p>Simplification factor to use on the geometries before returning them. The factor expresses the tolerance in degrees from which the geometry may differ. Topology is preserved. (Default: 0.0)</p> <code>address_details</code> <code>bool</code> <p>Add detailed information about the places that make up the address of the requested object. (Default: False)</p> <code>linked_places</code> <code>bool</code> <p>Add detailed information about the places that link to the result. (Default: False)</p> <code>parented_places</code> <code>bool</code> <p>Add detailed information about all places for which the requested object is a parent, i.e. all places for which the object provides the address details. Only POI places can have parents. (Default: False)</p> <code>keywords</code> <code>bool</code> <p>Add detailed information about the search terms used for this place.</p> <p>Returns:</p> Name Type Description <code>source_table</code> <code>enum</code> <p>Data source of the place. See below for possible values.</p> <code>category</code> <code>tuple</code> <p>A tuple of two strings with the primary OSM tag   and value.</p> <code>centroid</code> <code>Point</code> <p>Point position of the place.</p> <code>place_id</code> <code>Optional[int]</code> <p>Internal ID of the place. This ID may differ   for the same place between different installations.</p> <code>osm_object</code> <code>Optional[tuple]</code> <p>OSM type and ID of the place, if available.</p> <code>names</code> <code>Optional[dict]</code> <p>Dictionary of names of the place. Keys are   usually the corresponding OSM tag keys.</p> <code>address</code> <code>Optional[dict]</code> <p>Dictionary of address parts directly   attributed to the place. Keys are usually the corresponding   OSM tag keys with the <code>addr:</code> prefix removed.</p> <code>extratags</code> <code>Optional[dict]</code> <p>Dictionary of additional attributes for   the place. Usually OSM tag keys and values.</p> <code>housenumber</code> <code>Optional[str]</code> <p>House number of the place, normalised   for lookup. To get the house number in its original spelling,   use <code>address['housenumber']</code>.</p> <code>postcode</code> <code>Optional[str]</code> <p>Computed postcode for the place. To get   directly attributed postcodes, use <code>address['postcode']</code> instead.</p> <code>wikipedia</code> <code>Optional[str]</code> <p>Reference to a wikipedia site for the place.   The string has the format :. <code>rank_address</code> <code>int</code> <p>Address rank.</p> <code>rank_search</code> <code>int</code> <p>Search rank.</p> <code>importance</code> <code>Optional[float]</code> <p>Relative importance of the place. This is a measure   how likely the place will be searched for.</p> <code>country_code</code> <code>Optional[str]</code> <p>Country the feature is in as   ISO 3166-1 alpha-2 country code.</p> <code>address_rows</code> <code>Optional[AddressLines]</code> <p>List of places that make up the   computed address. <code>None</code> when <code>address_details</code> parameter was False.</p> <code>linked_rows</code> <code>Optional[AddressLines]</code> <p>List of places that link to the object.   <code>None</code> when <code>linked_places</code> parameter was False.</p> <code>parented_rows</code> <code>Optional[AddressLines]</code> <p>List of direct children of the place.   <code>None</code> when <code>parented_places</code> parameter was False.</p> <code>name_keywords</code> <code>Optional[WordInfos]</code> <p>List of search words for the name of    the place. <code>None</code> when <code>keywords</code> parameter is set to False.</p> <code>address_keywords</code> <code>Optional[WordInfos]</code> <p>List of search word for the address of    the place. <code>None</code> when <code>keywords</code> parameter is set to False.</p> <code>bbox</code> <code>Bbox</code> <p>Bounding box of the full geometry of the place.    If the place is a single point, then the size of the bounding    box is guessed according to the type of place.</p> <code>geometry</code> <code>dict</code> <p>Dictionary containing the full geometry of the place    in the formats requested in the <code>geometry_output</code> parameter.</p>"},{"location":"library/NominatimAPI/#nominatim.api.NominatimAPI.search_address","title":"<code>search_address(amenity=None, street=None, city=None, county=None, state=None, country=None, postalcode=None, **params)</code>","text":"<p>Find an address using structured search.</p> <p>Parameters:</p> Name Type Description Default <code>amenity</code> <code>Optional[str]</code> <p>Name of a POI.</p> <code>None</code> <code>street</code> <code>Optional[str]</code> <p>Street and optionally housenumber of the address. If the address does not have a street, then the place the housenumber references to.</p> <code>None</code> <code>city</code> <code>Optional[str]</code> <p>Postal city of the address.</p> <code>None</code> <code>county</code> <code>Optional[str]</code> <p>County equivalent of the address. Does not exist in all jurisdictions.</p> <code>None</code> <code>state</code> <code>Optional[str]</code> <p>State or province of the address.</p> <code>None</code> <code>country</code> <code>Optional[str]</code> <p>Country with its full name or its ISO 3166-1 alpha-2 country code. Do not use together with the country_code filter.</p> <code>None</code> <code>postalcode</code> <code>Optional[str]</code> <p>Post code or ZIP for the place.</p> <code>None</code> <p>Other Parameters:</p> Name Type Description <code>max_results</code> <code>int</code> <p>Maximum number of results to return. The actual number of results may be less. (Default: 10)</p> <code>min_rank</code> <code>int</code> <p>Lowest permissible rank for the result. For addressable places this is the minimum address rank. For all other places the search rank is used.</p> <code>max_rank</code> <code>int</code> <p>Highest permissible rank for the result. See min_rank above.</p> <code>layers</code> <code>enum</code> <p>Defines the kind of data to take into account. See layers section for details. (Default: addresses and POIs)</p> <code>countries</code> <code>list[str]</code> <p>Restrict search to countries with the given ISO 3166-1 alpha-2 country code. An empty list (the default) disables this filter. Do not use, when the country parameter is used.</p> <code>excluded</code> <code>list[int]</code> <p>A list of internal IDs of places to exclude from the search.</p> <code>viewbox</code> <code>Optional[Bbox]</code> <p>Bounding box of an area to focus search on.</p> <code>bounded_viewbox</code> <code>bool</code> <p>Consider the bounding box given in <code>viewbox</code> as a filter and return only results within the bounding box.</p> <code>near</code> <code>Optional[Point]</code> <p>Focus search around the given point and return results ordered by distance to the given point.</p> <code>near_radius</code> <code>Optional[float]</code> <p>Restrict results to results within the given distance in degrees of <code>near</code> point. Ignored, when <code>near</code> is not set.</p> <code>categories</code> <code>list[tuple]</code> <p>Restrict search to places of the given categories. The category is the main OSM tag assigned to each place. An empty list (the default) disables this filter.</p> <code>geometry_output</code> <code>enum</code> <p>Add the full geometry of the place to the result. Multiple formats may be selected. Note that geometries can become quite large. (Default: none)</p> <code>geometry_simplification</code> <code>float</code> <p>Simplification factor to use on the geometries before returning them. The factor expresses the tolerance in degrees from which the geometry may differ. Topology is preserved. (Default: 0.0)</p> <code>address_details</code> <code>bool</code> <p>Add detailed information about the places that make up the address of the requested object. (Default: False)</p> <code>linked_places</code> <code>bool</code> <p>Add detailed information about the places that link to the result. (Default: False)</p> <code>parented_places</code> <code>bool</code> <p>Add detailed information about all places for which the requested object is a parent, i.e. all places for which the object provides the address details. Only POI places can have parents. (Default: False)</p> <code>keywords</code> <code>bool</code> <p>Add detailed information about the search terms used for this place.</p> <p>Returns:</p> Name Type Description <code>source_table</code> <code>enum</code> <p>Data source of the place. See below for possible values.</p> <code>category</code> <code>tuple</code> <p>A tuple of two strings with the primary OSM tag   and value.</p> <code>centroid</code> <code>Point</code> <p>Point position of the place.</p> <code>place_id</code> <code>Optional[int]</code> <p>Internal ID of the place. This ID may differ   for the same place between different installations.</p> <code>osm_object</code> <code>Optional[tuple]</code> <p>OSM type and ID of the place, if available.</p> <code>names</code> <code>Optional[dict]</code> <p>Dictionary of names of the place. Keys are   usually the corresponding OSM tag keys.</p> <code>address</code> <code>Optional[dict]</code> <p>Dictionary of address parts directly   attributed to the place. Keys are usually the corresponding   OSM tag keys with the <code>addr:</code> prefix removed.</p> <code>extratags</code> <code>Optional[dict]</code> <p>Dictionary of additional attributes for   the place. Usually OSM tag keys and values.</p> <code>housenumber</code> <code>Optional[str]</code> <p>House number of the place, normalised   for lookup. To get the house number in its original spelling,   use <code>address['housenumber']</code>.</p> <code>postcode</code> <code>Optional[str]</code> <p>Computed postcode for the place. To get   directly attributed postcodes, use <code>address['postcode']</code> instead.</p> <code>wikipedia</code> <code>Optional[str]</code> <p>Reference to a wikipedia site for the place.   The string has the format :. <code>rank_address</code> <code>int</code> <p>Address rank.</p> <code>rank_search</code> <code>int</code> <p>Search rank.</p> <code>importance</code> <code>Optional[float]</code> <p>Relative importance of the place. This is a measure   how likely the place will be searched for.</p> <code>country_code</code> <code>Optional[str]</code> <p>Country the feature is in as   ISO 3166-1 alpha-2 country code.</p> <code>address_rows</code> <code>Optional[AddressLines]</code> <p>List of places that make up the   computed address. <code>None</code> when <code>address_details</code> parameter was False.</p> <code>linked_rows</code> <code>Optional[AddressLines]</code> <p>List of places that link to the object.   <code>None</code> when <code>linked_places</code> parameter was False.</p> <code>parented_rows</code> <code>Optional[AddressLines]</code> <p>List of direct children of the place.   <code>None</code> when <code>parented_places</code> parameter was False.</p> <code>name_keywords</code> <code>Optional[WordInfos]</code> <p>List of search words for the name of    the place. <code>None</code> when <code>keywords</code> parameter is set to False.</p> <code>address_keywords</code> <code>Optional[WordInfos]</code> <p>List of search word for the address of    the place. <code>None</code> when <code>keywords</code> parameter is set to False.</p> <code>bbox</code> <code>Bbox</code> <p>Bounding box of the full geometry of the place.    If the place is a single point, then the size of the bounding    box is guessed according to the type of place.</p> <code>geometry</code> <code>dict</code> <p>Dictionary containing the full geometry of the place    in the formats requested in the <code>geometry_output</code> parameter.</p>"},{"location":"library/NominatimAPI/#nominatim.api.NominatimAPI.search_category","title":"<code>search_category(categories, near_query=None, **params)</code>","text":"<p>Find an object of a certain category near another place.</p> <p>The near place may either be given as an unstructured search query in itself or as a geographic area through the viewbox or near parameters.</p> <p>Parameters:</p> Name Type Description Default <code>categories</code> <code>List[Tuple[str, str]]</code> <p>Restrict search to places of the given categories. The category is the main OSM tag assigned to each place.</p> required <code>near_query</code> <code>Optional[str]</code> <p>Optional free-text query to define the are to restrict search to.</p> <code>None</code> <p>Other Parameters:</p> Name Type Description <code>max_results</code> <code>int</code> <p>Maximum number of results to return. The actual number of results may be less. (Default: 10)</p> <code>min_rank</code> <code>int</code> <p>Lowest permissible rank for the result. For addressable places this is the minimum address rank. For all other places the search rank is used.</p> <code>max_rank</code> <code>int</code> <p>Highest permissible rank for the result. See min_rank above.</p> <code>layers</code> <code>enum</code> <p>Defines the kind of data to take into account. See layers section for details. (Default: addresses and POIs)</p> <code>countries</code> <code>list[str]</code> <p>Restrict search to countries with the given ISO 3166-1 alpha-2 country code. An empty list (the default) disables this filter.</p> <code>excluded</code> <code>list[int]</code> <p>A list of internal IDs of places to exclude from the search.</p> <code>viewbox</code> <code>Optional[Bbox]</code> <p>Bounding box of an area to focus search on.</p> <code>bounded_viewbox</code> <code>bool</code> <p>Consider the bounding box given in <code>viewbox</code> as a filter and return only results within the bounding box.</p> <code>near</code> <code>Optional[Point]</code> <p>Focus search around the given point and return results ordered by distance to the given point.</p> <code>near_radius</code> <code>Optional[float]</code> <p>Restrict results to results within the given distance in degrees of <code>near</code> point. Ignored, when <code>near</code> is not set.</p> <code>geometry_output</code> <code>enum</code> <p>Add the full geometry of the place to the result. Multiple formats may be selected. Note that geometries can become quite large. (Default: none)</p> <code>geometry_simplification</code> <code>float</code> <p>Simplification factor to use on the geometries before returning them. The factor expresses the tolerance in degrees from which the geometry may differ. Topology is preserved. (Default: 0.0)</p> <code>address_details</code> <code>bool</code> <p>Add detailed information about the places that make up the address of the requested object. (Default: False)</p> <code>linked_places</code> <code>bool</code> <p>Add detailed information about the places that link to the result. (Default: False)</p> <code>parented_places</code> <code>bool</code> <p>Add detailed information about all places for which the requested object is a parent, i.e. all places for which the object provides the address details. Only POI places can have parents. (Default: False)</p> <code>keywords</code> <code>bool</code> <p>Add detailed information about the search terms used for this place.</p> <p>Returns:</p> Name Type Description <code>source_table</code> <code>enum</code> <p>Data source of the place. See below for possible values.</p> <code>category</code> <code>tuple</code> <p>A tuple of two strings with the primary OSM tag   and value.</p> <code>centroid</code> <code>Point</code> <p>Point position of the place.</p> <code>place_id</code> <code>Optional[int]</code> <p>Internal ID of the place. This ID may differ   for the same place between different installations.</p> <code>osm_object</code> <code>Optional[tuple]</code> <p>OSM type and ID of the place, if available.</p> <code>names</code> <code>Optional[dict]</code> <p>Dictionary of names of the place. Keys are   usually the corresponding OSM tag keys.</p> <code>address</code> <code>Optional[dict]</code> <p>Dictionary of address parts directly   attributed to the place. Keys are usually the corresponding   OSM tag keys with the <code>addr:</code> prefix removed.</p> <code>extratags</code> <code>Optional[dict]</code> <p>Dictionary of additional attributes for   the place. Usually OSM tag keys and values.</p> <code>housenumber</code> <code>Optional[str]</code> <p>House number of the place, normalised   for lookup. To get the house number in its original spelling,   use <code>address['housenumber']</code>.</p> <code>postcode</code> <code>Optional[str]</code> <p>Computed postcode for the place. To get   directly attributed postcodes, use <code>address['postcode']</code> instead.</p> <code>wikipedia</code> <code>Optional[str]</code> <p>Reference to a wikipedia site for the place.   The string has the format :. <code>rank_address</code> <code>int</code> <p>Address rank.</p> <code>rank_search</code> <code>int</code> <p>Search rank.</p> <code>importance</code> <code>Optional[float]</code> <p>Relative importance of the place. This is a measure   how likely the place will be searched for.</p> <code>country_code</code> <code>Optional[str]</code> <p>Country the feature is in as   ISO 3166-1 alpha-2 country code.</p> <code>address_rows</code> <code>Optional[AddressLines]</code> <p>List of places that make up the   computed address. <code>None</code> when <code>address_details</code> parameter was False.</p> <code>linked_rows</code> <code>Optional[AddressLines]</code> <p>List of places that link to the object.   <code>None</code> when <code>linked_places</code> parameter was False.</p> <code>parented_rows</code> <code>Optional[AddressLines]</code> <p>List of direct children of the place.   <code>None</code> when <code>parented_places</code> parameter was False.</p> <code>name_keywords</code> <code>Optional[WordInfos]</code> <p>List of search words for the name of    the place. <code>None</code> when <code>keywords</code> parameter is set to False.</p> <code>address_keywords</code> <code>Optional[WordInfos]</code> <p>List of search word for the address of    the place. <code>None</code> when <code>keywords</code> parameter is set to False.</p> <code>bbox</code> <code>Bbox</code> <p>Bounding box of the full geometry of the place.    If the place is a single point, then the size of the bounding    box is guessed according to the type of place.</p> <code>geometry</code> <code>dict</code> <p>Dictionary containing the full geometry of the place    in the formats requested in the <code>geometry_output</code> parameter.</p>"},{"location":"library/NominatimAPI/#nominatimapiasync","title":"NominatimAPIAsync","text":"<p>The main frontend to the Nominatim database implements the functions for lookup, forward and reverse geocoding using asynchronous functions.</p> <p>This class shares most of the functions with its synchronous version. There are some additional functions or parameters, which are documented below.</p>"},{"location":"library/NominatimAPI/#nominatim.api.NominatimAPIAsync.__init__","title":"<code>__init__(project_dir, environ=None, loop=None)</code>","text":"<p>Initiate a new frontend object with synchronous API functions.</p> <p>Parameters:</p> Name Type Description Default <code>project_dir</code> <code>Path</code> <p>Path to the   project directory   of the local Nominatim installation.</p> required <code>environ</code> <code>Optional[Mapping[str, str]]</code> <p>Mapping of configuration parameters.   When set, replaces any configuration via environment variables.   Settings in this mapping also have precedence over any   parameters found in the <code>.env</code> file of the project directory.</p> <code>None</code> <code>loop</code> <code>Optional[AbstractEventLoop]</code> <p>The asyncio event loop that will be used when calling   functions. Only needed, when a custom event loop is used   and the Python version is 3.9 or earlier.</p> <code>None</code>"},{"location":"library/NominatimAPI/#nominatim.api.NominatimAPIAsync.setup_database","title":"<code>setup_database()</code>  <code>async</code>","text":"<p>Set up the SQL engine and connections.</p> <p>This function will be implicitly called when the database is accessed for the first time. You may also call it explicitly to avoid that the first call is delayed by the setup.</p>"},{"location":"library/NominatimAPI/#nominatim.api.NominatimAPIAsync.close","title":"<code>close()</code>  <code>async</code>","text":"<p>Close all active connections to the database. The NominatimAPIAsync object remains usable after closing. If a new API functions is called, new connections are created.</p>"},{"location":"library/NominatimAPI/#nominatim.api.NominatimAPIAsync.begin","title":"<code>begin()</code>  <code>async</code>","text":"<p>Create a new connection with automatic transaction handling.</p> <p>This function may be used to get low-level access to the database. Refer to the documentation of SQLAlchemy for details how to use the connection object.</p>"},{"location":"library/Result-Handling/","title":"Result handling","text":"<p>The search functions of the Nominatim API always return a result object with the raw information about the place that is available in the database. This section discusses data types used in the results and utility functions that allow further processing of the results.</p>"},{"location":"library/Result-Handling/#result-fields","title":"Result fields","text":""},{"location":"library/Result-Handling/#sources","title":"Sources","text":"<p>Nominatim takes the result data from multiple sources. The <code>source_table</code> field in the result describes, from which source the result was retrieved.</p> <p>The <code>SourceTable</code> type lists the possible sources a result can have.</p>"},{"location":"library/Result-Handling/#nominatim.api.SourceTable.PLACEX","title":"<code>PLACEX = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The placex table is the main source for result usually containing OSM data.</p>"},{"location":"library/Result-Handling/#nominatim.api.SourceTable.OSMLINE","title":"<code>OSMLINE = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The osmline table contains address interpolations from OSM data. Interpolation addresses are always approximate. The OSM id in the result refers to the OSM way with the interpolation line object.</p>"},{"location":"library/Result-Handling/#nominatim.api.SourceTable.TIGER","title":"<code>TIGER = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>TIGER address data contains US addresses imported on the side, see Installing TIGER data. TIGER address are also interpolations. The addresses always refer to a street from OSM data. The OSM id in the result refers to that street.</p>"},{"location":"library/Result-Handling/#nominatim.api.SourceTable.POSTCODE","title":"<code>POSTCODE = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The postcode table contains artificial centroids for postcodes, computed from the postcodes available with address points. Results are always approximate.</p>"},{"location":"library/Result-Handling/#nominatim.api.SourceTable.COUNTRY","title":"<code>COUNTRY = 5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The country table provides a fallback, when country data is missing in the OSM data.</p>"},{"location":"library/Result-Handling/#detailed-address-description","title":"Detailed address description","text":"<p>When the <code>address_details</code> parameter is set, then functions return not only information about the result place but also about the place that make up the address. This information is almost always required when you want to present the user with a human-readable description of the result. See also Localization below.</p> <p>The address details are available in the <code>address_rows</code> field as a ordered list of <code>AddressLine</code> objects with the country information last. The list also contains the result place itself and some artificial entries, for example, for the house number or the country code. This makes processing and creating a full address easier.</p> <p>The <code>AddressLine</code> may contain the following fields about a related place and its function as an address object. Most fields are optional. Their presence depends on the kind and function of the address part.</p>"},{"location":"library/Result-Handling/#nominatim.api.AddressLine.category","title":"<code>category: Tuple[str, str]</code>  <code>instance-attribute</code>","text":"<p>Main category of the place, described by a key-value pair.</p>"},{"location":"library/Result-Handling/#nominatim.api.AddressLine.names","title":"<code>names: Dict[str, str]</code>  <code>instance-attribute</code>","text":"<p>All available names for the place including references, alternative names and translations.</p>"},{"location":"library/Result-Handling/#nominatim.api.AddressLine.fromarea","title":"<code>fromarea: bool</code>  <code>instance-attribute</code>","text":"<p>If true, then the exact area of the place is known. Without area information, Nominatim has to make an educated guess if an address belongs to one place or another.</p>"},{"location":"library/Result-Handling/#nominatim.api.AddressLine.isaddress","title":"<code>isaddress: bool</code>  <code>instance-attribute</code>","text":"<p>If true, this place should be considered for the final address display. Nominatim will sometimes include more than one candidate for the address in the list when it cannot reliably determine where the place belongs. It will consider names of all candidates when searching but when displaying the result, only the most likely candidate should be shown.</p>"},{"location":"library/Result-Handling/#nominatim.api.AddressLine.rank_address","title":"<code>rank_address: int</code>  <code>instance-attribute</code>","text":"<p>Address rank of the place.</p>"},{"location":"library/Result-Handling/#nominatim.api.AddressLine.distance","title":"<code>distance: float</code>  <code>instance-attribute</code>","text":"<p>Distance in degrees between the result place and this address part.</p>"},{"location":"library/Result-Handling/#nominatim.api.AddressLine.place_id","title":"<code>place_id: Optional[int] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Internal ID of the place.</p>"},{"location":"library/Result-Handling/#nominatim.api.AddressLine.osm_object","title":"<code>osm_object: Optional[Tuple[str, int]] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>OSM type and ID of the place, if such an object exists.</p>"},{"location":"library/Result-Handling/#nominatim.api.AddressLine.extratags","title":"<code>extratags: Optional[Dict[str, str]] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Any extra information available about the place. This is a dictionary that usually contains OSM tag key-value pairs.</p>"},{"location":"library/Result-Handling/#nominatim.api.AddressLine.admin_level","title":"<code>admin_level: Optional[int] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The administrative level of a boundary as tagged in the input data. This field is only meaningful for places of the category (boundary, administrative).</p>"},{"location":"library/Result-Handling/#nominatim.api.AddressLine.local_name","title":"<code>local_name: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Place holder for localization of this address part. See Localization below.</p>"},{"location":"library/Result-Handling/#detailed-search-terms","title":"Detailed search terms","text":"<p>The <code>details</code> function can return detailed information about which search terms may be used to find a place, when the <code>keywords</code> parameter is set. Search terms are split into terms for the name of the place and search terms for its address.</p> <p>Each entry in the list of search terms contains the following detailed information.</p>"},{"location":"library/Result-Handling/#nominatim.api.WordInfo.word","title":"<code>word: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Untransliterated form, if available.</p>"},{"location":"library/Result-Handling/#nominatim.api.WordInfo.word_id","title":"<code>word_id: int</code>  <code>instance-attribute</code>","text":"<p>Internal identifier for the word.</p>"},{"location":"library/Result-Handling/#nominatim.api.WordInfo.word_token","title":"<code>word_token: str</code>  <code>instance-attribute</code>","text":"<p>Normalised and transliterated form of the word. This form is used for searching.</p>"},{"location":"library/Result-Handling/#localization","title":"Localization","text":"<p>Results are always returned with the full list of available names.</p>"},{"location":"library/Result-Handling/#locale","title":"Locale","text":"<p>Helper class for localization of names.</p> <p>It takes a list of language prefixes in their order of preferred usage.</p>"},{"location":"library/Result-Handling/#nominatim.api.Locales.display_name","title":"<code>display_name(names)</code>","text":"<p>Return the best matching name from a dictionary of names containing different name variants.</p> <p>If 'names' is null or empty, an empty string is returned. If no appropriate localization is found, the first name is returned.</p>"},{"location":"library/Result-Handling/#nominatim.api.Locales.from_accept_languages","title":"<code>from_accept_languages(langstr)</code>  <code>staticmethod</code>","text":"<p>Create a localization object from a language list in the format of HTTP accept-languages header.</p> <p>The functions tries to be forgiving of format errors by first splitting the string into comma-separated parts and then parsing each description separately. Badly formatted parts are then ignored.</p>"}]}